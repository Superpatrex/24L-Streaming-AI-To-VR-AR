using System.Collections;
using System.Collections.Generic;
using System.Reflection;
using UnityEngine;

// Copyright (c) 2018-2024 SCSM Pty Ltd. All rights reserved.
namespace scsmmedia
{
    [RequireComponent(typeof(Rigidbody))]
    [RequireComponent(typeof(CapsuleCollider))]
    [AddComponentMenu("Sticky3D Controller/Character/Sticky Control Module")]
    [DisallowMultipleComponent]
    [HelpURL("https://scsmmedia.com/s3d-documentation")]
    public class StickyControlModule : MonoBehaviour, IFloatingTransform
    {
        #region Enumerations

        public enum MoveUpdateType
        {
            Update = 0,
            FixedUpdate = 1
        }

        public enum LookUpdateType
        {
            Automatic = 0,
            FixedUpdate = 1,
            LateUpdate = 2
        }

        public enum ReferenceUpdateType
        {
            Manual = 0,
            Automatic = 1,
            AutoFirst = 2
        }

        public enum RespawningMode
        {
            DontRespawn = 10,
            RespawnAtOriginalPosition = 20,
            RespawnAtLastPosition = 30,
            RespawnAtSpecifiedPosition = 40
        }

        public enum S3Dside
        {
            Left = 0,
            Right = 1
        }

        /// <summary>
        /// Determines which axis are used to constrain hand bone rotation
        /// </summary>
        public enum HandConstraintSettings
        {
            Disabled = -1,
            Auto = 0,
            Option1 = 1,
            Option2 = 2,
            Option3 = 3,
            Option4 = 4
        }

        /// <summary>
        /// The orientation or starting position of the human player
        /// when using a VR headset
        /// </summary>
        public enum HumanPostureVR
        {
            Sitting = 0,
            Standing = 1
        }

        #endregion

        #region Public Static Version Properties
        public static string S3DVersion { get { return "1.1.2"; } }
        public static string S3DBetaVersion { get { return ""; } }
        #endregion

        #region Public Static Variables
        public static int RefUpdateTypeManualInt = (int)ReferenceUpdateType.Manual;
        public static int RefUpdateTypeAutoInt = (int)ReferenceUpdateType.Automatic;
        public static int RefUpdateTypeAutoFirstInt = (int)ReferenceUpdateType.AutoFirst;

        #endregion

        #region Public Variables

        #region Public Variables - General
        /// <summary>
        /// If enabled, the Initialise() will be called as soon as Awake() runs. This should be disabled if you are
        /// instantiating the component through code.
        /// </summary>
        public bool initialiseOnAwake = false;

        // Remember which tabs etc were shown in the editor
        [HideInInspector] public int selectedTabInt = 0;

        /// <summary>
        /// [INTERNAL ONLY]
        /// </summary>
        [HideInInspector] public bool allowRepaint = false;

        #endregion

        #region Public Variables - Move General

        /// <summary>
        /// The speed at which the character can walk in metres per second.
        /// </summary>
        [Range(0.01f, 10f)] public float walkSpeed = 1.5f;
        /// <summary>
        /// The speed at which the character can sprint or run in metres per second.
        /// </summary>
        [Range(0.1f, 20f)] public float sprintSpeed = 4f;
        /// <summary>
        /// The speed at which the character can strafe left or right in metres per second
        /// </summary>
        [Range(0f, 10f)] public float strafeSpeed = 1f;
        /// <summary>
        /// The maximum character movement acceleration in metres per second per second.
        /// </summary>
        [Range(0.1f, 25f)] public float maxAcceleration = 20f;

        /// <summary>
        /// The initial speed added to the character when jumping in metres per second.
        /// </summary>
        [Range(0.1f, 20f)] public float jumpSpeed = 4f;
        /// <summary>
        /// The number of seconds the character delays jumping upward. This is useful when
        /// a jump animation includes an initial movement when the feet are still on the ground.
        /// </summary>
        [Range(0f, 2f)] public float jumpDelay = 0f;
        /// <summary>
        /// The speed at which the character can crouch or stand from a crouch
        /// </summary>
        [Range(0.01f, 10f)] public float crouchSpeed = 1f;
        /// <summary>
        /// Whether movement is allowed while in the air.
        /// </summary>
        public bool allowMovementInAir = false;
        /// <summary>
        /// Can the character sprint or run backward?
        /// </summary>
        public bool allowSprintBackward = true;
        /// <summary>
        /// Gravity in metres per second per second
        /// </summary>
        public float gravitationalAcceleration = 9.81f;
        /// <summary>
        /// This can give your character an arcade-like feel when falling due to gravity. Values > 0
        /// will seem a little retro while values less than 0 will make them parachute or float to the ground
        /// </summary>
        [Range(-2f, 2f)] public float arcadeFallMultiplier = 0f;
        /// <summary>
        /// The maximum height of an object the character can step up onto or over without jumping.
        /// It must be less than half the height of the character.
        /// </summary>
        [Range(0f, 5f)] public float maxStepOffset = 0.2f;
        /// <summary>
        /// The speed at which the character rises up a step
        /// </summary>
        [Range(0.01f, 5f)] public float stepUpSpeed = 1.0f;
        /// <summary>
        /// Dynamically changes the step-up speed while sprinting up steps
        /// </summary>
        [Range(0.1f, 10f)] public float stepUpBias = 1.0f;
        /// <summary>
        /// The maximum slope, in degrees, that the character can walk up
        /// </summary>
        [Range(0f, 180f)] public float maxSlopeAngle = 45f;
        /// <summary>
        /// Will the character's up direction attempt to align with the ground normal? If enabled,
        /// will use the verticalRotationRate.
        /// </summary>
        public bool alignToGroundNormal = false;
        /// <summary>
        /// How quickly, in degrees per second, the character will attempt to match the target Up direction.
        /// Used for reference frame normal and ground normal matching.
        /// </summary>
        [Range(0.1f, 500f)] public float verticalRotationRate = 90f;
        /// <summary>
        /// How quickly, in degrees per second, the character will attempt to match the Free Look camera direction.
        /// </summary>
        [Range(0.1f, 500f)] public float turnRotationRate = 180f;
        /// <summary>
        /// The amount of time that needs to elapse before a stationary character is considered stuck.
        /// When the value is 0, a stationary character is never considered stuck.
        /// </summary>
        [Range(0f, 300)] public float stuckTime = 0f;
        /// <summary>
        /// The maximum speed in m/sec the character can be moving before it can be considered stuck
        /// </summary>
        [Range(0f, 1f)] public float stuckSpeedThreshold = 0.1f;

        /// <summary>
        /// The update loop or timing to use for moving the character.
        /// At runtime call SetMoveUpdateType() to change it.
        /// </summary>
        public MoveUpdateType moveUpdateType = MoveUpdateType.Update;

        #endregion

        #region Public Variables - Move Climbing
        // See also Private Variables - Move Climbing

        /// <summary>
        /// The speed at which the character can climb in metres per second.
        /// </summary>
        [Range(0.01f, 10f)] public float climbSpeed = 0.8f;

        /// <summary>
        /// The minimum slope, in degrees, that the character can climb. Cannot be less than the general walkable Min Slope Angle.
        /// </summary>
        [Range(0f, 180f)] public float minClimbSlopeAngle = 85f;

        /// <summary>
        /// The maximum slope, in degrees, that the character can climb
        /// </summary>
        [Range(0f, 180f)] public float maxClimbSlopeAngle = 90f;

        /// <summary>
        /// The maximum distance infront of the character that the they can reach out
        /// to grab a climable surface when not climbing.
        /// </summary>
        [Range(0f, 5f)] public float maxGrabDistance = 0.5f;

        /// <summary>
        /// The rate at which the character turns to face the surface they are climbing
        /// </summary>
        [Range(0f, 500f)] public float climbFaceSurfaceRate = 100f;

        /// <summary>
        /// Detect when the characters shoulders have reached the top of climbable object.
        /// Shoulder height is set on the Collide tab.
        /// </summary>
        public bool climbTopDetection = false;

        /// <summary>
        /// Climbable obstacles or structures with a collider need to be in one of these layers.
        /// The object must also be included in the Collision Layer Mask on the Collide tab.
        /// </summary>
        public LayerMask climbableLayerMask = Physics.DefaultRaycastLayers;

        #endregion

        #region Public Variables - Move Footsteps

        /// <summary>
        /// Is the character using footstep sounds and effects?
        /// </summary>
        public bool isFootStepsEnabled = false;
        /// <summary>
        /// Reference to a list of common surface types
        /// </summary>
        public S3DSurfaces s3dSurfaces = null;
        /// <summary>
        /// The (child) left foot transform of the character
        /// </summary>
        public Transform leftFoot = null;
        /// <summary>
        /// The (child) right foot transform of the character
        /// </summary>
        public Transform rightFoot = null;
        /// <summary>
        /// Rather than using foot placement, use the character moving speed
        /// </summary>
        public bool footStepsUseMoveSpeed = false;
        /// <summary>
        /// This controls the relative foot step frequency assuming the walk speed is 1.0
        /// Applies when footStepsUseMoveSpeed is true.
        /// </summary>
        [Range(0.05f, 5f)] public float footStepWalkFrequency = 1f;
        /// <summary>
        /// This controls the relative foot step frequency assuming the sprint speed is 1.0
        /// Applies when footStepsUseMoveSpeed is true.
        /// </summary>
        [Range(0.05f, 5f)] public float footStepSprintFrequency = 0.5f;
        /// <summary>
        /// The audio source containing the clip to play when the footsteps are used.
        /// Must be a child of the character gameobject.
        /// Call RefreshFootStepSettings() if changed at runtime.
        /// </summary>
        public AudioSource footStepsAudio = null;
        /// <summary>
        /// The default footstep sound when the walking surface is unknown
        /// </summary>
        public AudioClip footStepsDefaultClip = null;
        /// <summary>
        /// Overall volume of footsteps
        /// </summary>
        [Range(0f, 1f)] public float footStepsVolume = 0.5f;
        /// <summary>
        /// Optional list of S3DFootstep items that can be used to describe how
        /// S3D reacts to stepping on different surface types.
        /// </summary>
        public List<S3DFootstep> s3dFootstepList = null;

        /// <summary>
        /// [INTERNAL ONLY]
        /// </summary>
        public bool isS3DFootstepExpanded = true;

        /// <summary>
        /// [INTERNAL ONLY]
        /// </summary>
        public bool isS3DFootstepListExpanded = true;

        #endregion

        #region Public Variables - Look General
        /// <summary>
        /// Is the camera looking at the character from a distance?
        /// </summary>
        public bool isThirdPerson = false;

        /// <summary>
        /// Is look enabled when the module is first initilised?
        /// This will only occur if the lookCamera is configured.
        /// </summary>
        public bool lookOnInitialise = true;

        /// <summary>
        /// The main first person camera which is a child of the controller
        /// </summary>
        public Camera lookFirstPersonCamera1 = null;

        /// <summary>
        /// The main third person camera which is not a child of the controller
        /// </summary>
        public Camera lookThirdPersonCamera1 = null;

        /// <summary>
        /// Automatically adjust the 1st person camera to the "average" eye height, based on the height of the player
        /// </summary>
        public bool isAutoFirstPersonCameraHeight = false;

        /// <summary>
        /// The parent transform used for first person look direction. Anything that should have its position or orientation modified
        /// by look direction should probably be parented to this transform.
        /// At runtime call SetLookTransform(..).
        /// </summary>
        public Transform lookFirstPersonTransform1;
        /// <summary>
        /// The speed or rate the character can look up or down
        /// </summary>
        [Range(0.1f, 10f)] public float lookVerticalSpeed = 5f;
        /// <summary>
        /// The speed or rate the character can look left or right
        /// </summary>
        [Range(0.1f, 10f)] public float lookHorizontalSpeed = 5f;
        /// <summary>
        /// The amount of damping applied when starting or stopping to look up or down
        /// </summary>
        [Range(0f, 0.1f)] public float lookVerticalDamping = 0.02f;
        /// <summary>
        /// The amount of damping applied when starting or stopping to look left or right
        /// </summary>
        [Range(0f, 0.1f)] public float lookHorizontalDamping = 0.02f;
        /// <summary>
        /// The pitch limit for look upward direction in degrees.
        /// </summary>
        [Range(0f, 90f)] public float lookPitchUpLimit = 90f;
        /// <summary>
        /// The pitch limit for look downward direction in degrees.
        /// </summary>
        [Range(0f, 90f)] public float lookPitchDownLimit = 90f;

        /// <summary>
        /// The camera offset or distance from the character when in third person mode.
        /// Call GetCameraOffsetDistance() after changing this at runtime.
        /// </summary>
        public Vector3 lookCameraOffset = Vector3.zero;

        /// <summary>
        /// The local space point on the character where the third person camera focuses
        /// relative to the origin or pivot point of the character prefab.
        /// </summary>
        public Vector3 lookFocusOffset = Vector3.zero;

        /// <summary>
        /// The speed at which the Third Person camera can adjust to the optimal position
        /// </summary>
        [Range(0.1f, 50f)] public float lookMoveSpeed = 15f;

        /// <summary>
        /// Automatically hide the screen cursor or mouse pointer after it has been stationary
        /// for a fixed period of time. Automatically show the cursor if the mouse if moved.
        /// </summary>
        public bool lookAutoHideCursor = true;

        /// <summary>
        /// The number of seconds to wait until after the cursor has not moved before hiding it
        /// </summary>
        [Range(0f, 10f)] public float lookHideCursorTime = 3f;

        /// <summary>
        /// The delay, in seconds, before zoom starts to return to the non-zoomed position
        /// </summary>
        [Range(0f, 3600f)] public float lookUnzoomDelay = 0f;

        /// <summary>
        /// The camera field-of-view when no zoom is applied to the first person camera
        /// </summary>
        [Range(20f, 85f)] public float lookUnzoomedFoV = 60f;

        /// <summary>
        /// The camera field-of-view when the first person camera is fully zoomed in.
        /// </summary>
        [Range(1f, 50f)] public float lookZoomedFoV = 10f;

        /// <summary>
        /// In third person, the relative amount the camera can zoom out.
        /// </summary>
        [Range(1f, 50f)] public float lookZoomOutFactor = 1f;

        /// <summary>
        /// The delay, in seconds, before the camera orbit starts to return to the default position
        /// </summary>
        [Range(0f, 3600f)] public float lookUnorbitDelay = 0f;

        /// <summary>
        /// The amount of damping applied when starting or stopping camera orbit in third person
        /// </summary>
        [Range(0f, 1f)] public float lookOrbitDamping = 0.1f;

        /// <summary>
        /// The minimum anti-clockwise angle to rotate the camera around the character
        /// </summary>
        [Range(-360f, 0f)] public float lookOrbitMinAngle = -360f;

        /// <summary>
        /// The maximum clockwise angle to rotate the camera around the character
        /// </summary>
        [Range(0f, 360f)] public float lookOrbitMaxAngle = 360f;

        /// <summary>
        /// Maximum line-of-sight field-of-view
        /// </summary>
        [Range(5f, 360f)] public float lookMaxLoSFoV = 60f;

        /// <summary>
        /// The distance the focus point can move before the third person camera reacts
        /// </summary>
        //[Range(0f, 10f)] public float lookFocusTolerance = 0f;

        /// <summary>
        /// The maximum strength of the third person camera shake. Smaller numbers are better.
        /// This can be overridden by calling ShakeCamera(duration,strength).
        /// </summary>
        [Range(0f, 1.0f)] public float lookMaxShakeStrength = 0f;

        /// <summary>
        /// The maximum duration (in seconds) the third person camera will shake per incident.
        /// This can be overridden by calling ShakeCamera(duration,strength).
        /// </summary>
        [Range(0.1f, 5f)] public float lookMaxShakeDuration = 0.2f;

        /// <summary>
        /// The update loop or timing to use for moving or rotate the camera.
        /// At runtime call SetLookUpdateType() to change it.
        /// </summary>
        public LookUpdateType lookUpdateType = LookUpdateType.Automatic;

        #endregion

        #region Public Variables - Look Clip Objects

        /// <summary>
        /// Adjust the camera position to attempt to avoid the camera flying through objects between the character and the camera.
        /// </summary>
        public bool clipObjects = false;

        /// <summary>
        /// The minimum speed the camera will move to avoid flying through objects between the character and the camera.
        /// High values make clipping more effective. Lower values will make it smoother.
        /// Currently this has no effect if Lock to Target Position is enabled.
        /// </summary>
        [Range(1f, 100f)] public float minClipMoveSpeed = 10f;

        /// <summary>
        /// When clipObjects is true, the minimum distance the camera can be from the character position.
        /// Typically this is the radius of the character.
        /// </summary>
        [Range(0f, 1000f)] public float clipMinDistance = 0f;

        /// <summary>
        /// The minimum offset on the x-axis, in metres, the camera can be from the character when object clipping. This should be less than or equal to the Camera Offset X value. 
        /// </summary>
        [Range(0f, 50f)] public float clipMinOffsetX = 0f;

        /// <summary>
        /// The minimum offset on the y-axis, in metres, the camera can be from the character when object clipping. This should be less than or equal to the Camera Offset Y value.
        /// </summary>
        [Range(0f, 50)] public float clipMinOffsetY = 0f;

        /// <summary>
        /// The responsiveness to changes in the clipping distance. When 1.0, it will depend on the
        /// Min Move Speed and the Camera Move Speed. Reducing the responsiveness can stabilise
        /// clipping when the character is moving erratically or on a vehicle that is.
        /// </summary>
        [Range(0.1f, 1f)] public float clipResponsiveness = 1f;

        /// <summary>
        /// Clip objects in the selected Unity Layers.
        /// Start with Nothing (0) and call ResetClipObjectSettings()
        /// </summary>
        public LayerMask clipObjectMask = 0;

        #endregion

        #region Public Variables - Look Interactive
        /// <summary>
        /// When look interactive is enabled, how far away from the camera can the character see objects with a StickyInteractive component?
        /// </summary>
        [Range(0.01f, 200f)] public float lookMaxInteractiveDistance = 5f;

        /// <summary>
        /// The non-trigger colliders and characters in these Unity layers can be seen when Look Interactive is enabled
        /// </summary>
        public LayerMask lookInteractiveLayerMask = Physics.DefaultRaycastLayers;

        /// <summary>
        /// Instead of using the mouse or cursor position, always look in the direction the camera is facing.
        /// </summary>
        public bool lookInteractiveLockToCamera = false;

        #endregion

        #region Public Variables - Look Sockets
        /// <summary>
        /// When look sockets is enabled, how far away from the camera can the character see objects with a StickySocket component?
        /// </summary>
        [Range(0.01f, 200f)] public float lookMaxSocketDistance = 5f;

        /// <summary>
        /// The trigger colliders in these Unity layers can be seen when Look Sockets is enabled
        /// </summary>
        public LayerMask lookSocketLayerMask = Physics.DefaultRaycastLayers;

        /// <summary>
        /// Instead of using the mouse or cursor position, always look in the direction the camera is facing.
        /// </summary>
        public bool lookSocketLockToCamera = false;

        #endregion

        #region Public Variables - Look VR

        /// <summary>
        /// When isMoveSnapTurnVR is enabled, the number of degrees turned with each snap movement.
        /// </summary>
        [Range(10f, 180f)] public float snapTurnDegrees = 30f;

        /// <summary>
        /// The minimum amount of time required between snap turns
        /// </summary>
        [Range(0.1f, 5f)] public float snapTurnIntervalTime = 0.5f;

        #endregion

        #region Public Variables - Collide
        /// <summary>
        /// The height of the character collider in metres.
        /// Average height of western men ~ 1.75
        /// Average height of western women ~ 1.62
        /// </summary>
        public float height = 1.75f;
        /// <summary>
        /// The radius of the character collider in metres.
        /// Average shoulder width of 0.46 m
        /// </summary>
        public float radius = 0.23f;
        /// <summary>
        /// The distance, in the up direction, from the pivot point to the centre of the model.
        /// If the pivot point is at the feet, this will be half the height.
        /// </summary>
        public float pivotToCentreOffsetY = 0f;
        /// <summary>
        /// The height of the shoulders. Men typically have a shoulder height 0.82 x height,
        /// while females are 0.81 x the height.
        /// </summary>
        public float shoulderHeight = 1.435f;
        /// <summary>
        /// The normalised height of the character when crouching, relative to the height
        /// </summary>
        [Range(0.1f, 0.9f)] public float crouchHeightNormalised = 0.5f;

        /// <summary>
        /// The maximum number of sweep iterations allowed per frame.
        /// </summary>
        [Range(2, 5)] public int maxSweepIterations = 3;
        /// <summary>
        /// The tolerance allowed for sweeps and is grounded checks in metres.
        /// </summary>
        [Range(0.001f, 0.05f)] public float sweepTolerance = 0.02f;
        /// <summary>
        /// The layer mask used for collision testing for the character.
        /// </summary>
        public LayerMask collisionLayerMask = Physics.DefaultRaycastLayers;

        /// <summary>
        /// The character will attempt to interact with dynamic rigidbodies in these layers.
        /// Default: Nothing. Do NOT include any layers from the Reference Layer Mask.
        /// </summary>
        public LayerMask interactionLayerMask = 0;

        /// <summary>
        /// Call OnTriggerEnter or Exit when character enters or exits a Trigger Collider.
        /// This must be enabled if using StickyZones.
        /// </summary>
        public bool isOnTriggerEnterEnabled = false;
        /// <summary>
        /// Call OnTriggerStay EVERY FRAME while the character is inside a Trigger Collider
        /// </summary>
        public bool isOnTriggerStayEnabled = false;
        /// <summary>
        /// Rather than disabling the capsule collider at runtime, it is converted to a trigger collider
        /// so that it can be detected by raycasts.
        /// Character will be pushed by other moving objects that have colliders.
        /// </summary>
        public bool isTriggerColliderEnabled = true;

        /// <summary>
        /// When entering or exiting a StickyZone, allow configuration changes based on zone settings
        /// </summary>
        public bool isReactToStickyZonesEnabled = true;

        /// <summary>
        /// Does the character slide along walls or simply stop?
        /// </summary>
        //public bool isWallSlideEnabled = true;

        /// <summary>
        /// The Unity Layers used to test if the object under the character is a suitable Reference Frame.
        /// </summary>
        public LayerMask referenceFrameLayerMask = 0;

        /// <summary>
        /// Determines how the reference frame is updated. Manual, the default, is used when not updating
        /// it, when it is updated by your code by calling SetReferenceFrame() or via a StickyZone.
        /// Automatic attempts to set the reference frame for you.
        /// To change at runtime, call SetReferenceUpdateType().
        /// </summary>
        public ReferenceUpdateType referenceUpdateType = ReferenceUpdateType.Manual;

        /// <summary>
        /// When referenceUpdateType is Automatic or AutoFirst, when detecting a collider
        /// that is attached to or a child of a rigidbody, the reference frame will be
        /// set to the transform of the rigidbody rather than the transform of the collider.
        /// </summary>
        public bool isUseRBodyReferenceFrame = false;

        /// <summary>
        /// Initial or default reference frame transform the character will stick to.
        /// </summary>
        public Transform initialReferenceFrame;

        #endregion

        #region Public Variables - JetPack
        /// <summary>
        /// Is the Jet Pack feature selectable by the player?
        /// </summary>
        public bool isJetPackAvailable = false;
        /// <summary>
        /// Current available fuel level
        /// </summary>
        [Range(0f, 100f)] public float jetPackFuelLevel = 100f;

        /// <summary>
        /// The rate fuel is consumed per second. If rate is 0, fuel is unlimited
        /// </summary>
        [Range(0f, 20f)] public float jetPackFuelBurnRate = 0.1f;

        /// <summary>
        /// Maximum speed the jet pack can propel the character
        /// </summary>
        [Range(0.01f, 10f)] public float jetPackSpeed = 3f;

        /// <summary>
        /// The maximum jet pack acceleration in metres per second per second.
        /// </summary>
        [Range(0.1f, 5f)] public float jetPackMaxAcceleration = 2f;

        /// <summary>
        /// The damping force applied to slow down movement when no input is received
        /// </summary>
        [Range(0f, 1f)] public float jetPackDamping = 0.5f;

        /// <summary>
        /// The audio source containing the clip to play when the jetpack is used.
        /// Must be a child of the character gameobject.
        /// </summary>
        public AudioSource jetPackAudio = null;

        /// <summary>
        /// The number of seconds it takes for this jet pack to go from minimum to maximum power.
        /// </summary>
        [Range(0f, 5f)] public float jetPackRampUpDuration = 0.1f;

        /// <summary>
        /// The number of seconds it takes for this jet pack to go from maximum to minimum power.
        /// </summary>
        [Range(0f, 5f)] public float jetPackRampDownDuration = 0.1f;

        // Jet Pack thruster particle effect parent gameobjects
        public GameObject jetPackThrusterFwd = null;
        public GameObject jetPackThrusterBack = null;
        public GameObject jetPackThrusterUp = null;
        public GameObject jetPackThrusterDown = null;
        public GameObject jetPackThrusterRight = null;
        public GameObject jetPackThrusterLeft = null;

        /// <summary>
        /// The 0.0-1.0 value that indicates the minimum normalised amount of any particle effects that are
        /// applied when a non-zero jet pack input is received. Default is 0. If the full particle emission
        /// rate should be applied when any input is received, set the value to 1.0.
        /// </summary>
        [Range(0f, 1f)] public float jetPackMinEffectsRate;

        /// <summary>
        /// [INTERNAL ONLY]
        /// </summary>
        public bool isJetPackThrusterListExpanded = false;

        #endregion

        #region Public Variables - Animate General
        public Animator defaultAnimator;
        public List<S3DAnimAction> s3dAnimActionList;
        #endregion

        #region Public Variables - Animate Aim IK

        /// <summary>
        /// The camera offset or distance from the character when in third person weapon aiming mode.
        /// </summary>
        public Vector3 aimIKCameraOffsetTPS = Vector3.zero;

        /// <summary>
        /// The maximum rotation, in degrees, each bone for Aim IK can pitch down
        /// </summary>
        [Range(0f, 90f)] public float aimIKDownLimit = 40f;
        /// <summary>
        /// The maximum rotation, in degrees, each bone for Aim IK can pitch up
        /// </summary>
        [Range(0f, 90f)] public float aimIKUpLimit = 40f;
        /// <summary>
        /// The maximum rotation, in degrees, the held weapon can point left.
        /// </summary>
        [Range(0f, 90f)] public float aimIKLeftLimit = 80f;
        /// <summary>
        /// The maximum rotation, in degrees, the held weapon can point right.
        /// </summary>
        [Range(0f, 90f)] public float aimIKRightLimit = 80f;

        #endregion

        #region Public Variables - Animate Foot IK
        /// <summary>
        /// The rate at which the character's y-axis position is adjusted for foot IK placement
        /// </summary>
        [Range(0.01f, 100f)] public float footIKBodyMoveSpeedY = 20f;
        /// <summary>
        /// The maximum rotation, in degrees, the foot can roll or rotate inward
        /// </summary>
        [Range(0f, 90f)] public float footIKMaxInwardRotationX = 60f;
        /// <summary>
        /// The maximum rotation, in degrees, the foot can roll or rotate outward
        /// </summary>
        [Range(0f, 90f)] public float footIKMaxOutwardRotationX = 60f;

        /// <summary>
        /// The maximum rotation, in degrees, the foot can pitch forward or back
        /// </summary>
        [Range(0f, 90f)] public float footIKMaxPitchZ = 60f;

        /// <summary>
        /// Only adjust the position of the feet. Do not modify the rotation.
        /// </summary>
        public bool footIKPositionOnly = false;

        /// <summary>
        /// The rate at which the foot rotates to match the slope
        /// </summary>
        [Range(0.1f, 100f)] public float footIKSlopeReactRate = 10f;

        /// <summary>
        /// The minimum slope that is required before the feet will be rotated to match the
        /// slope under the character. This can allow the character to use foot rotations
        /// from the animation when standing or moving on relatively flat surfaces.
        /// </summary>
        [Range(0f, 5f)] public float footIKSlopeTolerance = 0.1f;

        /// <summary>
        /// The distance, in metres, from the foot bone to the end of the toes or the front of the foot.
        /// </summary>
        [Range(0f, 0.5f)] public float footIKToeDistance = 0.2f;

        #endregion

        #region Public Variables - Animate Head IK

        /// <summary>
        /// The maximum rate at which the character's head turns towards the target position.
        /// In future may also provide a min speed to allow a variable rate.
        /// </summary>
        [Range(0f, 25f)] public float headIKMoveMaxSpeed = 3f;
        /// <summary>
        /// When the character or the target is moving quickly this may help the head adjust
        /// quickly to the rapidly changing positions [DEFAULT: OFF]. Has performance overhead.
        /// </summary>
        public bool headIKAdjustForVelocity = false;
        /// <summary>
        /// The amount of damping to apply when starting or stopping to turn the character's
        /// head toward a target position.
        /// </summary>
        [Range(0f, 1f)] public float headIKMoveDamping = 0.25f;
        /// The Head IK look upward rotation limit in degrees
        /// </summary>
        [Range(0f, 90f)] public float headIKLookUpLimit = 40f;
        /// <summary>
        /// The Head IK look downward rotation limit in degrees
        /// </summary>
        [Range(0f, 90f)] public float headIKLookDownLimit = 40f;
        /// The Head IK look left rotation limit in degrees
        /// </summary>
        [Range(0f, 90f)] public float headIKLookLeftLimit = 80f;
        /// <summary>
        /// The Head IK look right rotation limit in degrees
        /// </summary>
        [Range(0f, 90f)] public float headIKLookRightLimit = 80f;
        /// <summary>
        /// How much the eyes are used to look towards the target
        /// </summary>
        [Range(0f, 1f)] public float headIKEyesWeight = 0.2f;
        /// <summary>
        /// How much the head is used to look towards the target
        /// </summary>
        [Range(0f, 1f)] public float headIKHeadWeight = 0.8f;
        /// <summary>
        /// If Head IK is enabled, the head (also) turns towards the target while climbing
        /// </summary>
        public bool headIKWhenClimbing = false;
        /// <summary>
        /// If Head IK is enabled, the head can turn towards the target while the character movement
        /// is disabled. For example, when the character is seated.
        /// </summary>
        public bool headIKWhenMovementDisabled = false;
        /// <summary>
        /// How much the upper body is used to look towards the target
        /// </summary>
        [Range(0f, 1f)] public float headIKBodyWeight = 0.1f;
        /// <summary>
        /// Will the character's look direction be affected if the target is behind them?
        /// </summary>
        public bool headIKConsiderBehind = false;

        #endregion

        #region Public Variables - Animate Hand IK

        /// <summary>
        /// The maximum rate at which the character's hands move toward the target position.
        /// In future may also provide a min speed to allow a variable rate.
        /// </summary>
        [Range(0f, 25f)] public float handIKMoveMaxSpeed = 3f;
        /// <summary>
        /// If Hand IK is enabled, the hands can move while the character movement
        /// is disabled. For example, when the character is seated or stationary.
        /// </summary>
        public bool handIKWhenMovementDisabled = false;
        /// <summary>
        /// How close an object must be to a hand before it is considered to be touching it.
        /// Currently both left and right hands share the same radius.
        /// </summary>
        [Range(0.01f, 2f)] public float leftHandRadius = 0.1f;

        /// <summary>
        /// Determines which axis are used to constrain left hand bone rotation
        /// </summary>
        public HandConstraintSettings leftHandConstraintSettings = HandConstraintSettings.Auto;
        /// <summary>
        /// Determines which axis are used to constrain right hand bone rotation
        /// </summary>
        public HandConstraintSettings rightHandConstraintSettings = HandConstraintSettings.Auto;

        /// <summary>
        /// The Hand IK left hand max rotation (to the right) in degrees
        /// </summary>
        [Range(0, 90f)] public float handIKLHMaxInRot = 40f;
        /// <summary>
        /// The Hand IK left hand max rotation (to the left) in degrees
        /// </summary>
        [Range(0, 90f)] public float handIKLHMaxOutRot = 40f;
        /// <summary>
        /// The Hand IK left hand max rotation up in degrees
        /// </summary>
        [Range(0, 90f)] public float handIKLHMaxUpRot = 80f;
        /// <summary>
        /// The Hand IK left hand max rotation down in degrees
        /// </summary>
        [Range(0, 90f)] public float handIKLHMaxDownRot = 80f;

        /// <summary>
        /// The Hand IK right hand max rotation (to the left) in degrees
        /// </summary>
        [Range(0, 90f)] public float handIKRHMaxInRot = 40f;
        /// <summary>
        /// The Hand IK right hand max rotation (to the right) in degrees
        /// </summary>
        [Range(0, 90f)] public float handIKRHMaxOutRot = 40f;
        /// The Hand IK right hand max rotation up in degrees
        /// </summary>
        [Range(0, 90f)] public float handIKRHMaxUpRot = 80f;
        /// <summary>
        /// The Hand IK right hand max rotation down in degrees
        /// </summary>
        [Range(0, 90f)] public float handIKRHMaxDownRot = 80f;

        /// The Hand IK left hand inward movement (to the right) limit in degrees.
        /// This limits where the hand can move. For wrist rotation see
        /// handIKLHInMaxRot and handIKLHOutMaxRot
        /// </summary>
        [Range(0f, 90f)] public float handIKLHInwardLimit = 30f;
        /// The Hand IK left hand outward movement (to the left) limit in degrees.
        /// Currently the left hand cannot reach behind the character.
        /// </summary>
        [Range(0f, 90f)] public float handIKLHOutwardLimit = 90f;
        /// The Hand IK right hand inward movement (to the left) limit in degrees
        /// This limits where the hand can move. For wrist rotation see
        /// handIKRHInMaxRot and handIKRHOutMaxRot
        /// </summary>
        [Range(0f, 90f)] public float handIKRHInwardLimit = 30f;
        /// The Hand IK right hand outward movement (to the right) limit in degrees.
        /// Currently the right hand cannot reach behind the character.
        /// </summary>
        [Range(0f, 90f)] public float handIKRHOutwardLimit = 90f;

        #endregion

        #region Public Variables - Animate Hand VR

        /// <summary>
        /// The animator used to animate a Virtual Reality left hand
        /// </summary>
        public Animator leftHandAnimator = null;

        /// <summary>
        /// The animator used to animate a Virtual Reality right hand
        /// </summary>
        public Animator rightHandAnimator = null;

        #endregion

        #region Public Variables - Animate Ragdoll

        #endregion

        #region Public Variables - Engage

        /// <summary>
        /// The rate at which an interactive object is pulled toward or pushed away from
        /// a character when interacting with objects. Currently works with socketed objects.
        /// When 0, objects are instantly snapped into position.
        /// </summary>
        [Range(0f, 50f)] public float lassoSpeed = 10f;

        /// <summary>
        /// These are triggered by a S3D character after it has been initialised.
        /// </summary>
        public S3DEngageEvt1 onInitialised = null;

        /// <summary>
        /// These are triggered when the character is destroyed or when it reaches 0 health.
        /// See also callbackOnDestroy.
        /// </summary>
        public S3DEngageEvt3 onDestroyed = null;

        /// <summary>
        /// These are triggered by a S3D character when they start or stop looking
        /// at an interactive-enabled object in the scene.
        /// </summary>
        public S3DEngageEvt2 onInteractLookAtChanged = null;

        /// <summary>
        /// These are triggered by a S3D character immediately before they start aiming a weapon
        /// </summary>
        public S3DEngageEvt4 onPreStartAim = null;

        /// <summary>
        /// These are triggered by a S3D character immediately after they start aiming a weapon
        /// </summary>
        public S3DEngageEvt4 onPostStartAim = null;

        /// <summary>
        /// These are triggered by a S3D character immediately before they stop aiming a weapon
        /// </summary>
        public S3DEngageEvt4 onPreStopAim = null;

        /// <summary>
        /// These are triggered by a S3D character immediately after they stop aiming a weapon
        /// </summary>
        public S3DEngageEvt4 onPostStopAim = null;

        /// <summary>
        /// These are triggered by a S3D character immediately before they start holding a weapon
        /// </summary>
        public S3DEngageEvt4 onPreStartHoldWeapon = null;

        /// <summary>
        /// These are triggered by a S3D character immediately after they stop holding a weapon
        /// </summary>
        public S3DEngageEvt4 onPostStopHoldWeapon = null;

        /// <summary>
        /// These are triggered when the character has just been respawned
        /// </summary>
        public S3DEngageEvt3 onRespawned = null;

        /// <summary>
        /// These are triggered when the character is about to be respawned.
        /// </summary>
        public S3DEngageEvt3 onRespawning = null;

        #endregion

        #region Public Variables - Engage Identification

        /// <summary>
        /// The faction or alliance the character belongs to. This can be used to identify
        /// if a character is friend or foe. Neutral = 0.
        /// </summary>
        public int factionId = 0;

        /// <summary>
        /// The type, category, or model of the character. Can be useful if you have a group
        /// of characters with similar attributes.
        /// For your own models, use numbers above 100 as numbers 1 to 99 are reserved for Sticky3D models.
        /// </summary>
        public int modelId = 0;

        #endregion

        #region Public Variables - Engage Respawning

        /// <summary>
        /// Should the character attempt to drop any held interactive objects when health reaches 0?
        /// </summary>
        public bool isDropHeldOnDestroy = false;

        /// <summary>
        /// Should the character attempt to drop any equipped interactive objects when health reaches 0?
        /// </summary>
        public bool isDropEquipOnDestroy = false;

        /// <summary>
        /// Should the character attempt to drop any stashed interactive objects when health reaches 0?
        /// </summary>
        public bool isDropStashOnDestroy = false;

        /// <summary>
        /// Should the ragdoll be enabled when health reaches 0?
        /// </summary>
        public bool isRagdollOnDestroy = false;

        /// <summary>
        /// How long the respawning process takes (in seconds). Only relevant when respawnMode is not set to DontRespawn.
        /// </summary>
        [Range(0f, 300f)] public float respawnTime = 10f;

        /// <summary>
        /// Where the character respawns from in world space when respawnMode is set to RespawnFromSpecifiedPosition.
        /// </summary>
        public Vector3 customRespawnPosition = Vector3.zero;

        /// <summary>
        /// The Euler rotation angles the character respawns from in world space when respawnMode is set to RespawnFromSpecifiedPosition.
        /// </summary>
        public Vector3 customRespawnRotation = Vector3.zero;

        #endregion

        #region Public Variables - Engage Equip
        /// <summary>
        /// The colour of the selected Equip Points in the scene view
        /// Non-selected points are slightly transparent
        /// </summary>
        public Color equipPointGizmoColour = new Color(1f, 0.92f, 0.016f, 1.0f);

        /// <summary>
        /// The minimum distance on the local x or z axis an equipped
        /// object can be dropped from the character capsule collider.
        /// </summary>
        [Range(0f, 10f)] public float minEquipDropDistance = 0.3f;

        /// <summary>
        /// The maximum distance on the local x or z axis an equipped
        /// object can be dropped from the character capsule collider.
        /// </summary>
        [Range(0f, 10f)] public float maxEquipDropDistance = 1f;

        #endregion

        #region Public Variables - Engage Stash

        /// <summary>
        /// The minimum distance on the local x or z axis a stashed
        /// object can be dropped from the character capsule collider.
        /// </summary>
        [Range(0f, 10f)] public float minStashDropDistance = 0.3f;

        /// <summary>
        /// The maximum distance on the local x or z axis a stashed
        /// object can be dropped from the character capsule collider.
        /// </summary>
        [Range(0f, 10f)] public float maxStashDropDistance = 1f;

        #endregion

        #endregion

        #region Public Properties - General

        /// <summary>
        /// [READONLY] The runtime identification number of the character
        /// </summary>
        public int StickyID { get { return capsuleColliderId; } }

        /// <summary>
        /// [READONLY] Get the main rigidbody for the character controller
        /// </summary>
        public Rigidbody CharacterRigidBody { get { return isInitialised ? rBody : GetComponent<Rigidbody>(); } }

        /// <summary>
        /// Get or set the colour typically used for when the character engages with an interactive-enabled object in the scene.
        /// Used with the StickyDisplayModule reticle.
        /// </summary>
        public Color32 EngageColour { get { return engageColour; } set { SetEngageColour(value); } }

        /// <summary>
        /// Get or set the colour typically used for when the character is not engaging with an interactive-enabled object in the scene.
        /// Used with the StickyDisplayModule reticle.
        /// </summary>
        public Color32 NonegageColour { get { return nonengageColour; } set { SetNonEngageColour(value); } }

        /// <summary>
        /// [READONLY] Has the character movement script been initialised?
        /// </summary>
        public bool IsInitialised { get { return isInitialised; } }

        /// <summary>
        /// [READONLY] Is animate enabled and ready to animate the character?
        /// </summary>
        public bool IsAnimateEnabled { get { return isAnimateEnabled; } }

        /// <summary>
        /// [READONLY] Is audio muted for this character?
        /// </summary>
        public bool IsAudioMuted { get { return isAudioMuted; } }

        /// <summary>
        /// [READONLY] Is the left hand holding and interactive-enabled magazine?
        /// </summary>
        public bool IsLeftHandHoldingMagazine { get { return isLeftHandHoldingMagazine && leftHandInteractiveId != StickyInteractive.NoID; } }

        /// <summary>
        /// [READONLY] Is the left hand holding and interactive-enabled weapon?
        /// </summary>
        public bool IsLeftHandHoldingWeapon { get { return isLeftHandHoldingWeapon && leftHandInteractiveId != StickyInteractive.NoID; } }

        /// <summary>
        /// [READONLY] Is the left hand holding an interactive-enabled object?
        /// </summary>
        public bool IsLeftHandHoldingInteractive { get { return leftHandInteractiveId != StickyInteractive.NoID; } }

        /// <summary>
        /// [READONLY] Is the right hand holding and interactive-enabled magazine?
        /// </summary>
        public bool IsRightHandHoldingMagazine { get { return isRightHandHoldingMagazine && rightHandInteractiveId != StickyInteractive.NoID; } }

        /// <summary>
        /// [READONLY] Is the right hand holding and interactive-enabled weapon?
        /// </summary>
        public bool IsRightHandHoldingWeapon { get { return isRightHandHoldingWeapon && rightHandInteractiveId != StickyInteractive.NoID; } }

        /// <summary>
        /// [READONLY] Is the right hand holding an interactive-enabled object?
        /// </summary>
        public bool IsRightHandHoldingInteractive { get { return rightHandInteractiveId != StickyInteractive.NoID; } }

        /// <summary>
        /// [READONLY] Is Head IK enabled and ready for use?
        /// </summary>
        public bool IsHeadIKEnabled { get { return isAnimateEnabled && isHeadIK; } }

        /// <summary>
        /// [READONLY] Is Head IK in the process of being smoothly disabled over several frames?
        /// </summary>
        public bool IsHeadIKDisabling { get { return isAnimateEnabled && isHeadIK && isHeadIKSmoothDisable; } }

        /// <summary>
        /// [READONLY] Is Foot IK enabled and ready for use?
        /// </summary>
        public bool IsFootIKEnabled { get { return isAnimateEnabled && isFootIK; } }

        /// <summary>
        /// [READONLY] Is the character idle (will also return true when not initialised or movement is disabled).
        /// If this is changed, also need to change IsIdle in GetAnimateBoolValue(..).
        /// </summary>
        public bool IsIdle { get { return !isInitialised || !isMovementEnabled || (!isClimbing && currentLocalVelocity.sqrMagnitude < moveIdleThreshold); } }

        /// <summary>
        /// [READONLY] Is the character walking?
        /// </summary>
        public bool IsWalking { get { return isInitialised && isMovementEnabled && isGrounded && !isStepping && !isClimbing && !currentSprintInput && (currentLocalVelocity.z > moveIdleThreshold || currentLocalVelocity.z < -moveIdleThreshold); } }

        /// <summary>
        /// [READONLY] Is the character walking forwards?
        /// </summary>
        public bool IsWalkingForward { get { return isInitialised && isMovementEnabled && isGrounded && !isStepping && !isClimbing && !currentSprintInput && (currentLocalVelocity.z > moveIdleThreshold); } }

        /// <summary>
        /// [READONLY] Is the character walking backwards?
        /// </summary>
        public bool IsWalkingBackward { get { return isInitialised && isMovementEnabled && isGrounded && !isStepping && !isClimbing && !currentSprintInput && (currentLocalVelocity.z < -moveIdleThreshold); } }

        /// <summary>
        /// [READONLY] Is the character walking or strafing?
        /// </summary>
        public bool IsWalkingOrStrafing { get { return isInitialised && isMovementEnabled && isGrounded && !isStepping && !isClimbing && !currentSprintInput && (currentLocalVelocity.z > moveIdleThreshold || currentLocalVelocity.z < -moveIdleThreshold || currentLocalVelocity.x > moveIdleThreshold || currentLocalVelocity.x < -moveIdleThreshold); } }

        /// <summary>
        /// [READONLY] Is the character walking or sprinting ?
        /// </summary>
        public bool IsWalkingOrSprinting { get { return isInitialised && isMovementEnabled && isGrounded && !isStepping && !isClimbing && (currentLocalVelocity.z > moveIdleThreshold || currentLocalVelocity.z < -moveIdleThreshold); } }

        /// <summary>
        /// Is the character sitting down?
        /// </summary>
        public bool IsSitting { get { return isInitialised && isSitting; } set { isSitting = value; } }

        /// <summary>
        /// [READONLY] Is the character currently running? To set, call SendInput(..).
        /// </summary>
        public bool IsSprinting { get { return isMovementEnabled && currentSprintInput && !isClimbing; } }

        /// <summary>
        /// [READONLY] Is the character strafing or moving sideways?
        /// </summary>
        public bool IsStrafing { get { return isInitialised && isMovementEnabled && isGrounded && !isStepping && !isClimbing && (currentLocalVelocity.x > moveIdleThreshold || currentLocalVelocity.x < -moveIdleThreshold); } }

        /// <summary>
        /// [READONLY] Is the character strafing right or moving sideways to the right?
        /// </summary>
        public bool IsStrafingRight { get { return isInitialised && isMovementEnabled && isGrounded && !isStepping && !isClimbing && (currentLocalVelocity.x > moveIdleThreshold); } }

        /// <summary>
        /// [READONLY] Is the character strafing left or moving sideways to the left?
        /// </summary>
        public bool IsStrafingLeft { get { return isInitialised && isMovementEnabled && isGrounded && !isStepping && !isClimbing && (currentLocalVelocity.x < -moveIdleThreshold); } }

        /// <summary>
        /// [READONLY] Is the character crouching?
        /// </summary>
        public bool IsCrouching { get { return currentCrouchInput || isForcedCrouch; } }

        /// <summary>
        /// [READONLY] Is character movement enabled?
        /// </summary>
        public bool IsMovementEnabled { get { return isMovementEnabled; } }

        /// <summary>
        /// [READONLY] Is the character being moved or rotated in the FixedUpdate() loop?
        /// </summary>
        public bool IsMoveFixedUpdate { get { return isInitialised ? isMoveFixedUpdate : moveUpdateType == MoveUpdateType.FixedUpdate; } }

        /// <summary>
        /// [READONLY] Is the character on the ground?
        /// </summary>
        public bool IsGrounded { get { return isGrounded; } }

        /// <summary>
        /// [READONLY] Is the character landing on the ground this frame?
        /// </summary>
        public bool IsLanding { get { return isLanding; } }

        /// <summary>
        /// [READONLY] Has the character started a jump in this frame?
        /// </summary>
        public bool IsJumping { get { return isJumpStartedThisFrame; } }

        /// <summary>
        /// [READONLY] Is the character currently climbing a wall?
        /// </summary>
        public bool IsClimbing { get { return isClimbingEnabled && isClimbing; } }

        /// <summary>
        /// [READONLY] Is the character climbing and the shoulders are level with, or above, the top of the object being climbed?
        /// </summary>
        public bool IsClimbingAtTop { get { return isClimbingAtTop && isClimbingEnabled && isClimbing; } }

        /// <summary>
        /// [READONLY] Has the height of the character or the floor offset of the camera been calibrated based on the position
        /// of the head-mounted device?
        /// </summary>
        public bool IsHeightCalibratedVR { get { return isHeightCalibratedVR; } internal set { isHeightCalibratedVR = value; } }

        /// <summary>
        /// [READONLY] Is the character position only modified when the reference frame object moves?
        /// </summary>
        public bool IsPositionLocked { get { return isPositionLocked; } }

        /// <summary>
        /// [READONLY] Is the character walking up a step?
        /// </summary>
        public bool IsStepping { get { return isStepping; } }

        /// <summary>
        /// [READONLY] Is the character walking down a step?
        /// </summary>
        public bool IsSteppingDown { get { return isSteppingDown; } }

        /// <summary>
        /// [READONLY] Is the character trying to move, but cannot?
        /// </summary>
        public bool IsStuck { get { return isStuck; } }

        /// <summary>
        /// [READONLY] Is sprint input being received by the character?
        /// </summary>
        public bool IsSprintInput { get { return isInitialised && isMovementEnabled && currentSprintInput; } }

        /// <summary>
        /// [READONLY] Is strafe left or right input being received by the character?
        /// </summary>
        public bool IsStrafeInput { get { return isInitialised && isMovementEnabled && (currentLocalSpaceMovementInput.x > 0.0001f || currentLocalSpaceMovementInput.x < -0.0001f); } }

        /// <summary>
        /// [READONLY] Is walk forward or backward input being received by the character?
        /// </summary>
        public bool IsWalkInput { get { return isInitialised && isMovementEnabled && !currentSprintInput && (currentLocalSpaceMovementInput.z > 0.0001f || currentLocalSpaceMovementInput.z < -0.0001f); } }

        /// <summary>
        /// [READONLY] Is the point in world space where the user is currently focusing, being updated?
        /// Requires Look Interactive to be enabled.
        /// </summary>
        public bool IsUpdateLookingAtPoint { get { return isLookInteractiveEnabled && isUpdateLookingAtPoint; } }

        /// <summary>
        /// [READONLY] Get the velocity of the character relative to the reference object.
        /// </summary>
        public Vector3 GetCurrentLocalVelocity { get { return currentLocalVelocity; } }

        /// <summary>
        /// [READONLY] Get the current forward direction the character is facing
        /// </summary>
        public Vector3 GetCurrentForward { get { return isInitialised ? currentCharacterFwd : transform.forward; } }

        /// <summary>
        /// [READONLY] Get the current inverse rotation in worldspace. Helpful to calc local space rotation GetCurrentInverseRotation * otherObjectWSRotation
        /// </summary>
        public Quaternion GetCurrentInverseRotation { get { return Quaternion.Inverse(isInitialised ? currentWorldRotation : transform.rotation); } }

        /// <summary>
        /// [READONLY] Get the current world space position
        /// </summary>
        public Vector3 GetCurrentPosition { get { return isInitialised ? currentWorldPosition : transform.position; } }

        /// <summary>
        /// [READONLY] Get the current character world space rotation
        /// </summary>
        public Quaternion GetCurrentRotation { get { return isInitialised ? currentWorldRotation : transform.rotation; } }

        /// <summary>
        /// [READONLY] Get the current up direction for the character
        /// </summary>
        public Vector3 GetCurrentUp { get { return isInitialised ? currentCharacterUp : transform.up; } }

        /// <summary>
        /// [READONLY] Get the current (calculated) character world space velocity.
        /// You can also get it from the 
        /// </summary>
        public Vector3 GetCurrentWorldVelocity { get { return currentWorldVelocity; } }

        /// <summary>
        /// [READONLY] Get the last recorded slope of the surface under the character
        /// </summary>
        public float GetLastGroundSlope { get { return isInitialised ? groundSlopeAngle : 0f; } }

        /// <summary>
        /// [READONLY] The world space point where the camera is looking at. Look Interactive must be enabled and
        /// IsUpdateLookingAtPoint must be true. This could be a StickyInteractive object position or a point
        /// lookMaxInteractiveDistance from the camera if no interactive-enabled objects are within view.
        /// </summary>
        public Vector3 GetLookingAtPoint { get { return isInitialised ? lookingAtPoint : Vector3.zero; } }

        /// <summary>
        /// [READONLY] If Hand IK is enabled, get the transform of the left hand bone
        /// </summary>
        public Transform GetLeftHandTransform { get { return isHandIK ? leftHandTrfm : null; } }

        /// <summary>
        /// [READONLY] If Hand IK is enabled, get the transform of the right hand bone
        /// </summary>
        public Transform GetRightHandTransform { get { return isHandIK ? rightHandTrfm : null; } }

        /// <summary>
        /// [READONLY] Get the current player camera (if any).
        /// </summary>
        public Camera GetCurrentPlayerCamera { get { return isInitialised && !isNPC ? lookCamera1 : null; } }

        /// <summary>
        /// [READONLY] Get the current method or type for updating the reference frame
        /// </summary>
        public int GetReferenceUpdateTypeInt { get { return isInitialised ? refUpdateTypeInt : (int)referenceUpdateType; } }

        /// <summary>
        /// [READONLY] The current reference frame transform
        /// </summary>
        public Transform GetCurrentReferenceFrame { get { return currentReferenceFrame; } }

        /// <summary>
        /// [READONLY] The current ID for the reference frame transform.
        /// </summary>
        public int GetCurrentReferenceFrameID { get { return currentReferenceFrameId; } }

        /// <summary>
        /// The overall health of the character. Must be in the range 0 to 100.
        /// See also JetPackHealth
        /// </summary>
        public float Health
        {
            get { return health * 100f; }
            set { SetHealth(value); }
        }

        /// <summary>
        /// Get or set if a weapon is held, will it always attempt to face the target?
        /// Otherwise, it will only do this when weapon IsAiming is true.
        /// </summary>
        public bool IsAimIKWhenNotAiming { get { return isAimIKWhenNotAiming; } set { SetAimIKWhenNotAiming(value); } }

        /// <summary>
        /// [READONLY] Is the jet packed feature engaged?
        /// NOTE: This will always return false when the Jet Pack feature is not available.
        /// </summary>
        public bool IsJetPackEnabled { get { return isJetPackEnabled && isJetPackAvailable; } }

        /// <summary>
        /// The health of the Jet Pack. Must be in the range 0 to 100.
        /// </summary>
        public float JetPackHealth
        {
            get { return jetPackHealth * 100f; }
            set
            {
                if (value < 0f) { jetPackHealth = 0f; }
                else if (value > 100f) { jetPackHealth = 1f; }
                else { jetPackHealth = value / 100f; }
            }
        }

        /// <summary>
        /// [READONLY] Get a reference to the item currently being held in the character's left hand
        /// </summary>
        public StickyInteractive LeftHandInteractive { get { return leftHandInteractive; } }

        /// <summary>
        /// [READONLY] Get the ID of the interactive-enabled object held in the character's left hand
        /// </summary>
        public int LeftHandInteractiveID { get { return leftHandInteractiveId; } }

        /// <summary>
        /// The 0.0-1.0 amount the character is crouching. 0 - not crouching, 1.0 is fully crouched.
        /// </summary>
        public float CrouchAmount { get; internal set; }

        /// <summary>
        /// [READONLY] The speed in metres per second the character is moving in any direction.
        /// </summary>
        public float MovingSpeed { get { return isMovementEnabled ? currentLocalVelocity.magnitude : 0f; } }

        /// <summary>
        /// [READONLY] Given the maximum walk or sprint speed, calculate what number, when multiplied by the current speed, would
        /// give a range of 0.0 to 1.0.
        /// </summary>
        public float MovingSpeedInvN { get { return isMovementEnabled ? S3DMath.InvNormalise(currentLocalVelocity.magnitude, currentSprintInput && !isClimbing ? sprintSpeed : walkSpeed) : 0f; } }

        /// <summary>
        /// [READONLY] Given the maximum walk, sprint, or strafe speed, find the normalised (0.0 t0 1.0) value from 0 to max speed.
        /// </summary>
        public float MovingSpeedN { get { return isMovementEnabled ? S3DMath.Normalise(currentLocalVelocity.magnitude, currentSprintInput && !isClimbing ? sprintSpeed : (currentLocalVelocity.x < -moveIdleThreshold || currentLocalVelocity.x > moveIdleThreshold) && (currentLocalVelocity.z > -moveIdleThreshold && currentLocalVelocity.z < moveIdleThreshold) ? strafeSpeed : walkSpeed) : 0f; } }

        /// <summary>
        /// [READONLY] The speed in metres per second the character is moving forward
        /// </summary>
        public float MovingForwardSpeed { get { return isMovementEnabled && currentLocalVelocity.z > moveIdleThreshold ? currentLocalVelocity.z : 0f; } }

        /// <summary>
        /// [READONLY] The speed in metres per second the character is moving backward
        /// </summary>
        public float MovingBackwardSpeed { get { return isMovementEnabled && currentLocalVelocity.z < -moveIdleThreshold ? currentLocalVelocity.z : 0f; } }

        /// <summary>
        /// [READONLY] The speed in metres per second the character is moving forward or backward
        /// </summary>
        public float MovingForwardBackSpeed { get { return isMovementEnabled && currentLocalVelocity.z < -moveIdleThreshold ? currentLocalVelocity.z : 0f; } }

        /// <summary>
        /// [READONLY] The number of Anim Actions configured on the Animate tab
        /// </summary>
        public int NumberOfAnimActions { get { return isInitialised ? numAnimateActions : s3dAnimActionList == null ? 0 : s3dAnimActionList.Count; } }

        /// <summary>
        /// [READONLY] The number of Damage Regions configured on the Engage tab
        /// </summary>
        public int NumberOfDamageRegions { get { return isInitialised ? numDamageRegions : damageRegionList == null ? 0 : damageRegionList.Count; } }

        /// <summary>
        /// [READONLY] The number of Equip Points configured on the Engage tab
        /// </summary>
        public int NumberOfEquipPoints { get { return isInitialised ? numEquipPoints : equipPointList == null ? 0 : equipPointList.Count; } }

        /// <summary>
        /// [READONLY] The number of items stashed on this character
        /// </summary>
        public int NumberOfStashItems { get { return isInitialised ? numStashedItems : stashList == null ? 0 : stashList.Count; } }

        /// <summary>
        /// [READONLY] Get a reference to the item currently being held in the character's right hand
        /// </summary>
        public StickyInteractive RightHandInteractive { get { return rightHandInteractive; } }

        /// <summary>
        /// [READONLY] Get the ID of the interactive-enabled object held in the character's right hand
        /// </summary>
        public int RightHandInteractiveID { get { return rightHandInteractiveId; } }

        /// <summary>
        /// [READONLY] The speed in metres per second the character is moving left or right.
        /// </summary>
        public float StrafingSpeed { get { return isMovementEnabled ? currentLocalVelocity.x : 0f; } }

        /// <summary>
        /// [READONLY] Given the maximum strafe or sprint speed, find the normalised (0.0 t0 1.0) value from 0 to max speed that the character is moving left or right.
        /// </summary>
        public float StrafingSpeedN { get { return isMovementEnabled ? S3DMath.Normalise(currentLocalVelocity.x, currentSprintInput && !isClimbing ? sprintSpeed : strafeSpeed) : 0f; } }

        /// <summary>
        /// [READONLY] The speed in metres per second the character is walking forward or backward
        /// </summary>
        public float WalkingSpeed { get { return isInitialised && isMovementEnabled && isGrounded && !isStepping && !isClimbing && !currentSprintInput ? currentLocalVelocity.z : 0f; } }

        /// <summary>
        /// [READONLY] The speed in metres per second the character is walking forward
        /// </summary>
        public float WalkingForwardSpeed { get { float _walkingSpeed = WalkingSpeed; return _walkingSpeed > moveIdleThreshold ? _walkingSpeed : 0f; } }

        /// <summary>
        /// [READONLY] The speed in metres per second the character is walking backward
        /// </summary>
        public float WalkingBackwardSpeed { get { float _walkingSpeed = WalkingSpeed; return _walkingSpeed < moveIdleThreshold ? _walkingSpeed : 0f; } }

        /// <summary>
        /// [READONLY] The speed in metres per second the character is sprinting forward or backward
        /// </summary>
        public float SprintingSpeed { get { return isMovementEnabled && currentSprintInput && !isClimbing ? currentLocalVelocity.z : 0f; } }

        /// <summary>
        /// [READONLY] Get the current size on the character. This assumes a capsule-like shape.
        /// </summary>
        public Vector3 ScaledSize { get { return new Vector3(currentScaledRadius * 2f, currentScaledHeight, currentScaledRadius * 2f); } }

        /// <summary>
        /// Get or set the child transform under which all items are stashed
        /// </summary>
        public Transform StashParent { get { return stashParent; } set { SetStashParent(value); } }

        /// <summary>
        /// [READONLY] Get the currently angular turning speed (how quickly the character is currently turning).
        /// Turning right is +ve, left is -ve.
        /// </summary>
        public float TurningSpeed { get { return isMovementEnabled ? currentLocalAngularVelocity.y : 0f; } }

        #endregion

        #region Public Properties - Aim IK

        /// <summary>
        /// Get or set the Humanoid bones used to help aim the character toward a target while holding a weapon
        /// </summary>
        public S3DHumanBone[] AimBones { get { return aimBones; } set { SetAimBones(value); } }

        /// <summary>
        /// Get or set the weapon local space offset from the first-person camera when aiming
        /// </summary>
        public Vector3 AimIKFPWeaponOffset { get { return aimIKFPWeaponOffset; } set { aimIKFPWeaponOffset = value; } }

        /// <summary>
        /// Get or set the first-person camera near clipping plane when aiming a weapon.
        /// NOTE: This does not change the camera, it only stores the value to be used when aiming.
        /// This can be overridden by a Weapon Anim Set.
        /// </summary>
        public float AimIKFPNearClippingPlane { get { return aimIKFPNearClippingPlane; } set { if (value > 0.01f) { aimIKFPNearClippingPlane = value; } } }

        /// <summary>
        /// Get or set the time, in seconds, to delay the character turning to face the target when aiming starts.
        /// This allows time to transition from a held animation, to an aiming animation. 
        /// </summary>
        public float AimIKTurnDelay { get { return aimIKTurnDelay; } set { aimIKTurnDelay = value; } }

        /// <summary>
        /// When grabbing a weapon, this is the time, in seconds, it takes the animation to play that transitions from not holding,
        /// to holding the weapon. See also S3DWeaponAnimSet.heldTransitionDuration.
        /// </summary>
        public float HeldTransitionDuration { get { return heldTransitionDuration; } set { heldTransitionDuration = value; } }

        /// <summary>
        /// Is the (humanoid) character currently attempting to aim toward the target? This is typically used when
        /// holding a weapon. For more control see EnableAimAtTarget(..).
        /// </summary>
        public bool IsAimAtTarget { get { return isAimAtTargetEnabled; } set { EnableAimAtTarget(value, true); } }

        /// <summary>
        /// When a weapon is aimed and held by a character in 3rd person, should it use the first-person camera?
        /// This is typically set at runtime using a S3DWeaponAnimSet scriptable object.
        /// </summary>
        public bool IsAimTPUsingFPCamera { get { return isAimTPUsingFPCamera; } internal set { isAimTPUsingFPCamera = value; } }

        /// <summary>
        /// Is third-person weapon aiming currently using the first-person camera?
        /// </summary>
        public bool IsAimTPUsingFPCameraEnabled { get { return isAimTPUsingFPCameraEnabled; } }

        #endregion

        #region Public Properies - Hand IK

        /// <summary>
        /// [READONLY] The current maximium Hand IK weight available for use in the animator.
        /// When smooth enabling or disabling, the maximum weight possible can be between 0.0 and 1.0.
        /// Hand IK weight is then limited to this value in the OnAnimatorIK() pass.
        /// </summary>
        public float CurrentMaxHandIKWeight { get { return currentMaxHandIKWeight; } }

        /// <summary>
        /// [READONLY] Is Hand IK enabled and ready for use?
        /// </summary>
        public bool IsHandIKEnabled { get { return isHandIK && (isAnimateEnabled || editorMode); } }

        /// <summary>
        /// [READONLY] Is Hand IK in the process of being smoothly disabled over several frames?
        /// </summary>
        public bool IsHandIKDisabling { get { return isAnimateEnabled && isHandIK && isHandIKSmoothDisable; } }

        #endregion

        #region Public Properties - Look

        /// <summary>
        /// If a non-NPC character has Free Look enabled before a weapon is held (but not aimed), does Free Look remain enabled?
        /// Useful when a weapon is held in a relaxed pose not pointing forward.
        /// </summary>
        public bool IsFreeLookWhenWeaponHeld { get { return isFreeLookWhenWeaponHeld; } internal set { isFreeLookWhenWeaponHeld = value; } }

        /// <summary>
        /// Get or attempt to set (un)locking the third-person camera to the current world space position, relative to the reference frame.
        /// </summary>
        public bool IsLockCamToWorldPos { get { return isLockCamToWorldPos; } set { if (isInitialised) { if (value) { LockThirdPersonCameraPosition(); } else { UnLockThirdPersonCameraPosition(); } } } }

        /// <summary>
        /// Get or attempt to set (un)locking the third-person camera to the current world space rotation, relative to the reference frame.
        /// </summary>
        public bool IsLockCamToWorldRot { get { return isLockCamToWorldRot; } set { if (isInitialised) { if (value) { LockThirdPersonCameraRotation(); } else { UnLockThirdPersonCameraRotation(); } } } }

        /// <summary>
        /// [READONLY] Is the player able to look around with the camera?
        /// When disabled, the camera will be disabled.
        /// </summary>
        public bool IsLookEnabled { get { return isLookEnabled; } }

        /// <summary>
        /// [READONLY] Is the character able to look around without the character rotating?
        /// </summary>
        public bool IsLookFreeLookEnabled { get { return isFreeLook; } }

        /// <summary>
        /// [READONLY] Is the camera being moved or rotated in the FixedUpdate() loop?
        /// </summary>
        public bool IsLookFixedUpdate { get { return isLookFixedUpdate; } }

        /// <summary>
        /// [READONLY] If the relative head bone position changes, the first-person camera will move relative to it.
        /// </summary>
        public bool IsLookCameraFollowHead { get { return isLookCameraFollowHead; } }

        /// <summary>
        /// [READONLY] If the relative head bone position changes, the third-person camera will move relative to it.
        /// </summary>
        public bool IsLookCameraFollowHeadTP { get { return isLookCameraFollowHeadTP; } }

        /// <summary>
        /// {READONLY] Can the character see or detect objects with an StickyInteractive component?
        /// </summary>
        public bool IsLookInteractiveEnabled { get { return isLookInteractiveEnabled; } }

        /// <summary>
        /// [READONLY] Is the character currently looking at an object with a StickyInteractive component?
        /// </summary>
        public bool IsLookingAtInterative { get { return isLookInteractiveEnabled && lookingAtInteractiveId != StickyInteractive.NoID; } }

        /// <summary>
        /// Get or set if the StickySockets will be highlighted when looked at and Look Sockets is enabled.
        /// </summary>
        public bool IsLookSocketAutoShow { get { return isLookSocketAutoShow; } set { SetLookSocketAutoShow(value); } }

        /// <summary>
        /// {READONLY] Can the character see or detect objects with a StickySocket component?
        /// </summary>
        public bool IsLookSocketsEnabled { get { return isLookSocketsEnabled; } }

        /// <summary>
        /// [READONLY] Is the character currently looking at an object with an StickySocket component?
        /// </summary>
        public bool IsLookingAtSocket { get { return isLookSocketsEnabled && lookingAtSocketId != StickySocket.NoID; } }

        /// <summary>
        /// {READONLY] Is the camera permitted to be moved or rotated?
        /// </summary>
        public bool IsLookMovementEnabled { get { return isUpdateLookMovement; } }

        /// <summary>
        /// [READONLY] Is the character in third-person mode?
        /// </summary>
        public bool IsLookThirdPersonEnabled { get { return isThirdPerson; } }

        /// <summary>
        /// [READONLY] Is (look) VR mode available for selection or use?
        /// </summary>
        public bool IsLookVRAvailable
#if SCSM_XR && SSC_UIS
        { get { return !isThirdPerson && !isNPC; } }
#else
        { get { return false; } }
#endif

        /// <summary>
        /// [READONLY] Is Look VR mode enabled?
        /// </summary>
        public bool IsLookVREnabled { get { return isLookVREnabled; } }

        /// <summary>
        /// [READONLY] When Look VR is enabled, the character Height will be modified to match
        /// the approximate height of the human player based on the starting head-mounted
        /// device position above the floor.
        /// </summary>
        public bool IsLookMatchHumanHeightVR { get { return isMatchHumanHeightVR; } }

        /// <summary>
        /// [READONLY]
        /// Is the VR Head Mounted Device (HMD) driving character motion?
        /// </summary>
        public bool IsLookRoomScaleVR { get { return isRoomScaleVR; } }

        /// <summary>
        /// [READONLY] Is Snap Turn VR enabled? Look VR must also be available and enabled for this to be true.
        /// </summary>
        public bool IsLookSnapTurnVREnabled { get { return isLookVREnabled && isSnapTurnVR; } }

        /// <summary>
        /// [READONLY] Is look left input being received by the character?
        /// </summary>
        public bool IsLookLeftInput { get { return isInitialised && isUpdateLookMovement && currentHorizontalLookInput < -0.0001f; } }

        /// <summary>
        /// [READONLY] Is look right input being received by the character?
        /// </summary>
        public bool IsLookRightInput { get { return isInitialised && isUpdateLookMovement && currentHorizontalLookInput > 0.0001f; } }

        /// <summary>
        /// [READONLY] Is look down input being received by the character?
        /// </summary>
        public bool IsLookDownInput { get { return isInitialised && isUpdateLookMovement && currentVerticalLookInput < -0.0001f; } }

        /// <summary>
        /// [READONLY] Is look up input being received by the character?
        /// </summary>
        public bool IsLookUpInput { get { return isInitialised && isUpdateLookMovement && currentVerticalLookInput > 0.0001f; } }

        /// <summary>
        /// [READONLY] Is the character looking left, right, up or down while not moving?
        /// </summary>
        public bool IsLookWhileIdle { get { return isInitialised && isUpdateLookMovement && (currentHorizontalLookInput < -0.0001f || currentHorizontalLookInput > 0.0001f || currentVerticalLookInput < -0.0001f || currentVerticalLookInput > 0.0001f) && (!isMovementEnabled || currentLocalVelocity.sqrMagnitude < moveIdleThreshold); } }

        /// <summary>
        /// [READONLY] Is the character looking left or right while not moving?
        /// </summary>
        public bool IsLookLeftOrRightWhileIdle { get { return isInitialised && isUpdateLookMovement && (currentHorizontalLookInput < -0.0001f || currentHorizontalLookInput > 0.0001f) && (!isMovementEnabled || currentLocalVelocity.sqrMagnitude < moveIdleThreshold); } }

        /// <summary>
        /// [READONLY] Is the character looking up or down while not moving?
        /// </summary>
        public bool IsLookUpOrDownWhileIdle { get { return isInitialised && isUpdateLookMovement && (currentVerticalLookInput < -0.0001f || currentVerticalLookInput > 0.0001f) && (!isMovementEnabled || currentLocalVelocity.sqrMagnitude < moveIdleThreshold); } }

        /// <summary>
        /// [READONLY] Get the current amount of zoom being applied in third person mode
        /// </summary>
        public float ZoomAmount { get { return isThirdPerson ? zoomFactor : 0f; } }

        #endregion

        #region Public Properties - Ragdoll

        /// <summary>
        /// Get or set if the character is acting like a ragdoll
        /// </summary>
        public bool IsRagdoll { get { return isRagdollEnabled; } set { EnableOrDisableRagdoll(value); } }

        /// <summary>
        /// Get or set the list of bones used for the Ragdoll feature
        /// </summary>
        public List<S3DHumanBonePersist> RagdollBoneList { get { return ragdollBoneList; } set { SetRagdollBones(value); } }

        #endregion

        #region Public Properties - Respawning

        /// <summary>
        /// Is the character currently being respawned?
        /// The character will be disabled during the respawn time.
        /// </summary>
        public bool IsRespawning { get { return isRespawning; } set { isRespawning = value; } }

        /// <summary>
        /// [READONLY] Has respawning been paused? If so, this character cannot respawn
        /// until ResumeRespawning() has been called. See also PauseRespawning().
        /// </summary>
        public bool IsRespawningPaused { get { return isRespawingPaused; } }

        /// <summary>
        /// [READONLY] The current number of lives available
        /// </summary>
        public int Lives { get { return currentLives; } }

        public int MaxLives { get { return maxLives; } set { SetMaxLives(value); } }

        public RespawningMode RespawnMode { get { return respawnMode; } set { SetRespawnMode(value); } }

        public int StartLives { get { return startLives; } set { SetStartLives(value); } }

        #endregion

        #region Public Delegates

        public delegate void CallbackOnChangeCamera(int stickyID, Camera oldCamera, Camera newCamera, bool isThirdPerson);

        public delegate void CallbackOnChangeInteractiveTarget(StickyControlModule stickyControlModule, StickyInteractive oldTarget, StickyInteractive newTarget);

        public delegate void CallbackOnChangeLookAtInteractive(StickyControlModule stickyControlModule, StickyInteractive oldLookAt, StickyInteractive newLookAt);

        public delegate void CallbackOnDestroy(StickyControlModule stickyControlModule);

        public delegate void CallbackOnHit(S3DCharacterHitParameters s3dCharacterHitParameters);

        public delegate void CallbackAfterRespawn(StickyControlModule stickyControlModule);

        public delegate void CallbackOnStuck(StickyControlModule stickyControlModule);

        /// <summary>
        /// The name of your custom method that is called immediately after the look camera is changed.
        /// </summary>
        [System.NonSerialized] public CallbackOnChangeCamera callbackOnCameraChange = null;

        /// <summary>
        /// The name of your custom method that is called immediately after an interactive target is changed
        /// </summary>
        [System.NonSerialized] public CallbackOnChangeInteractiveTarget callbackOnChangeInteractiveTarget = null;

        /// <summary>
        /// The name of your custom method that is called immediately after the character changes the interactive
        /// object they are looking at.
        /// </summary>
        [System.NonSerialized] public CallbackOnChangeLookAtInteractive callbackOnChangeLookAtInteractive = null;

        /// <summary>
        /// The name of the custom method that is called immediately before the character
        /// is destroyed (or when the health reaches 0).
        /// Your method must take 1 parameter: StickyControlModule.
        /// This parameter will never be null. This should be a lightweight method to
        /// avoid performance issues and not hold references past the current frame.
        /// See also onDestroyed event.
        /// </summary>
        [System.NonSerialized] public CallbackOnDestroy callbackOnDestroy = null;

        /// <summary>
        /// The name of the custom method that is called immediately
        /// after the character is hit by a projectile or beam. Your method must take 1
        /// parameter of type CallbackOnS3DHitParameters. This should be 
        /// a lightweight method to avoid performance issues. It could be used to 
        /// take evasive action while being pursued by an enemy NPC. It could
        /// also be used to detect friendly fire.
        /// </summary>
        [System.NonSerialized] public CallbackOnHit callbackOnHit = null;

        /// <summary>
        /// The name of the custom method that is called immediately after the character
        /// is respawned. Your method must take 1 parameter: StickyControlModule.
        /// This parameter will never be null. This should be a lightweight method to
        /// avoid performance issues.
        /// </summary>
        [System.NonSerialized] public CallbackAfterRespawn callbackAfterRespawn = null;

        /// <summary>
        /// The name of your custom method that is called immediately after
        /// a character is detected as stuck. To avoid performance issues, action
        /// should be taken otherwise your method may be called each subsequent
        /// frame.
        /// See also stickControlModule.stuckTime and stuckSpeedThreshold.
        /// </summary>
        [System.NonSerialized] public CallbackOnStuck callbackOnStuck = null;

        #endregion

        #region Internal-Only Properties

#if UNITY_EDITOR
        /// <summary>
        /// [INTERNAL ONLY]
        /// </summary>
        public bool IsEditorMode { get { return editorMode; } }
        /// <summary>
        /// [INTERNAL ONLY]
        /// </summary>
        public List<S3DDamageRegion> DamageRegionList { get { return damageRegionList; } }
        /// <summary>
        /// [INTERNAL ONLY]
        /// </summary>
        public List<S3DEquipPoint> EquipPointList { get { return equipPointList; } }
        /// <summary>
        /// [INTERNAL ONLY]
        /// </summary>
        public bool IsEquipListExpanded { get { return isEngageEquipPointListExpanded; } set { isEngageEquipPointListExpanded = value; } }
        /// <summary>
        /// [INTERNAL ONLY]
        /// </summary>
        public bool ShowLookCamOffsetGizmosInSceneView { get { return showLookCamOffsetGizmosInSceneView; } }
        /// <summary>
        /// [INTERNAL ONLY]
        /// </summary>
        public bool ShowLookFocusOffsetGizmosInSceneView { get { return showLookFocusOffsetGizmosInSceneView; } }
        /// <summary>
        /// [INTERNAL ONLY]
        /// </summary>
        public bool ShowLHGizmosInSceneView { get { return showLHGizmosInSceneView; } }
        /// <summary>
        /// [INTERNAL ONLY]
        /// </summary>
        public bool ShowRHGizmosInSceneView { get { return showRHGizmosInSceneView; } }

        /// <summary>
        /// [INTERNAL ONLY]
        /// </summary>
        public Color HandZoneGizmoColour { get { return handZoneGizmoColour; } }
#endif

        #endregion

        #region Private and Internal Variables
        private bool isInitialised = false;

        #region Private Input Variables
        /// <summary>
        /// Keeps track of if all input has been processed in FixedUpdate() since
        /// it was last received - typically from Update(). SendInput(..) may receive
        /// multiple updates before the next FixedUpdate() runs.
        /// </summary>
        private bool isInputProcessed = true;
        private bool isSmoothCameraUpdate = true;
        // Move input
        private Vector3 currentLocalSpaceMovementInput = Vector3.zero;
        private bool currentJumpInput = false;
        private bool currentSprintInput = false;
        private bool currentCrouchInput = false;
        private bool currentJetPackInput = false;
        private bool currentSwitchLookInput = false;
        // Look input
        private float currentHorizontalLookInput = 0f;
        private float previousHorizontalLookInput = 0f;
        private float currentVerticalLookInput = 0f;
        private float previousVerticalLookInput = 0f;
        private float currentZoomLookInput = 0f;
        private float currentOrbitLookInput = 0f;
        private float previousOrbitLookInput = 0f;
        // Weapon input

        /// <summary>
        /// [INTERNAL ONLY] The input send to the weapon in the right hand (if any)
        /// </summary>
        [System.NonSerialized] private WeaponInput leftHandWeaponInput = null;
        /// <summary>
        /// [INTERNAL ONLY] The input sent to the weapon in the right hand (if any)
        /// </summary>
        [System.NonSerialized] private WeaponInput rightHandWeaponInput = null;

        /// <summary>
        /// Current local space rotation of the XR HMD
        /// </summary>
        private Quaternion currentXRLookInput = Quaternion.identity;
        #endregion

        #region Private Variables - General
        /// <summary>
        /// Is this a non-player character? Set when you want to drive input via code.
        /// </summary>
        [SerializeField] private bool isNPC = false;

        /// <summary>
        /// The overall normalised health of the character.
        /// See also jetpackHealth
        /// </summary>
        [SerializeField, Range(0f, 1f)] private float health = 1f;

        [System.NonSerialized] private Rigidbody rBody, rBodyCamera;

        /// <summary>
        /// This is used to show or hide the character. Currently used with respawning
        /// </summary>
        [System.NonSerialized] private List<Renderer> activeRenderersList;

        /// <summary>
        /// This prevents the activeRenderersList being updated while the character is disabled
        /// </summary>
        private bool isCharacterVisibilityDisabled = false;

        // Use when climbing steps
        private bool isStepping = false;
        // When descending steps
        private bool isSteppingDown = false;
        // Total height of the step
        private float stepUpHeight = 0f;

        // Point at which contact is made with the wall or step (also used for climbing)
        private Vector3 steppingContactPoint = Vector3.zero;
        // Height of steppingContactPoint above the bottom of the character (also used for climbing)
        private float steppingContactHeight = 0f;
        // The normal of the wall or step we made contact with (also used for climbing)
        private Vector3 steppingContactNormal = Vector3.zero;

        // Used to update character in scene view from the editor when not in play mode
        private bool editorMode = false;

        /// <summary>
        /// This is a state when the NPC or Player cannot make the character move,
        /// while the character's position and rotation can still be updated to keep
        /// in sync with the reference frame.
        /// </summary>
        private bool isPositionLocked = false;

        /// <summary>
        /// The starting rotation on y-axis of the character. Currently used with lookVR
        /// </summary>
        private float initialRotationY = 0f;

        /// <summary>
        /// The starting position of the VR head mounted device above the floor
        /// </summary>
        private Vector3 initialHMDFloorOffset = Vector3.zero;

        /// <summary>
        /// This is the floor offset difference between the starting position of the
        /// VR head-mounted device and the first person camera position.
        /// </summary>
        internal Vector3 initialHMDCameraDelta = Vector3.zero;

        /// <summary>
        /// Random number generator for any purpose for this character.
        /// </summary>
        private S3DRandom miscS3DRandom = null;

        [System.NonSerialized] internal int sceneHandle = 0;

        #endregion

        #region Private Variables - Stuck
        private bool isStuck = false;
        private float stuckTimer = 0f;
        #endregion

        #region Private Variables - Raycast
        private Ray raycastRay = new Ray(Vector3.zero, Vector3.forward);
        private RaycastHit raycastHitInfo;
        private RaycastHit[] raycastHitInfoArray;
        #endregion

        #region Private Variables - General Current Values

        /// <summary>
        /// This is the height taking into consideration things like crouching
        /// </summary>
        private float currentScaledHeight = 1f;

        /// <summary>
        /// This is the shoulder height taking into consideration things like crouching
        /// </summary>
        private float currentScaledShoulderHeight = 1f;

        /// <summary>
        /// The scaled height in the last frame
        /// </summary>
        private float prevScaledHeight = 1f;

        /// <summary>
        /// This is the radius taking into consideration things like crouching
        /// </summary>
        private float currentScaledRadius = 1f;

        /// <summary>
        /// The offset on the local Y axis from the position of the character.
        /// When the pivot is at the centre of the model, this will be 0.
        /// When pivot is at feet, this will be currentScaledHeight * 0.5
        /// </summary>
        private float currentScaledBottomY = 0.5f;

        /// <summary>
        /// Was the character crouching in the last frame?
        /// </summary>
        private bool prevCrouching = false;
        /// <summary>
        /// This is set when attempting to stand but is blocked by an obstacle
        /// </summary>
        private bool isForcedCrouch = false;
        /// <summary>
        /// Is the character height currently adjusted to a temporary value?
        /// Typically used when sitting with knees under a table or bench etc.
        /// </summary>
        private bool isTemporaryHeight = false;
        private bool isMoveFixedUpdate = false;
        private bool isLookFixedUpdate = false;
        private bool isGrounded = false;
        /// <summary>
        /// Was the character grounded in the last frame?
        /// </summary>
        private bool previousIsGrounded = false;
        private bool isLanding = false;
        /// <summary>
        /// The delayed jump will happen this frame
        /// </summary>
        private bool isDelayedJumpThisFrame = false;
        /// <summary>
        /// A delayed jump has been triggered. This helps to avoid multiple
        /// jumps while still on the ground and a jump animation has started to play.
        /// </summary>
        private bool isJumpingWithDelay = false;
        /// <summary>
        /// Has a jump started during this frame? This is when the user first presses the button
        /// down to begin a jump. If the jump includes a jumpDelay (typically for an animation),
        /// this prevents the jump animation running multiple times.
        /// </summary>
        private bool isJumpStartedThisFrame = false;
        /// <summary>
        /// Is a jump in progress? This is different from falling as it was triggered by a jump action.
        /// </summary>
        private bool isInJump = false;
        /// <summary>
        /// Is the character currently sitting down?
        /// See SampleSitActionPopup.cs
        /// </summary>
        private bool isSitting = false;

        private Transform currentReferenceFrame = null;
        private Transform previousReferenceFrame = null;
        private int currentReferenceFrameId = -1;
        internal int refUpdateTypeInt = 0;
        // The current position and rotation of the reference frame in world space
        private Vector3 currentReferenceFramePosition = Vector3.zero;
        private Quaternion currentReferenceFrameRotation = Quaternion.identity;
        private Vector3 currentReferenceFrameUp = Vector3.up;
        // The reference frame multiplier is used to retain a similar forwards direction
        // when the character crosses from one reference frame to another.
        private Quaternion currentReferenceFrameRotationMultiplier = Quaternion.identity;
        // The current position and rotation relative to the reference frame
        private Vector3 currentRelativePosition = Vector3.zero;
        private Quaternion currentRelativeRotation = Quaternion.identity;
        // The last relative position relative to the reference frame before non-velocity adjustments are done
        private Vector3 unadjustedRelativePosition = Vector3.zero;
        // The current velocity and angular velocity relative to the reference frame
        private Vector3 currentRelativeVelocity = Vector3.zero;
        private Vector3 currentRelativeAngularVelocity = Vector3.zero;
        // The current velocity in character local space
        private Vector3 currentLocalVelocity = Vector3.zero;
        // The current world position and rotation
        private Vector3 currentWorldPosition = Vector3.zero;
        private Quaternion currentWorldRotation = Quaternion.identity;
        // The current world velocity and angular velocity
        private Vector3 currentWorldVelocity = Vector3.zero;
        private Quaternion currentWorldAngularVelocity = Quaternion.identity;
        private Vector3 currentLocalAngularVelocity = Vector3.zero;
        // The current character directions
        private Vector3 currentCharacterUp = Vector3.up;
        private Vector3 currentCharacterFwd = Vector3.forward;
        private Vector3 currentCharacterRight = Vector3.right;
        private Vector3 currentRelativeTargetUp = Vector3.up;
        /// <summary>
        /// The last recorded slope under the characters feet. Currently this only
        /// gets set when the character is moving up a slope.
        /// </summary>
        private float groundSlopeAngle = 0f;
        #endregion

        #region Private Variables - Move General
        private bool isMovementEnabled = true;

        /// <summary>
        /// Used when re-enabling or unpausing a character.
        /// </summary>
        private bool savedMovementState = false;

        /// <summary>
        /// Values at or below this value are considered idle.
        /// When root motion is enabled, this value can be overridden by rootMotionIdleThreshold
        /// </summary>
        internal float moveIdleThreshold = 0.0001f;

        // Editor only
        [SerializeField] private bool isMoveGeneralExpanded = true;

        // FootStep variables
        /// <summary>
        /// Is set to true when footsteps are configured ready for use
        /// </summary>
        private bool isFootStepsAvailable = false;
        private float footStepTimer = 0f;
        private int numFootSteps = 0;
        private S3DRandom audioclipRandom = null;
        /// <summary>
        /// Temp list for getting single StickySurface component attached
        /// to a collider in the scene without incurring GC.
        /// </summary>
        private List<StickySurface> stickySurfaceList = null;

        /// <summary>
        /// Used with Free Look, the amount the character has turned toward
        /// the camera rotation since the previous camera movement.
        /// </summary>
        private float localTurnedY = 0f;

        private Vector3 applyForceDirection;
        private float applyForceAmount = 0f;
        private float applyForceDuration = 0f;
        private float applyForceTimer = 0f;
        private Vector3 applyForcePointLS;

        #endregion

        #region Private Variables - Move Climbing

        /// <summary>
        /// Is the character able to climb walls?
        /// </summary>
        [SerializeField] private bool isClimbingEnabled = false;

        /// <summary>
        /// Is the character currently climbing a wall?
        /// </summary>
        private bool isClimbing = false;
        private bool checkIfClimbable = false;
        /// <summary>
        /// Is the character climbing at or above shoulder height to
        /// the top of the climbable object?
        /// </summary>
        private bool isClimbingAtTop = false;

        /// <summary>
        /// The normal of the wall the character is currently climbing.
        /// </summary>
        private Vector3 currentClimbingWallNormal = Vector3.forward;
        /// <summary>
        /// The rightwards direction of the wall the character is currently climbing.
        /// </summary>
        private Vector3 currentClimbingWallRightDir = Vector3.right;
        /// <summary>
        /// The upwards direction of the wall the character is currently climbing.
        /// </summary>
        private Vector3 currentClimbingWallUpDir = Vector3.up;

        // Editor only
        [SerializeField] private bool isClimbingExpanded = true;

        #endregion

        #region Private Variables - Move Identification
        // Editor only
        [SerializeField] private bool isIdenficationExpanded = true;

        #endregion

        #region Private Variables - Collide
        [System.NonSerialized] private CapsuleCollider capsuleCollider;
        private int capsuleColliderId = 0;
        private int leftFootColliderId = 0;
        private int rightFootColliderId = 0;

        [System.NonSerialized] private Collider[] overlapCapsuleResults = new Collider[10];
        [System.NonSerialized] private Collider otherCollider;
        [System.NonSerialized] private Collider groundCollider = null;
        private Vector3 groundHitPoint = Vector3.zero;

        /// <summary>
        /// Stores an unordered unique list of (trigger) colliders that we are currently inside.
        /// Helps to send OnTriggerEnter/Exit events
        /// </summary>
        [System.NonSerialized] private HashSet<Collider> inTriggerColliders;

        /// <summary>
        /// Unordered unique set of trigger collider hashes overlapping in this frame.
        /// Helps to determine OnTriggerExit events
        /// </summary>
        [System.NonSerialized] private HashSet<int> frameTriggerColliders = new HashSet<int>();

        /// <summary>
        /// Stores an unordered unique list of colliders that we are currently in contact with.
        /// Helps to send OnCollisionEnter/Exit events
        /// </summary>
        [System.NonSerialized] private HashSet<Collider> inCollisionColliders;

        /// <summary>
        /// Unordered unique set of collider hashes overlapping in this frame.
        /// Helps to determine OnCollisionExit events
        /// </summary>
        [System.NonSerialized] private HashSet<int> frameCollisionColliders = new HashSet<int>();

        /// <summary>
        /// Unordered unique set of colliders on objects that have been attached to this character.
        /// Typically will contain objects grabbed by the character.
        /// </summary>
        [System.NonSerialized] private HashSet<int> attachedCollisionColliders = new HashSet<int>();

        /// <summary>
        /// Unordered unique set of colliders on this character that should not register as hits
        /// for weapons that fire at this character.
        /// </summary>
        [System.NonSerialized] private HashSet<int> weaponNonHitColliders = new HashSet<int>();

        /// <summary>
        /// A temporary list of colliders that are no longer affected by this
        /// character. Used with OnTriggerEntry/Stay/Exit and OnCollisionEntry/Stay/Exit..
        /// Also used in EnableOrDisableColliders(..)
        /// </summary>
        [System.NonSerialized] private List<Collider> removeColliderList = new List<Collider>(10);
        #endregion

        #region Private Variables - Look

        /// <summary>
        /// Is the first or third person free look mode enabled?
        /// </summary>
        [SerializeField] private bool isFreeLook = false;

        /// <summary>
        /// If a non-NPC character has Free Look enabled before a weapon is held (but not aimed), does Free Look remain enabled?
        /// Useful when a weapon is held in a relaxed pose not pointing forward. Can be overridden by a Weapon Anim Set.
        /// </summary>
        private bool isFreeLookWhenWeaponHeld = false;

        /// <summary>
        /// If the relative head bone position changes, the first person camera will move relative to it.
        /// </summary>
        [SerializeField] private bool isLookCameraFollowHead = false;

        /// <summary>
        /// If the relative head bone position changes, the third person camera will move relative to it.
        /// </summary>
        private bool isLookCameraFollowHeadTP = false;

        // Editor only
        [SerializeField] private bool isLookGeneralExpanded = true;
        [SerializeField] private bool showLookCamOffsetGizmosInSceneView = false;
        [SerializeField] private bool showLookFocusOffsetGizmosInSceneView = false;

        /// <summary>
        /// [INTERNAL ONLY]
        /// The current parent transform used for look direction. Anything that should have its position or orientation
        /// modified by look direction should probably be parented to this transform.
        /// </summary>
        internal Transform lookTransform;

        /// <summary>
        /// [INTERNAL ONLY] The current camera for the controller
        /// </summary>
        internal Camera lookCamera1 = null;

        /// <summary>
        /// Used with first person camera for pitch and left/right
        /// </summary>
        private Vector3 currentLookRotEulerAngles = Vector3.zero;
        private bool isUpdateLookMovement = false;
        private bool isLookEnabled = true;
        // The relative normalised offset from feet to the first person camera.
        private float firstPersonCameraFeetOffsetY = 1f;
        // Look 3rd person variables. Unless indicated the 3rd person camera variables are in local space.
        private bool isThirdPersonValid = false;
        private Vector3 optimalCameraPosition = Vector3.zero;
        private Vector3 previousOptimalCameraPosition = Vector3.zero;
        private Quaternion optimalCameraRotation = Quaternion.identity;
        private Vector3 currentFocusPosition = Vector3.zero;
        private Vector3 currentCameraPosition = Vector3.zero;
        private Vector3 currentCameraPosWS = Vector3.zero;
        private Quaternion currentCameraRotWS = Quaternion.identity;
        private Vector3 currentCameraRefFrameOffset = Vector3.zero;
        private Quaternion currentCameraRefFrameRot = Quaternion.identity;
        /// <summary>
        /// Used for Free Look. This is in the character's local space.
        /// </summary>
        private Quaternion currentLookRotation = Quaternion.identity;
        /// <summary>
        /// Used when disabling and re-enabling character
        /// </summary>
        private bool lookAutoHideCursorToRestore = false;
        private float zoomFactor = 0f;
        /// <summary>
        /// The time, in seconds, to zoom fully in or out
        /// </summary>
        [SerializeField, Range(0.1f, 20f)] private float zoomDuration = 3f;
        private float unzoomTimer = 0f;
        private float lookCameraOffsetDistance = 0f;

        // Range -359.9 to 359.9. 0.0 = centre (default)
        private float orbitHorizontalAngle = 0f;

        private float orbitVerticalAngle = 0f;
        /// <summary>
        /// The time, in seconds, to fully orbit the character
        /// </summary>
        [SerializeField, Range(0.1f, 30f)] private float orbitDuration = 5f;
        private float unorbitTimer = 0f;

        /// <summary>
        /// Stop third person camera moving relative to the current reference frame
        /// </summary>
        private bool isLockCamToWorldPos = false;

        /// <summary>
        /// Stop third person camera rotating relative to the current reference frame
        /// </summary>
        private bool isLockCamToWorldRot = false;

        // Camera shake variables - See MoveThirdPersonCamera() and ShakeCamera(..).
        private bool isShaking = false;
        private float shakeStrength = 1f;
        private float shakeTimer = 0f;

        /// <summary>
        /// Used when re-enabling or unpausing a character.
        /// </summary>
        private bool savedLookMovementState = false;

        /// <summary>
        /// Used with isLookCameraFollowHead to record the starting position
        /// before it is enabled. This allows it to be restored when
        /// isLookCameraFollowHead is disabled.
        /// </summary>
        private Vector3 initialLookHeadOffset = Vector3.zero;

        /// <summary>
        /// Used with isLookCameraFollowHeadTP to record the starting local space offset
        /// from the feet before it is enabled. This allows it to be restored when
        /// isLookCameraFollowHeadTP is disabled.
        /// </summary>
        private Vector3 initialLookHeadOffsetTP = Vector3.zero;

        /// <summary>
        /// Used with isLookCameraFollowHead to record the starting local
        /// oosition of the first person camera.
        /// </summary>
        private Vector3 initialLookCamOffset = Vector3.zero;

        #endregion

        #region Private Variables - Look Clip Objects
        private Vector3 viewHalfExtents = Vector3.zero;
        private float previousClipHitDistance = 0f;

        // Editor only
        [SerializeField] private bool isLookClipObjectsExpanded = true;

        #endregion

        #region Private Variables - Look Interactive

        /// <summary>
        /// Can the character see or detect objects with an StickyInteractive component?
        /// </summary>
        [SerializeField] private bool isLookInteractiveEnabled = false;

        /// <summary>
        /// When true, GetLookingAtPoint is updated. Also required IsLookInteractiveEnabled.
        /// to be true.
        /// </summary>
        [SerializeField] private bool isUpdateLookingAtPoint = false;

        // Editor only
        [SerializeField] private bool isLookInteractiveExpanded = true;

        /// <summary>
        /// The interactive-enabled object currently being looked at
        /// </summary>
        [System.NonSerialized] private StickyInteractive lookingAtInteractive = null;
        private int lookingAtInteractiveId = 0;

        /// <summary>
        /// This is the point in world space where the user is currently aiming or targeting.
        /// It could be an interactive-enabled object.
        /// Used when isLookInteractiveEnabled
        /// is true. This could be a StickyInteractive object position or a point
        /// lookMaxInteractiveDistance from the camera if lookingAtInteractive is null.
        /// See also isUpdateLookingAtPoint.
        /// </summary>
        private Vector3 lookingAtPoint;

        /// <summary>
        /// Used when re-enabling character.
        /// 0 = unset, 1 = was Enabled, 2 = was Disabled.
        /// </summary>
        private int savedLookInteractiveState = 0;

        #endregion

        #region Private Variables - Look Sockets

        /// <summary>
        /// Attempt to automatically show (and hide) the highlighter when looking a socket
        /// </summary>
        [SerializeField] private bool isLookSocketAutoShow = true;

        /// <summary>
        /// Can the character see or detect objects with an StickySocket component?
        /// </summary>
        [SerializeField] private bool isLookSocketsEnabled = false;

        // Editor only
        [SerializeField] private bool isLookSocketsExpanded = true;

        /// <summary>
        /// The material used to highlight a socket in the scene.
        /// If not set, one will be created at runtime.
        /// </summary>
        [SerializeField] private Material socketActiveMaterial = null;

        /// <summary>
        /// The socket currently being looked at.
        /// </summary>
        [System.NonSerialized] private StickySocket lookingAtSocket = null;
        private int lookingAtSocketId = 0;

        /// <summary>
        /// Used when re-enabling character.
        /// 0 = unset, 1 = was Enabled, 2 = was Disabled.
        /// </summary>
        private int savedLookSocketsState = 0;

        #endregion

        #region Private Variables - Look VR

        /// <summary>
        /// Is look in VR-mode for the player character?
        /// </summary>
        [SerializeField] private bool isLookVR = false;

        /// <summary>
        /// When Look VR is enabled, the character Height will be modified to match
        /// the approximate height of the human player based on the starting
        /// head-mounted device position above the floor.
        /// </summary>
        [SerializeField] private bool isMatchHumanHeightVR = false;

        /// <summary>
        /// The VR Head Mounted Device (HMD) drives character motion.
        /// </summary>
        [SerializeField] private bool isRoomScaleVR = false;

        /// <summary>
        /// The posture or starting position of the human player when wearing a
        /// VR head-mounted device.
        /// </summary>
        [SerializeField] public HumanPostureVR humanPostureVR = HumanPostureVR.Sitting;

        /// <summary>
        /// When enabled with UnityXR input, left and right turn will be incremented
        /// by the snapTurnDegrees
        /// </summary>
        [SerializeField] private bool isSnapTurnVR = false;

        /// <summary>
        /// At runtime, is VR look in use? See also isLookVR.
        /// isLookVR may be true, but for some reason is not available.
        /// </summary>
        private bool isLookVREnabled = false;

        /// <summary>
        /// Has the height of the character or the camera offset been calibrated
        /// to the head-mounted device?
        /// </summary>
        private bool isHeightCalibratedVR = false;

        private float snapTurnTimer = 0f;
        private float previousLookY = 0f;

        /// <summary>
        /// The local space offset from the characters feet for the first person camera
        /// when the floor offset is calculated. See also RecalculateFloorOffsetVR()
        /// </summary>
        private Vector3 initialFirstPersonCameraOffsetVR = Vector3.zero;

        /// <summary>
        /// The world space position where the character was standing when
        /// ReinitiliseCameraVR() as last called. Uses the HMD position.
        /// </summary>
        private Vector3 initialCameraPositionVR = Vector3.zero;

        /// <summary>
        /// The world rotation where the character was facing when ReinitiliseCameraVR()
        /// was last called.
        /// </summary>
        private Quaternion initialCameraRotationVR = Quaternion.identity;

        /// <summary>
        /// When moving based on the local x-z position of the head-mounted device
        /// in VR, we need to track where it was the last time we moved.
        /// This way, we can calculate how much the HMD moved in the last frame etc.
        /// </summary>
        private Vector3 lastHMDPosXZProcessedVR = Vector3.zero;

        /// <summary>
        /// When moving based on the local x-z position of the head-mounted device
        /// in VR, we need to track where it was in local space the last time we moved.
        /// This way, we can calculate how much the HMD moved in the last frame etc.
        /// </summary>
        private Vector3 lastHMDPosXZProcessedVRLS = Vector3.zero;

        // Editor only
        [SerializeField] private bool isLookVRExpanded = false;

        #endregion

        #region Private Variables - Cursor
        [SerializeField] private bool lookShowCursor = false; // Off by default in case of instantiating at runtime
        private float cursorTimer = 0f;

        // Switch to using the New Input System if it is available
#if SSC_UIS
        private Vector2 currentMousePosition = Vector2.zero;
        private Vector2 lastMousePosition = Vector2.zero;
#else
        private Vector3 currentMousePosition = Vector3.zero;
        private Vector3 lastMousePosition = Vector3.zero;
#endif
        #endregion

        #region Private Variables - Jet Pack
        /// <summary>
        /// Is the Jet Pack currently operating?
        /// </summary>
        [SerializeField] private bool isJetPackEnabled = false;

        /// <summary>
        /// Used when re-enabling character.
        /// 0 = unset, 1 = was Enabled, 2 = was Disabled.
        /// </summary>
        private int savedJetPackAvailableState = 0;

        /// <summary>
        /// Current health of the jet pack
        /// </summary>
        [Range(0f, 1f)] [SerializeField] private float jetPackHealth = 1f;

        private S3DRamp jetPackRampInputX = null;
        private S3DRamp jetPackRampInputY = null;
        private S3DRamp jetPackRampInputZ = null;
        private float jetPackMaxVolume = 1f;
        private S3DEffects jetPackEffectsFwd = null;
        private S3DEffects jetPackEffectsBack = null;
        private S3DEffects jetPackEffectsUp = null;
        private S3DEffects jetPackEffectsDown = null;
        private S3DEffects jetPackEffectsRight = null;
        private S3DEffects jetPackEffectsLeft = null;
        #endregion

        #region Private Variables - Audio
        // When initialised, was there an audioListener component present and enabled?
        // We remember this for EnableLook() and DisableLook()
        private bool isAudioListenerConfigured = false;
        private AudioListener audioListener = null;

        /// <summary>
        /// Is all audio muted for this character?
        /// </summary>
        private bool isAudioMuted = false;
        #endregion

        #region Private Variables - Animate General
        private int numAnimateActions = 0;
        private bool isAnimateEnabled = false;
        /// <summary>
        /// Is the character Animator currently updating in FixedUpdate?
        /// </summary>
        private bool isAnimatorFixedUpdate = false;
        /// <summary>
        /// Used when re-enabling or unpausing a character.
        /// </summary>
        private bool savedAnimateEnabledState = false;

        private AnimatorOverrideController animOverrideController = null;
        private HumanPoseHandler hposeHandler = null;
        private HumanPose humanPose;

        private int numAnimLayers = 0;
        [System.NonSerialized] private List<S3DAnimLayerData> animlayerDataList = null;

        // Editor only
        [SerializeField] private bool isS3DAnimActionListExpanded = true;
        [SerializeField] private bool isAnimActionsExpanded = true;

        #endregion

        #region Private Variables - Animate Aim IK

        /// <summary>
        /// The Humanoid bones used to help aim the character toward a target while holding a weapon
        /// </summary>
        [SerializeField] private S3DHumanBone[] aimBones;

        /// <summary>
        /// The zero-based layer in the animator controller that has the IK Pass enabled for Aim IK.
        /// If this layer (not layer 0) has an avatar mask for fingers, it needs to be above
        /// the layer than includes the character aim animation.
        /// e.g. aim ik layer = 1 and layer with animations is 2.
        /// </summary>
        [Range(0, 9), SerializeField] int aimIKAnimIKPassLayerIndex = 0;

        /// <summary>
        /// The overall bone weight when holding a weapon in first-person. Adjust this if the bones pitch
        /// up or down at a different rate to the first-person camera. This can be most noticeable when
        /// holding a weapon but not aiming it and Free Look is disabled.
        /// </summary>
        [Range(0f, 1f), SerializeField] float aimIKBoneWeightFPS = 0.6f;

        /// <summary>
        /// How quickly, in degrees per second, the character will attempt to turn toward the aim target.
        /// </summary>
        [Range(0.1f, 360f)] public float aimIkTurnRotationRate = 180f;

        // Editor only
        [SerializeField] private bool isAimBonesExpanded = true;

        // Editor only
        [SerializeField] private bool isAimIKExpanded = true;

        /// <summary>
        /// If a weapon is held, will it always attempt to face the target using Aim IK?
        /// Otherwise, it will only do this when weapon IsAiming is true.
        /// </summary>
        [SerializeField] private bool isAimIKWhenNotAiming = false;

        /// <summary>
        /// The angle to turn the character to match the aim at target position
        /// </summary>
        private float aimTurnAngle = 0f;

        /// <summary>
        /// When first person aiming is enabled, the weapon is parented, in local space,
        /// with this offset from the camera.
        /// </summary>
        private Vector3 aimIKFPWeaponOffset = new Vector3(0f, -0.05f, 0.4f);

        /// <summary>
        /// The first person camera near clipping plane when aiming a weapon.
        /// NOTE: This does not change the camera, it only stores the value to be used when aiming.
        /// </summary>
        private float aimIKFPNearClippingPlane = 0.3f;

        /// <summary>
        /// The time, in seconds, to delay the character turning to face the
        /// target when aiming starts. This allows time for a animation to transition
        /// from a held animation, to an aiming animation. It is typically associated
        /// with a weapon and character pair.
        /// </summary>
        private float aimIKTurnDelay = 0f;

        /// <summary>
        /// The timer use with aimIKTurnDelay.
        /// </summary>
        private float aimIKTurnDelayTimer = 0f;

        /// <summary>
        /// While aiming, after compeleting the initial turn to face where the weapon
        /// is facing, the cumulative angle on the y-axis, the character has been rotated
        /// since the last 3rd person camera update.
        /// </summary>
        private float aimingTurnedAngleY = 0f;

        /// <summary>
        /// The current look pitch (up-down) angle when Free Look is enabled and a held weapon starts aiming.
        /// </summary>
        private float aimingFreeLookX = 0;

        /// <summary>
        /// The current local space look horizontal (left-right) angle when Free Look is true and a held weapon starts aiming.
        /// </summary>
        private float aimingFreeLookY = 0f;

        /// <summary>
        /// How long, in seconds, should it take to rotate the character to face the aim position?
        /// </summary>
        private float aimingFreeLookDuration = 0f;

        /// <summary>
        /// How many degrees has the character turned since transition to aiming began when
        /// FreeLook was true while the weapon was held.
        /// </summary>
        private float aimingFreeLookHasTurned = 0f;

        /// <summary>
        /// The initial camera pitch (up-down) x-axis local space angle when Free Look is true and a held weapon starts aiming.
        /// </summary>
        private float aimingFreeLookXStart = 0f;

        /// <summary>
        /// The number of seconds that has passed since aiming began when FreeLook was true
        /// while holding a weapon. Note: may not be exactly the same as aimingFreeLookYTimer
        /// as Y timer could be on FixedUpdate while X timer could be LastUpdate.
        /// </summary>
        private float aimingFreeLookXTimer = 0f;

        /// <summary>
        /// The number of seconds that has passed since aiming began when FreeLook was true
        /// while holding a weapon. Note: may not be exactly the same as aimingFreeLookXTimer
        /// as Y timer could be on FixedUpdate while X timer could be LastUpdate.
        /// </summary>
        private float aimingFreeLookYTimer = 0f;

        /// <summary>
        /// The angle to pitch up/down to match the camera pitch angle
        /// </summary>
        //private float aimPitchAngle = 0;

        private int numAimBones = 0;

        /// <summary>
        /// Is the character attempting to aim at a target with AimIK?
        /// </summary>
        private bool isAimAtTargetEnabled = false;

        /// <summary>
        /// Is aiming transitioning from FreeLook being enabled. This is
        /// when a character is turning toward where the reticle was on
        /// the screen when aiming commenced.
        /// </summary>
        private bool isAimIKFromFreeLook = false;

        /// <summary>
        /// Is aim ik smoothly being disabled? ie is it transitioning
        /// from enabled to be becoming disabled?
        /// </summary>
        private bool isAimIKSmoothDisable = false;

        /// <summary>
        /// Is aim ik smoothly being enabled? ie is it transistioning
        /// from not enabled to becoming fully enabled?
        /// </summary>
        private bool isAimIKSmoothEnable = false;

        /// <summary>
        /// When a weapon is aimed and held by a character in 3rd person, should it use the first-person camera?
        /// This is typically set at runtime using a S3DWeaponAnimSet scriptable object.
        /// </summary>
        private bool isAimTPUsingFPCamera;

        /// <summary>
        /// Is third-person weapon aiming currently using the first-person camera? When aiming is stopped, the
        /// character should switch back to the third-person camera.
        /// </summary>
        private bool isAimTPUsingFPCameraEnabled;

        /// <summary>
        /// where we want to aim
        /// </summary>
        internal Vector3 aimTargetPos = Vector3.zero;

        /// <summary>
        /// TO BE DELETED
        /// </summary>
        //internal GameObject tempAimGO = null;

        /// <summary>
        /// The initial world space position the character should aim at when transitioning
        /// between not aiming and aiming.
        /// </summary>
        private Vector3 aimTargetPosSmoothEnable = Vector3.zero;

        /// <summary>
        /// Where we are aiming.
        /// When NOT aiming, this will be Vector3.zero.
        /// </summary>
        private Vector3 currentAimTargetPos = Vector3.zero;

        /// <summary>
        /// Where we are aiming from
        /// </summary>
        internal Vector3 aimFromPos = Vector3.zero;

        /// <summary>
        /// When grabbing a weapon, this is the time, in seconds, it takes the animation
        /// to play that transitions from not holding, to holding the weapon.
        /// See S3DWeaponAnimSet.heldTransitionDuration.
        /// </summary>
        private float heldTransitionDuration = 0f;

        /// <summary>
        /// Used when heldTransistionDuration > 0.
        /// </summary>
        private float heldTransitionTimer = 0f;

        private float prevCameraToAimTargetDistance = 1f;
        private Vector3 prevCameraAimTarget = Vector3.one;

        /// <summary>
        /// Remember the weapon offset from the first person camera when aiming
        /// </summary>
        internal Vector3 savedAimIKFPWeaponOffset;

        /// <summary>
        /// Remember the first person camera near clipping plane
        /// </summary>
        internal float savedAimIKFPNearClippingPlane = 0f;

        /// <summary>
        /// If there is a HUD save current value of Locked Reticle To Cursor.
        /// Currently only used when enter/exit Aiming
        /// </summary>
        private bool savedLockedReticleToCursor = false;

        /// <summary>
        /// Remember if Free Look was enabled before switching to AimIK.
        /// </summary>
        private bool savedFreeLook = false;

        /// <summary>
        /// Remember if FollowHeadPosition was enabled before switching to
        /// first person while AimIK is enabled or holding weapon without FreeLook.
        /// </summary>
        private bool savedFollowHeadPosition = false;

        /// <summary>
        /// Remember if FollowHeadPositionTP was enabled before switching to
        /// third person while AimIK is enabled or holding weapon without FreeLook.
        /// </summary>
        private bool savedFollowHeadPositionTP = false;

        /// <summary>
        /// Remember isAimIKWhenNoAiming before applying S3DWeaponAnimSets.
        /// </summary>
        internal bool savedIsAimIKWhenNotAiming = false;

        /// <summary>
        /// The world space direction the weapon (if held) is currently aiming
        /// </summary>
        internal Vector3 weaponAimDirection = Vector3.forward;

        /// <summary>
        /// Where the weapon is currently aiming or pointing. This can be different from the
        /// aimTargetPosition which is typically were the character is looking while aiming.
        /// </summary>
        internal Vector3 weaponAimPos = Vector3.zero;

        /// <summary>
        /// The world space Up direction, relative to the direction the weapon is currently aiming.
        /// </summary>
        internal Vector3 weaponAimUp = Vector3.up;

        /// <summary>
        /// The relative fire position, in world space, of the weapon (if held)
        /// </summary>
        internal Vector3 weaponFirePosition = Vector3.zero;

        #endregion

        #region Private Variables - Animate Foot IK
        /// <summary>
        /// Are the feet placed on the ground using Inverse Kinematics for Humanoid rigged characters?
        /// Call EnableFootIK() or DisableFootIK() to modify at runtime.
        /// </summary>
        [SerializeField] private bool isFootIK = false;

        /// <summary>
        /// The layer in the animator controller that has the IK Pass enabled for Foot IK
        /// </summary>
        [Range(0, 9), SerializeField] int footIKAnimIKPassLayerIndex = 0;

        /// <summary>
        /// INTERNAL ONLY]
        /// </summary>
        [SerializeField] private bool isFootIKExpanded = true;

        /// <summary>
        /// The hash code for the left foot IK Weight Curve parameter. 0 = unset.
        /// </summary>
        [SerializeField] private int paramHashLFootIKWeightCurve = 0;

        /// <summary>
        /// The hash code for the right foot IK Weight Curve parameter. 0 = unset.
        /// </summary>
        [SerializeField] private int paramHashRFootIKWeightCurve = 0;

        [System.NonSerialized] private Transform leftFootTrfm = null;
        [System.NonSerialized] private Transform rightFootTrfm = null;

        private S3DFootData leftFootData = null;
        private S3DFootData rightFootData = null;

        private float currentFootIKOffsetY = 0f;
        private float prevFootIKOffsetY = 0f;
        #endregion

        #region Private Variables - Animate Head IK
        /// <summary>
        /// The head can follow a target within defined constaints
        /// </summary>
        [SerializeField] private bool isHeadIK = false;

        /// <summary>
        /// The layer in the animator controller that has the IK Pass enabled for Head IK
        /// </summary>
        [Range(0, 9), SerializeField] private int headIKAnimIKPassLayerIndex = 0;

        /// <summary>
        /// When the Head IK target is a character, look toward their eyes
        /// </summary>
        [SerializeField] private bool headIKLookAtEyes = true;

        /// <summary>
        /// When look interactive and Update Looking Point are enabled,
        /// while the character is stationary, the head will face either
        /// the interactive enabled object being looked at, or in the direction
        /// the character is looking.
        /// </summary>
        [SerializeField] private bool headIKLookAtInteractive = false;

        [System.NonSerialized] private Transform headTrfm = null;
        /// <summary>
        /// The transform of the object the head should be looking at
        /// </summary>
        [System.NonSerialized] private Transform headTargetTrfm = null;

        /// <summary>
        /// The target position the head should be looking at
        /// </summary>
        private Vector3 targetHeadIKPos = Vector3.zero;
        private Vector3 currentHeadIKPos = Vector3.zero;
        private Vector3 prevHeadIKPos = Vector3.zero;
        /// <summary>
        /// Euler angles of x:pitch, y: horizontal, z: tilt (unused)
        /// Should be calculated in LateUpdate()
        /// </summary>
        private Vector3 prevHeadIKAngles = Vector3.zero;
        private float currentHeadIKVelo = 0f; // used with headIKAdjustForVelocity for Mathf.SmoothDamp(..)
        private float prevHeadIKDeltaVelo = 0f;
        /// <summary>
        /// Local space offset from the target transform the head should be looking at
        /// </summary>
        private Vector3 targetHeadIKPosOffset = Vector3.zero;
        private bool isHeadIKSmoothDisable = false;
        private bool isHeadIKSmoothEnable = false;
        private float currentMaxHeadIKWeight = 1f;

        // Editor only
        [SerializeField] private bool isHeadIKExpanded = true;

        #endregion

        #region Private Variables - Animate Hand IK

        /// <summary>
        /// Are the hands moved using Inverse Kinematics for Humanoid rigged characters?
        /// Call EnableHandIK() or DisableHandIK() to modify at runtime.
        /// </summary>
        [SerializeField] private bool isHandIK = false;

        /// <summary>
        /// The local space offset the palm, or centre, of the hand is from the left hand bone position
        /// </summary>
        [SerializeField] private Vector3 leftHandPalmOffset = Vector3.zero;
        /// <summary>
        /// The local space offset the palm, or centre, of the hand is from the right hand bone position
        /// </summary>
        [SerializeField] private Vector3 rightHandPalmOffset = Vector3.zero;

        /// <summary>
        /// The local space left hand palm rotation from the hand bone stored in degrees.
        /// The palm normal, stored as a rotation.
        /// </summary>
        [SerializeField] private Vector3 leftHandPalmRotation = Vector3.zero;

        /// <summary>
        /// The local space right hand palm rotation from the hand bone stored in degrees.
        /// The palm normal, stored as a rotation.
        /// </summary>
        [SerializeField] private Vector3 rightHandPalmRotation = Vector3.zero;

        /// <summary>
        /// Left Elbow hint transform for Hand IK. Should be approx 0.25 directly behind elbow
        /// </summary>
        [SerializeField] private Transform handIKLHElbowHint = null;

        /// <summary>
        /// Right Elbow hint transform for Hand IK. Should be approx 0.25 directly behind elbow
        /// </summary>
        [SerializeField] private Transform handIKRHElbowHint = null;

        /// <summary>
        /// The maximum distance the left hand will attempt to reach for an object.
        /// </summary>
        [SerializeField, Range(0.1f, 1f)] private float handIKLHMaxReachDist = 0.3f;
        /// <summary>
        /// The maximum distance the right hand will attempt to reach for an object.
        /// </summary>
        [SerializeField, Range(0.1f, 1f)] private float handIKRHMaxReachDist = 0.3f;

        [SerializeField] private bool showLHGizmosInSceneView = false;
        [SerializeField] private bool showRHGizmosInSceneView = false;

        /// <summary>
        /// The layer in the animator controller that has the IK Pass enabled for Hand IK
        /// </summary>
        [Range(0, 9), SerializeField] int handIKAnimIKPassLayerIndex = 0;

        // Common bones - must be present in any valid humanoid.
        [System.NonSerialized] private Transform leftHandTrfm = null;
        [System.NonSerialized] private Transform rightHandTrfm = null;
        [System.NonSerialized] private Transform leftUpperArmTrfm = null;
        [System.NonSerialized] private Transform rightUpperArmTrfm = null;
        [System.NonSerialized] private Transform leftLowerArmTrfm = null;
        [System.NonSerialized] private Transform rightLowerArmTrfm = null;

        private float leftArmLength = 0f;
        private float rightArmLength = 0f;

        /// <summary>
        /// Use when HandIK is being disabled
        /// </summary>
        private bool isHandIKSmoothDisable = false;
        /// <summary>
        /// Used when HandIK is being enabled
        /// </summary>
        private bool isHandIKSmoothEnable = false;
        private float currentMaxHandIKWeight = 1f;

        /// <summary>
        /// Typically used when transistioning to an animation clip
        /// that includes the left hand
        /// </summary>
        private bool isHandIKLeftBlendOut = false;
        /// <summary>
        /// Typically used when transistioning to an animation clip
        /// that includes the right hand
        /// </summary>
        private bool isHandIKRightBlendOut = false;
        /// <summary>
        /// The maximum weight when blending out a left hand IK target.
        /// Typically used when transistioning to an animation clip.
        /// </summary>
        private float currentMaxLHandWeight = 0f;
        /// <summary>
        /// The maximum weight when blending out a right hand IK target.
        /// Typically used when transistioning to an animation clip.
        /// </summary>
        private float currentMaxRHandWeight = 0f;

        [Range(0.001f, 10f)] float leftHandIKBlendOutDuration = 2f;
        [Range(0.001f, 10f)] float rightHandIKBlendOutDuration = 2f;

        private S3DHandData leftHandData = null;
        private S3DHandData rightHandData = null;

        private MethodInfo miGetLimitSign = null;
        private MethodInfo miGetPreRotation = null;
        private MethodInfo miGetPostRotation = null;

        /// <summary>
        /// The maximum distance between the left upper arm and the target
        /// </summary>
        private float leftMaxArmReachDistance = 0;
        /// <summary>
        /// The maximum distance between the right upper arm and the target
        /// </summary>
        private float rightMaxArmReachDistance = 0;

        /// <summary>
        /// The target transform the left hand should be reaching toward
        /// </summary>
        [System.NonSerialized] private Transform leftHandTargetTrfm = null;
        /// <summary>
        /// The target transform the right hand should be reaching toward
        /// </summary>
        [System.NonSerialized] private Transform rightHandTargetTrfm = null;
        /// <summary>
        /// The target interactive-enabled object the left hand should be reaching toward.
        /// This may have additional offset and rotation data.
        /// </summary>
        [System.NonSerialized] private StickyInteractive leftHandTargetInteractive = null;
        /// <summary>
        /// The target interactive-enabled object the right hand should be reaching toward.
        /// This may have additional offset and rotation data.
        /// </summary>
        [System.NonSerialized] private StickyInteractive rightHandTargetInteractive = null;

        // Editor only
        [SerializeField] private bool isHandIKExpanded = true;
        [SerializeField] private bool isLeftHandIKExpanded = true;
        [SerializeField] private bool isRightHandIKExpanded = true;
        [SerializeField] private Color handZoneGizmoColour = new Color(1f, 1f, 1f, 0.8f);

#if UNITY_EDITOR
        // Editor only to show hand targets in the scene view
        private Color handLHTargetGizmoColour = new Color(0f, 1f, 0f, 0.9f);
        private Color handRHTargetGizmoColour = new Color(0f, 0f, 1f, 0.9f);
#endif

        #endregion

        #region Private Variables - Animate Hand VR

        /// <summary>
        /// Are the hands animated using VR controllers?
        /// Call EnableHandVR() or DisableHandVR() to modify at runtime.
        /// </summary>
        [SerializeField] private bool isHandVR = false;

        [SerializeField] private S3DAnimAction leftHandVRGrip = null;
        [SerializeField] private S3DAnimAction rightHandVRGrip = null;
        [SerializeField] private S3DAnimAction leftHandVRTrigger = null;
        [SerializeField] private S3DAnimAction rightHandVRTrigger = null;

        // Editor only
        [SerializeField] private bool isHandVRExpanded = true;

        /// <summary>
        /// [INTERNAL ONLY] Is Hand VR enabled at runtime?
        /// </summary>
        private bool isHandVRAnimateLHEnabled = false;
        private bool isHandVRAnimateRHEnabled = false;

        private CharacterInputXR currentCharInputXR = null;
        private CharacterInputXR previousCharInputXR = null;

        #endregion

        #region Private Variables - Animate Ragdoll

        [SerializeField] private List<S3DHumanBonePersist> ragdollBoneList = null;

        // Editor only
        [SerializeField] private bool isRagdollExpanded = false;

        /// <summary>
        /// Is the character currently acting like a ragdoll?
        /// </summary>
        private bool isRagdollEnabled = false;

        private int numRagdollBones = 0;

        private bool savedRagdollIsAnimateEnabled = false;

        #endregion

        #region Private Variables - Animate Root Motion
        /// <summary>
        /// Is Animation Root Motion used to influence character position and rotation?
        /// </summary>
        [SerializeField] private bool isRootMotion = false;

        /// <summary>
        /// Do animations drive turn left or right? Input can be sent to the animator controller
        /// via Anim Actions, and S3D reads the rotation from the avatar.
        /// </summary>
        [SerializeField] private bool isRootMotionTurning = false;

        /// <summary>
        /// When root motion is enabled, velocity below this level will be considered idle.
        /// Some idle animations move the character around a little. Increasing this value
        /// will make IsIdle more stable. Default: 0.0001.
        /// </summary>
        [SerializeField, Range(0.0001f, 0.2f)] private float rootMotionIdleThreshold = 0.0001f;

        [System.NonSerialized] private Vector3 rootMotionLocalPosError = Vector3.zero;

        [System.NonSerialized] private Quaternion rootMotionRotDelta = Quaternion.identity;

        // Editor only
        [SerializeField] private bool isRootMotionExpanded = true;

        #endregion

        #region Private Variables - Engage General

        /// <summary>
        /// The number of Interactive-enabled object that can be selected in the scene at the same time.
        /// When the value is zero (the default) no items can be selected.
        /// </summary>
        [SerializeField, Range(0, 5)] private int storeMaxSelectableInScene = 0;

        /// <summary>
        /// The number of seconds to delay firing the onInitialised event methods after
        /// the S3D character has been initialised.
        /// </summary>
        [SerializeField, Range(0f, 30f)] private float onInitialisedEvtDelay = 0f;

        /// <summary>
        /// The colour associated with engaging with an interactive-enabled object in the scene.
        /// Typically used by the StickyDisplayModule reticle when is hovering over an object.
        /// See Events, onInteractLookAtChanged
        /// </summary>
        [SerializeField] private Color32 engageColour = new Color32(0, 255, 0, 128);

        /// <summary>
        /// The colour associated with not engaging with an interactive-enabled object in the scene.
        /// Typically used by the StickyDisplayModule reticle when not hovering over an object.
        /// </summary>
        [SerializeField] private Color32 nonengageColour = new Color32(255, 255, 255, 128);

        /// <summary>
        /// The list of damage regions for this character. There should always be one
        /// which should be added automatically.
        /// </summary>
        [SerializeField] private List<S3DDamageRegion> damageRegionList = null;

        /// <summary>
        /// The common interactive tags scriptableobject used to determine which interactive objects
        /// can be added to this character. Typically only one would be used for all interactive objects
        /// as the text is only used to help you remember what each number from 1-32 represent.
        /// See also Equip Points.
        /// </summary>
        [SerializeField] protected S3DInteractiveTags interactiveTags = null;

        // Start damage in the enabled state
        private bool isDamageEnabled = true;
        private bool savedDamageEnabledState = false;
        private int numDamageRegions = 0;
        private int numStoreSelectedInScene = 0;

        /// <summary>
        /// Unordered unique set of damage region colliders for this character. Does NOT contain
        /// the main damage region capsule collider. For that see capsuleColliderId or StickyID
        /// </summary>
        [System.NonSerialized] private HashSet<int> damageRegionColliders = new HashSet<int>();

        /// <summary>
        /// [INTERNAL ONLY] The items currently selected in the scene by this character.
        /// </summary>
        [System.NonSerialized] private List<S3DStoreItem> selectedInSceneStoreItemList;

        /// <summary>
        /// [INTERNAL ONLY] The item being held in the left hand
        /// </summary>
        [System.NonSerialized] private StickyInteractive leftHandInteractive = null;
        /// <summary>
        /// [INTERNAL ONLY] The item being held in the right hand
        /// </summary>
        [System.NonSerialized] private StickyInteractive rightHandInteractive = null;

        /// <summary>
        /// [INTERNAL ONLY] The magazine held in the left hand
        /// </summary>
        [System.NonSerialized] private StickyMagazine leftHandMagazine = null;
        /// <summary>
        /// [INTERNAL ONLY] The magazine held in the right hand
        /// </summary>
        [System.NonSerialized] private StickyMagazine rightHandMagazine = null;

        /// <summary>
        /// [INTERNAL ONLY] The weapon held in the left hand
        /// </summary>
        [System.NonSerialized] private StickyWeapon leftHandWeapon = null;
        /// <summary>
        /// [INTERNAL ONLY] The weapon held in the right hand
        /// </summary>
        [System.NonSerialized] private StickyWeapon rightHandWeapon = null;

        //private bool lastDamageWasCollisionDamage = false;

        /// <summary>
        /// [INTERNAL ONLY] The ID of the object being held in the left hand
        /// </summary>
        private int leftHandInteractiveId = 0;
        /// <summary>
        /// [INTERNAL ONLY] The ID of the object being held in the right hand
        /// </summary>
        private int rightHandInteractiveId = 0;
        /// <summary>
        /// [INTERNAL ONLY] Is the item being held in the left hand a StickyMagazine?
        /// </summary>
        private bool isLeftHandHoldingMagazine = false;
        /// <summary>
        /// [INTERNAL ONLY] Is the item being held in the right hand a StickyMagazine?
        /// </summary>
        private bool isRightHandHoldingMagazine = false;
        /// <summary>
        /// [INTERNAL ONLY] Is the item being held in the left hand a StickyWeapon?
        /// </summary>
        private bool isLeftHandHoldingWeapon = false;
        /// <summary>
        /// [INTERNAL ONLY] Is the item being held in the right hand a StickyWeapon?
        /// </summary>
        private bool isRightHandHoldingWeapon = false;

        /// <summary>
        /// The currently Active StickyPopupModules being display near the character.
        /// Stored as an unordered unique set of popup instanceIds.
        /// </summary>
        [System.NonSerialized] private HashSet<int> popupActiveInstanceIDs = new HashSet<int>();

        /// <summary>
        /// [INTERNAL ONLY]
        /// The left hand StickyXRInteractor component. Need to be careful as the component
        /// also references StickyControlModule. See StickyXRInteractor.OnDestroy()
        /// </summary>
        [System.NonSerialized] internal StickyXRInteractor leftHandXRInteractor = null;

        /// <summary>
        /// [INTERNAL ONLY]
        /// The right hand StickyXRInteractor component. Need to be careful as the component
        /// also references StickyControlModule. See StickyXRInteractor.OnDestroy()
        /// </summary>
        [System.NonSerialized] internal StickyXRInteractor rightHandXRInteractor = null;


        [System.NonSerialized] private S3DDamageRegion mainDamageRegion = null;

        internal Coroutine revertAnimClipsDelayed = null;

        // Editor only
        [SerializeField] private bool isEngageGeneralExpanded = true;
        [SerializeField] private bool isEngageEventsExpanded = false;
        [SerializeField] private bool isEngageEquipExpanded = false;
        [SerializeField] private bool isEngageStashExpanded = false;
        [SerializeField] private bool isEngageDamageRegionsExpanded = false;
        [SerializeField] private bool isEngageDamageRegionListExpanded = false;
        [SerializeField] private bool isEngageEquipPointListExpanded = false;
        [SerializeField] private bool isEngageRespawnExpanded = false;

        #endregion

        #region Private Variables - Engage Equip

        /// <summary>
        /// The list of equip points for equipped inactive interactive objects
        /// </summary>
        [SerializeField] private List<S3DEquipPoint> equipPointList;

        private bool isEquipInitialised = false;
        private int numEquipPoints = 0;
        private Coroutine equipInteractiveDelayed = null;

        #endregion

        #region Private Variables - Engage Respawn

        /// <summary>
        /// How respawning happens if the character has unlimited or at least 1 spare life
        /// </summary>
        [SerializeField] private RespawningMode respawnMode = RespawningMode.DontRespawn;

        /// <summary>
        /// The maximum number of lives that the character can have.
        /// 0 = unlimited.
        /// </summary>
        [SerializeField, Range(0, 50)] private int maxLives = 10;

        /// <summary>
        /// The number of the lives the character has when it is initialised
        /// </summary>
        [SerializeField, Range(0, 50)] private int startLives = 3;

        private int currentLives = 0;
        private Vector3 currentRespawnPosition = Vector3.zero;
        private Quaternion currentRespawnRotation = Quaternion.identity;

        /// <summary>
        /// [INTERNAL ONLY] Is the character currently waiting to respawn?
        /// </summary>
        private bool isRespawning = false;

        private bool isRespawingPaused = false;
        private float respawnTimer = 0f;

        #endregion

        #region Private Variables - Enagage Stash

        /// <summary>
        /// The child transform under which all items are stashed
        /// </summary>
        [SerializeField] private Transform stashParent = null;

        /// <summary>
        /// The list of interactive-enabled objects stashed on the character
        /// </summary>
        [SerializeField] private List<S3DStoreItem> stashList = null;

        /// <summary>
        /// Is the stash initialised and ready for use?
        /// </summary>
        private bool isStashInitialised = false;

        /// <summary>
        /// The number of items stashed on this character
        /// </summary>
        private int numStashedItems = 0;

        [System.NonSerialized] List<StickyInteractive> tempStickyInteractiveList = null;

        #endregion

        #endregion

        #region Private Initialisation Methods

        // Awake is called before the first frame update
        void Awake()
        {
            if (initialiseOnAwake) { Initialise(); }
        }

        #endregion

        #region Update Events

        // Update is called once per frame
        void Update()
        {
            if (!isInitialised) { return; }

            if (isRespawning)
            {
                #region Respawning

                // If we are currently respawning, count down respawn timer
                respawnTimer -= isRespawingPaused ? 0f : Time.deltaTime;

                // Once respawn time reaches zero, respawn the character
                if (respawnTimer <= 0f) { Respawn(); }

                #endregion
            }
            else
            {
                if (!isMoveFixedUpdate) { UpdateController(false); }
                else { if (isMovementEnabled) { UpdateTransformPosition(); } }

                if (isLookEnabled)
                {
                    // NOTE: This is set to false when DisableCharacter is called
                    if (lookAutoHideCursor) { CheckCursor(); }
                    else if (!isLookVREnabled && (isLookInteractiveEnabled || isLookSocketsEnabled))
                    {
                        UpdateCurrentMousePosition();
                        lastMousePosition = currentMousePosition;
                    }

                    // Call after CheckCursor()
                    if (isLookInteractiveEnabled)
                    {
                        if (!isLookVREnabled)
                        {
                            SeekInteractiveObjects(lookInteractiveLockToCamera ? new Vector2(Screen.width * 0.5f, Screen.height * 0.5f) : MouseScreenPoint(false));
                        }

                        CheckHeadIKLookAtInteractive();
                    }

                    if (isLookSocketsEnabled && !isLookVREnabled)
                    {
                        SeekSockets(lookSocketLockToCamera ? new Vector2(Screen.width * 0.5f, Screen.height * 0.5f) : MouseScreenPoint(false));
                    }
                }

                if (isMovementEnabled)
                {
                    UpdateWeapons();
                }

                #region Check damage
                if (isDamageEnabled)
                {
                    S3DDamageRegion damageRegion;
                    for (int dmgIdx = 0; dmgIdx < numDamageRegions; dmgIdx++)
                    {
                        damageRegion = damageRegionList[dmgIdx];

                        if (dmgIdx == 0 && !damageRegion.isInvincible && damageRegion.Health <= 0f)
                        {
                            DestroyCharacter(false);
                        }
                        else
                        {
                            damageRegion.CheckShieldRecharge();
                        }
                    }
                }
                #endregion
            }
        }

        void FixedUpdate()
        {
            if (isRespawning || !isInitialised) { return; }

            if (isMoveFixedUpdate) { UpdateController(true); }

            if (isLookFixedUpdate && isThirdPersonValid) { MoveThirdPersonCamera(true, isSmoothCameraUpdate); }
        }

        void LateUpdate()
        {
            if (isRespawning || !isInitialised) { return; }

            if (isThirdPersonValid)
            {
                // TPS aiming or held without FreeLook. Look uses FixedUpdate OR LateUpdate.
                if (isAnimateEnabled && !isAimIKSmoothEnable && heldTransitionTimer == 0f && (isAimAtTargetEnabled || (!isFreeLook && (isRightHandHoldingWeapon || isLeftHandHoldingWeapon))))
                {
                    AimBonesAtTarget(false);
                }

                if (!isLookFixedUpdate)
                {
                    MoveThirdPersonCamera(false, isSmoothCameraUpdate);
                }
            }
            else if (!isThirdPerson)
            {
                if (isLookVREnabled) { MoveXRCamera(false); }
                else if (!isLookFixedUpdate && isUpdateLookMovement) { MoveFirstPersonCamera(false); }
            }
            
            // OnAnimateIK gets run before LateUpdate and modifies hand, head, and head transform positions
            if (isAnimateEnabled)
            {
                // First person aiming uses AimBonesFPS(..) which is called from OnAnimatorIK when aiming
                // or "could" run in this method when not aiming and FreeLook is not enabled.
                // HOWEVER, when the Animator uses UnityPhysics the bones go crazy.
                // NOTE: This can get some camera clipping through the arms or weapon.
                if (!isLookFixedUpdate && !isThirdPerson && !isFreeLook && !isAnimatorFixedUpdate && !isAimAtTargetEnabled && (isRightHandHoldingWeapon || isLeftHandHoldingWeapon))
                {
                    AimBonesFPS(false);
                }

                // When first person camera runs in LateUpdate, LookCameraFollowHead() needs to run
                // after the spine bones are rotated to aim at the weapon target.
                if (!isLookFixedUpdate && !isThirdPerson && isLookCameraFollowHead && isUpdateLookMovement)
                {
                    LookCameraFollowHead();
                }

                if (isHandIK)
                {
                    UpdateHandData(leftHandData, true);
                    UpdateHandData(rightHandData, false);

                    // FPS aiming while crouching (otherwise it is done in OnAnimateIK).
                    // In FPS, we need to get the position of the weapon after the first-person
                    // camera has been updated.
                    if (!isThirdPerson && isAimAtTargetEnabled && !isNPC && currentCrouchInput)
                    {
                        // These do nothing if the target transforms are null.
                        HandIKAdjustForHandHold(leftHandData, leftHandTargetTrfm);
                        HandIKAdjustForHandHold(rightHandData, rightHandTargetTrfm);
                    }
                }

                // Currently doesn't produce correct pitch angles...
                //if (isHeadIK)
                //{
                //    HeadIKGetLocalAngles(out prevHeadIKAngles);
                //}

                if (isFootIK)
                {
                    if (!footIKPositionOnly)
                    {
                        FootIKCheckToeClipping(leftFootData, true);
                        FootIKCheckToeClipping(rightFootData, false);
                    }

                    UpdateFootData(leftFootData, true);
                    UpdateFootData(rightFootData, false);
                }
            }
        }

        #endregion

        #region Update and Move Controller Methods

        /// <summary>
        /// This is the main method where all the action happens each frame
        /// </summary>
        /// <param name="isFixedUpdate">Has this been called from the FixedUpdate Loop?</param>
        private void UpdateController(bool isFixedUpdate)
        {
            #region Reset or Initialise frame-based variables
            isJumpStartedThisFrame = false;
            // Get the static property once
            float dTime = isFixedUpdate ? Time.fixedDeltaTime : Time.deltaTime;
            isSmoothCameraUpdate = true; // Default
            #endregion

            #region Calculate Position/Rotation From Previous Frame

            // Get information from reference frame
            if (currentReferenceFrame != null)
            {
                // Get reference frame position and rotation
                currentReferenceFrameRotation = currentReferenceFrameRotationMultiplier * currentReferenceFrame.rotation;
                currentReferenceFramePosition = currentReferenceFrame.position;
                currentReferenceFrameUp = currentReferenceFrame.up;
            }
            else
            {
                // If reference frame is null assume a "zero" reference frame
                currentReferenceFramePosition = Vector3.zero;
                currentReferenceFrameRotation = Quaternion.identity;
                currentReferenceFrameUp = Vector3.up;
            }

            // We retain the relative position and rotation from the last frame
            // Convert current position and rotation into world space
            currentWorldPosition = currentReferenceFramePosition + (currentReferenceFrameRotation * currentRelativePosition);
            currentWorldRotation = currentReferenceFrameRotation * currentRelativeRotation;

            // Remember previous character directions
            currentCharacterUp = currentWorldRotation * Vector3.up;
            currentCharacterFwd = currentWorldRotation * Vector3.forward;
            currentCharacterRight = currentWorldRotation * Vector3.right;

            #endregion

            #region Get current size of character

            // Start crouching (or stop crouching) - this doesn't occur when the Jet Pack is enabled.
            // See SendInput(..) for more information.
            if (!isMovementEnabled || isPositionLocked) { } // Do not crouch or uncrouch
            else if (currentCrouchInput)
            {
                // Do we need to adjust the height and therefore the worldPosition?
                if (prevScaledHeight > height * crouchHeightNormalised)
                {
                    float _newHeight = prevScaledHeight - (crouchSpeed * dTime);
                    if (_newHeight < height * crouchHeightNormalised) { _newHeight = height * crouchHeightNormalised; }

                    // If the height was changed, and in first person, change the first person camera height
                    if (ChangeHeight(_newHeight) && !isThirdPerson) { SetLookCameraHeight(); }
                }

                prevCrouching = true;
                isForcedCrouch = false;

                //DebugExtension.DebugCapsule(GetBottom(currentWorldPosition, currentCharacterUp, false), GetTop(currentWorldPosition, currentCharacterUp, false), Color.magenta, currentScaledRadius);

            }
            // Stop crouching, so adjust height and worldPosition
            else if (!isTemporaryHeight && currentScaledHeight < height)
            {
                float _newHeight = currentScaledHeight + (crouchSpeed * dTime);
                if (_newHeight > height) { _newHeight = height; }

                // If the height was changed, and in first person, change the first person camera height
                if (ChangeHeight(_newHeight))
                {
                    if (!isThirdPerson) { SetLookCameraHeight(); }
                    isForcedCrouch = false;

                    if (capsuleCollider.height != height)
                    {
                        capsuleCollider.height = height;
                        capsuleCollider.center = new Vector3(0f, pivotToCentreOffsetY, 0f);
                    }
                }
                // Couldn't increase height while attempting to stand from a crouching position
                else if (prevCrouching)
                {
                    isForcedCrouch = true;
                }

                if (prevCrouching && currentScaledHeight == height)
                {
                    prevCrouching = false;
                }
            }

            prevScaledHeight = currentScaledHeight;
            #endregion

            // TODO calculate is grounded from previous frame collision calculations

            #region Is Grounded, is landing, and Reference Frame Check

            previousIsGrounded = isGrounded;

            RaycastHit groundSphereCastHitInfo;
            groundCollider = null;

            // In v1.0.0 to 1.0.2 this as sweepTolerance * 2f.
            // Issue: character can float sweepTolerance above the ground.
            float groundCheckDistance = sweepTolerance * 2f;

            // Cast a ray directly downwards to check if we are on the ground
            raycastRay.direction = currentWorldRotation * -Vector3.up;
            raycastRay.origin = currentWorldPosition + raycastRay.direction * (-currentScaledBottomY - currentScaledRadius - sweepTolerance);
            currentRelativeTargetUp = Vector3.up;

            if ((refUpdateTypeInt == RefUpdateTypeAutoInt || alignToGroundNormal) && Physics.SphereCast(raycastRay, currentScaledRadius, out groundSphereCastHitInfo, groundCheckDistance, referenceFrameLayerMask, QueryTriggerInteraction.Ignore))
            {
                groundCollider = groundSphereCastHitInfo.collider;
                groundHitPoint = groundSphereCastHitInfo.point;
                Transform hitObject = groundCollider.transform;

                // Check the reference frame
                // TODO - Resolve issue of adjoining colliders that have different rotation.
                // This causes the character to suddenly be facing the wrong direction.

                if (refUpdateTypeInt == RefUpdateTypeAutoInt)
                {
                    if (currentReferenceFrame == null)
                    {
                        if (isUseRBodyReferenceFrame) { SetCurrentReferenceFrame(groundCollider); }
                        else { SetCurrentReferenceFrame(hitObject); }
                    }
                    else if (hitObject.GetHashCode() != currentReferenceFrameId && !hitObject.transform.IsChildOf(currentReferenceFrame))
                    {
                        if (isUseRBodyReferenceFrame) { SetCurrentReferenceFrame(groundCollider); }
                        else { SetCurrentReferenceFrame(hitObject); }
                    }
                }

                if (alignToGroundNormal)
                {
                    AlignToGroundNormal(groundSphereCastHitInfo.normal);
                }
                else { currentRelativeTargetUp = Vector3.up; }

                isGrounded = true;
                isSteppingDown = false;
            }
            // Don't need to check the reference frame but still don't want to detect trigger colliders
            else if (refUpdateTypeInt != RefUpdateTypeAutoInt && Physics.SphereCast(raycastRay, currentScaledRadius, out groundSphereCastHitInfo, groundCheckDistance, referenceFrameLayerMask, QueryTriggerInteraction.Ignore))
            {
                // Debug.Log("[DEBUG] is grounded check T:" + Time.time);

                groundCollider = groundSphereCastHitInfo.collider;
                groundHitPoint = groundSphereCastHitInfo.point;
                isGrounded = true;
                isSteppingDown = false;
            }
            // Prevent going to not grounded when walking up steps (or climbing) and test for walking/sprinting down steps
            else
            {
                //isGrounded = isStepping || isClimbing;
                isGrounded = isStepping;
                groundHitPoint = Vector3.zero;

                // Are we walking down steps?
                // How far is it to the ground? Cast a ray directly downwards to find the nearest ground
                raycastRay.direction = currentWorldRotation * -Vector3.up;
                // Start sweepTolerance above the bottom of the character to cater for when character is already on or very near ground.
                raycastRay.origin = currentWorldPosition + raycastRay.direction * (-currentScaledBottomY - sweepTolerance - 0.001f);

                if (!isGrounded && !isInJump && Physics.Raycast(raycastRay, out groundSphereCastHitInfo, maxStepOffset, collisionLayerMask, QueryTriggerInteraction.Ignore))
                {
                    // NOTE: Setting to isGrounded does not work... floats at top of step for a few moments
                    isSteppingDown = true;
                }
                else { isSteppingDown = false; }
            }

            isLanding = isGrounded && !previousIsGrounded;

            if (isLanding) { isInJump = false; }

            //Debug.DrawRay(raycastRay.origin, raycastRay.direction.normalized * sweepTolerance * 2f, Color.red);

            #endregion

            #region Depenetration Calculations and Check Triggers

            // Remember the world position pre-depenetration calculations
            Vector3 preDepenetrationWorldPosition = currentWorldPosition;

            // Perform an overlap capsule test to check if any colliders (including triggers) have moved within our
            // collider during the previous frame/s
            // If FootIK is enabled, raise the capsule up from the bottom to let it go up steps and slopes
            Vector3 preDepenetrationCapsuleBottom = GetBottom(preDepenetrationWorldPosition, currentCharacterUp, true);
            Vector3 preDepenetrationCapsuleTop = GetTop(preDepenetrationWorldPosition, currentCharacterUp, true);

            int overlapCapsuleResultsSize = Physics.OverlapCapsuleNonAlloc(
                preDepenetrationCapsuleBottom, preDepenetrationCapsuleTop,
                radius, overlapCapsuleResults, collisionLayerMask, QueryTriggerInteraction.Collide);

            // Iterate over all the returned colliders
            Vector3 depenetrationDirection = Vector3.zero;
            float depenetrationDistance = 0f, depenetrationDistanceTotal = 0f;

            frameTriggerColliders.Clear();
            frameCollisionColliders.Clear();

            for (int i = 0; i < overlapCapsuleResultsSize; i++)
            {
                // TODO - consider resizing disabled capsuleCollider for ComputePenetration when crouching
                // For each collider, compute the vector required to move the character to depenetrate the collider
                // (so that we are no longer inside of it)
                // IMPORTANT1: S3D must have Trigger Collider enabled to get pushed by other objects else
                // depenetrationDirection and depenetrationDistance return 0,0,0 and 0.
                // IMPORTANT2: Physics.ComputePenetration will return our own capsuleCollider if is enabled (compare with ID).
                otherCollider = overlapCapsuleResults[i];
                bool isPentration = Physics.ComputePenetration(capsuleCollider, preDepenetrationWorldPosition, currentWorldRotation,
                    otherCollider, otherCollider.gameObject.transform.position, otherCollider.gameObject.transform.rotation,
                    out depenetrationDirection, out depenetrationDistance);

                // Triggers return a depenetrationDistance of 0, so no need to depenetrate them.
                if (!otherCollider.isTrigger)
                {
                    // Ignore colliders that are attached to this character. This is particularly relevant when an object
                    // is attached to say the hand and then hits the capsule collider if Trigger Collider is enabled on
                    // the Collide tab.
                    if (isPentration && (!isTriggerColliderEnabled || !IsColliderSelf(otherCollider)))
                    {
                        // Shift the current world position by this vector
                        currentWorldPosition += depenetrationDirection * depenetrationDistance;

                        depenetrationDistanceTotal += depenetrationDistance;
                    }
                }
                // Eliminate own capsule collider
                else if (!IsColliderSelf(otherCollider) && otherCollider.GetComponent<StickyFoot>() == null)
                {
                    bool hitOtherS3D = false;

                    if (isTriggerColliderEnabled)
                    {
                        // Check for other S3D with trigger collider enabled
                        /// TODO - find a more efficient way of checking for S3D component

                        // Find the parent object and elliminate non-RB objects
                        Rigidbody rb = otherCollider.attachedRigidbody;

                        if (rb != null)
                        {
                            // The user could have added another trigger collider to the character.
                            // e.g. SampleLookAtPlayer.cs uses a sphere trigger collider.
                            // WARNING: PERFORMANCE IMPACT - probab should use a int array of other colliders in IsColliderSelf(..) as an option

                            StickyControlModule otherS3D = rb.GetComponent<StickyControlModule>();

                            // Did we hit the capsule or feet of another S3D but not any trigger collider attached to this character?
                            hitOtherS3D = otherS3D != null && otherS3D.IsColliderSelf(otherCollider) && !otherCollider.transform.IsChildOf(transform);

                            if (isPentration && hitOtherS3D)
                            {
                                // Shift the current world position by this vector
                                currentWorldPosition += depenetrationDirection * depenetrationDistance;
                                depenetrationDistanceTotal += depenetrationDistance;
                            }
                        }
                    }

                    if (!hitOtherS3D && (isOnTriggerEnterEnabled || isOnTriggerStayEnabled))
                    {
                        frameTriggerColliders.Add(otherCollider.GetInstanceID());

                        // Is this the first time we're entering the trigger collider?
                        if (!inTriggerColliders.Contains(otherCollider))
                        {
                            inTriggerColliders.Add(otherCollider);
                            if (isOnTriggerEnterEnabled)
                            {
                                otherCollider.SendMessage("OnTriggerEnter", capsuleCollider, SendMessageOptions.DontRequireReceiver);
                            }
                        }

                        if (isOnTriggerStayEnabled) { otherCollider.SendMessage("OnTriggerStay", capsuleCollider, SendMessageOptions.DontRequireReceiver); }
                    }
                }

            }
            otherCollider = null;

            #region Check to see if we have exited any trigger collider(s)
            if (isOnTriggerEnterEnabled || isOnTriggerStayEnabled)
            {
                // Remove any colliders that are null (not sure what would happen if 2 colliders became null in same frame...)
                inTriggerColliders.RemoveWhere(col => col == null);

                int numInTriggerColliders = inTriggerColliders.Count;

                // Find colliders that the character has exited
                foreach (Collider collider in inTriggerColliders)
                {
                    if (collider != null && !frameTriggerColliders.Contains(collider.GetInstanceID()))
                    {
                        removeColliderList.Add(collider);

                        if (isOnTriggerEnterEnabled) { collider.SendMessage("OnTriggerExit", capsuleCollider, SendMessageOptions.DontRequireReceiver); }
                    }
                }

                // Remove all the trigger colliders that the character is not longer inside
                foreach (Collider collider in removeColliderList)
                {
                    RemoveCollider(collider);
                }

                removeColliderList.Clear();
            }
            #endregion

            // Remember the world position post-depenetration calculations
            Vector3 postDepenetrationWorldPosition = currentWorldPosition;
            Vector3 postDepenetrationRelativePosition = Quaternion.Inverse(currentReferenceFrameRotation) * (postDepenetrationWorldPosition - currentReferenceFramePosition);

            #endregion

            #region Compute New Relative Velocity / Position

            // Get current velocity in the local space of the character
            // Character should not have any local velocity when movement is disabled
            currentLocalVelocity = isMovementEnabled ? Quaternion.Inverse(currentRelativeRotation) * currentRelativeVelocity : Vector3.zero;

            Vector3 addedVeloFromForce = CalculateVeloForceAtPoint();

            if (!isPositionLocked && isJetPackAvailable && isJetPackEnabled)
            {
                #region Jet Pack
                GetRampedJetPackInput();

                // Check fuel and health levels
                if (jetPackFuelLevel > 0f && jetPackHealth > 0f && isUpdateLookMovement && (currentLocalSpaceMovementInput.z != 0f || currentLocalSpaceMovementInput.x != 0f || currentLocalSpaceMovementInput.y != 0f))
                {
                    // Max speed and consider acceleration
                    float availableJetPackSpeed = jetPackSpeed * jetPackHealth;

                    // Calculate current velocity in the local space of the character
                    Vector3 targetLocalVelocity = new Vector3
                    (
                        currentLocalSpaceMovementInput.x * availableJetPackSpeed,
                        currentLocalSpaceMovementInput.y * availableJetPackSpeed,
                        currentLocalSpaceMovementInput.z * availableJetPackSpeed
                    );

                    Vector3 targetLocalVelocityDelta = targetLocalVelocity - currentLocalVelocity;
                    targetLocalVelocityDelta = Vector3.ClampMagnitude(targetLocalVelocityDelta, jetPackMaxAcceleration * dTime);

                    currentLocalVelocity += targetLocalVelocityDelta;

                    // Transform the local space velocity back into the provided reference frame
                    currentRelativeVelocity = currentRelativeRotation * currentLocalVelocity;

                    // Burn fuel independently to the health level. A damaged jet pack will burn the same
                    // amount of fuel but produce less thrust
                    jetPackFuelLevel -= jetPackFuelBurnRate * dTime;

                    if (jetPackFuelLevel < 0f) { jetPackFuelLevel = 0f; }
                }

                // If there is fuel available, pass in the max of x and y input values
                SetJetPackEffects();

                // Damp velocity when no jet pack input
                if (jetPackDamping > 0f && currentLocalSpaceMovementInput.x == 0f && currentLocalSpaceMovementInput.z == 0f && currentLocalSpaceMovementInput.y == 0f)
                {
                    currentRelativeVelocity *= 1f - (jetPackDamping * dTime);
                }
                #endregion
            }
            else if (isMovementEnabled && !isPositionLocked && (isGrounded || allowMovementInAir || isStepping || isClimbing))
            {
                // RootMotion is always updated in FixedUpdate().
                // OnAnimationMove() runs in FixedUpdate() - I think.
                // Animations gets applied by Unity in LateUpdate().
                if (isRootMotion)
                {
                    // Set the velocity in such a way so that we move to the correct position (where the animator thinks we should
                    // be) by the end of this frame. This approach however allows S3D to apply acceleration limits etc.
                    currentLocalVelocity = rootMotionLocalPosError / dTime;
                }
                else if (isLookVREnabled && isRoomScaleVR && isHeightCalibratedVR)
                {
                    /// TODO GetLocalVelocityFromHMD() needs to consider when ref frame is moving and rotating
                    // This is required for stepping
                    currentLocalSpaceMovementInput = GetLocalVelocityFromHMD();

                    // Get the velocity in metres per second (this is what moves the character)
                    currentLocalVelocity = currentLocalSpaceMovementInput / (dTime > 0f ? dTime : 0.02f);

                    currentLocalSpaceMovementInput.y = 0f;
                    if (currentLocalSpaceMovementInput.sqrMagnitude > Vector3.kEpsilon)
                    {
                        currentLocalSpaceMovementInput = Vector3.Normalize(currentLocalSpaceMovementInput);
                    }
                }
                else
                {
                    // Calculate current velocity in the local space of the character
                    Vector3 targetLocalVelocity = new Vector3
                    (
                        currentLocalSpaceMovementInput.x * (isClimbing ? climbSpeed : currentSprintInput ? sprintSpeed : strafeSpeed) * health, 0f,
                        currentLocalSpaceMovementInput.z * (isClimbing ? climbSpeed : currentSprintInput ? sprintSpeed : walkSpeed) * health
                    );

                    Vector3 targetLocalVelocityDelta = targetLocalVelocity - currentLocalVelocity;
                    targetLocalVelocityDelta.y = 0f;

                    // This is required for max acceleration, but seems to cause some issues with depenetration
                    //if (depenetrationDistanceTotal < 0.01f)
                    {
                        targetLocalVelocityDelta = Vector3.ClampMagnitude(targetLocalVelocityDelta, maxAcceleration * dTime);
                    }

                    currentLocalVelocity += targetLocalVelocityDelta + addedVeloFromForce;
                }

                // Transform the local space velocity back into the provided reference frame
                currentRelativeVelocity = currentRelativeRotation * currentLocalVelocity;
            }

            #region Jump
            // Allow jump when on the ground (or climbing) and not using jet pack
            // Prevent jumping when the char has just landed. This avoids the case where user has configured a jump
            // animation that leads to a landing animation and can result in getting stuck on the Jump animation.
            if ((isGrounded || isClimbing) && isMovementEnabled && !isPositionLocked && !isStepping && !isLanding && (!isJetPackAvailable || !isJetPackEnabled))
            {
                if (currentJumpInput || isDelayedJumpThisFrame)
                {
                    // Do we need to delay the jump action to allow an animation or part of an animation to play first?
                    if (currentJumpInput && jumpDelay > 0f && !isDelayedJumpThisFrame)
                    {
                        // Avoid multiple jumps when the jump key can be held down (typically used with the jetpack)
                        if (!isJumpingWithDelay)
                        {
                            isJumpStartedThisFrame = true;
                            isJumpingWithDelay = true;
                            Invoke("DelayedJump", jumpDelay);
                        }
                    }
                    // No delayed jump action OR this is the frame in which a delayed jump action occurs.
                    else if (jumpDelay == 0f || isDelayedJumpThisFrame)
                    {
                        // If jumping, it is reset at the end of this method after AnimateCharacter() is called.
                        currentRelativeVelocity += currentRelativeRotation * Vector3.up * jumpSpeed * health;
                        // Stop climbing if we jump
                        isClimbing = false;
                        isClimbingAtTop = false;

                        // The jump will have only begun if the user has pressed the jump button
                        // and the jump hasn't been delayed.
                        isJumpStartedThisFrame = currentJumpInput && jumpDelay == 0f;

                        // A jump has started
                        isInJump = true;
                    }

                    isDelayedJumpThisFrame = false;
                }
            }
            #endregion

            #region Apply acceleration due to gravity
            if (!isStepping && !isGrounded && (!isClimbingEnabled || !isClimbing) && (!isJetPackAvailable || !isJetPackEnabled) && isMovementEnabled && !isPositionLocked)
            {
                currentRelativeVelocity.y -= gravitationalAcceleration * dTime;

                // Should we apply any (fake) falling acceleration?
                if (currentRelativeVelocity.y < 0f) { currentRelativeVelocity.y -= arcadeFallMultiplier * gravitationalAcceleration * dTime; }
            }
            #endregion

            #endregion

            #region Collision Calculations, Stepping and Climbing

            #region Init Movement Variables
            // Convert current velocity into world space
            currentWorldVelocity = currentReferenceFrameRotation * currentRelativeVelocity;

            // Set the current world position as where we started from after depenetration
            currentWorldPosition = postDepenetrationWorldPosition;

            float worldMoveDeltaMagnitude = 0f;
            Vector3 worldMoveDelta = currentWorldVelocity * dTime;
            Vector3 worldMoveDeltaNormalised, thisSweepMoveDelta, sweepToleranceVector;

            // This is the direction in which the character wants to move.
            // Not to be confused with the actual direction the character is moving.
            Vector3 worldMoveDirection = currentWorldRotation * (currentLocalSpaceMovementInput == Vector3.zero ? Vector3.forward : currentLocalSpaceMovementInput.normalized);

            int sweepIterationsCount = 0;
            bool continueIterating = true;
            //groundSlopeAngle = 0f;
            #endregion

            if (isMovementEnabled && !isPositionLocked)
            {
                // If we touch the ground while climbing down, stop climbing.
                if (isClimbing && isGrounded && currentLocalSpaceMovementInput.z < -0.001f)
                {
                    isClimbing = false;
                    isClimbingAtTop = false;
                }

                if (isClimbing)
                {
                    #region Climbing

                    // Calculate how far up to move this frame based on climbing speed
                    // Use forward/back input as up/down when climbing
                    float stepVerticalThisFrame = currentLocalSpaceMovementInput.z * climbSpeed * dTime * health;
                    float stepHorizontalThisFrame = currentLocalSpaceMovementInput.x * climbSpeed * dTime * health;

                    if (stepVerticalThisFrame > 0.0001f || stepVerticalThisFrame < -0.0001f ||
                        stepHorizontalThisFrame > 0.0001f || stepHorizontalThisFrame < -0.0001f)
                    {
                        // Shift the character away from the wall slightly in the hopes that it avoids any situations
                        // where the later capsule casts start inside a wall due to floating point error
                        currentWorldPosition += currentClimbingWallNormal * 0.0001f;

                        // Calculate the vector of how far we "want" to move in space
                        Vector3 testWallMoveVector = (currentClimbingWallUpDir * stepVerticalThisFrame) +
                            (currentClimbingWallRightDir * stepHorizontalThisFrame);
                        float testWallMoveVectorMagnitude = testWallMoveVector.magnitude;
                        Vector3 testWallMoveVectorNormalised = testWallMoveVector / testWallMoveVectorMagnitude;

                        Vector3 currentWorldPositionCapsuleBottom = GetBottom(currentWorldPosition, currentCharacterUp, true);
                        Vector3 currentWorldPositionCapsuleTop = GetTop(currentWorldPosition, currentCharacterUp, true);
                        RaycastHit capsuleCastHitInfo;

                        // Capsule cast in the direction we want to move in
                        sweepToleranceVector = testWallMoveVectorNormalised * sweepTolerance;
                        if (Physics.CapsuleCast(
                            currentWorldPositionCapsuleBottom - sweepToleranceVector, currentWorldPositionCapsuleTop - sweepToleranceVector,
                            currentScaledRadius, testWallMoveVectorNormalised, out capsuleCastHitInfo, testWallMoveVectorMagnitude + sweepTolerance, climbableLayerMask, QueryTriggerInteraction.Ignore))
                        {
                            // We hit something climbable - so the wall curves outwards (i.e. towards us)
                            // Raycast towards the position we reached from a pointed near where we started, but shifted
                            // away from the wall (so that we raycast at a 45 degree angle)
                            float originalTestWallMoveVectorMagnitude = testWallMoveVectorMagnitude;
                            currentWorldPosition += testWallMoveVector;
                            testWallMoveVector = testWallMoveVector - (currentClimbingWallNormal * testWallMoveVectorMagnitude);
                            testWallMoveVectorMagnitude = testWallMoveVector.magnitude;
                            testWallMoveVectorNormalised = testWallMoveVector / testWallMoveVectorMagnitude;
                            // NOTE: The code from here on is the same as in the below else branch
                            // EXCEPT for the start of the capsule cast
                            sweepToleranceVector = testWallMoveVectorNormalised * sweepTolerance;
                            if (Physics.CapsuleCast(
                                currentWorldPositionCapsuleBottom + (currentClimbingWallNormal * originalTestWallMoveVectorMagnitude) - sweepToleranceVector,
                                currentWorldPositionCapsuleTop + (currentClimbingWallNormal * originalTestWallMoveVectorMagnitude) - sweepToleranceVector,
                                currentScaledRadius, testWallMoveVectorNormalised, out capsuleCastHitInfo, (testWallMoveVectorMagnitude * 2f) + sweepTolerance, climbableLayerMask, QueryTriggerInteraction.Ignore))
                            {
                                currentClimbingWallNormal = capsuleCastHitInfo.normal;

                                // Move to the point we found with the capsule cast
                                if (currentClimbingWallNormal != currentCharacterUp)
                                {
                                    currentWorldPosition += testWallMoveVector * (capsuleCastHitInfo.distance - sweepTolerance);
                                }
                                else
                                {
                                    isClimbing = false;
                                    isClimbingAtTop = false;
                                }
                            }
                            else
                            {
                                // If we don't find a wall, exit climbing
                                isClimbing = false;
                                isClimbingAtTop = false;
                            }
                        }
                        else
                        {
                            // We did not hit something climbable - so the wall curves inwards (i.e. away from us)
                            // Capsule cast from the position we reached back towards where we were - but at a 45 degree angle
                            // Aim is to find the wall again

                            CheckIsClimbingAtTop(stepVerticalThisFrame);

                            // Attempt to find the wall again
                            currentWorldPosition += testWallMoveVector;
                            currentWorldPositionCapsuleBottom += testWallMoveVector;
                            currentWorldPositionCapsuleTop += testWallMoveVector;
                            testWallMoveVector = -(testWallMoveVector + (currentClimbingWallNormal * testWallMoveVectorMagnitude));
                            testWallMoveVectorMagnitude = testWallMoveVector.magnitude;
                            testWallMoveVectorNormalised = testWallMoveVector / testWallMoveVectorMagnitude;
                            // NOTE: The code from here on is the same as in the above if branch
                            // EXCEPT for the start of the capsule cast and checking for edge at bottom of capsule.
                            sweepToleranceVector = testWallMoveVectorNormalised * sweepTolerance;
                            if (Physics.CapsuleCast(
                                currentWorldPositionCapsuleBottom - sweepToleranceVector,
                                currentWorldPositionCapsuleTop - sweepToleranceVector,
                                currentScaledRadius, testWallMoveVectorNormalised, out capsuleCastHitInfo, (testWallMoveVectorMagnitude * 2f) + sweepTolerance, climbableLayerMask, QueryTriggerInteraction.Ignore))
                            {
                                // NOTE: CapsuleCast (and SphereCast) return the -ve normal of the capsule at that point not the actual hit collider face.
                                // We "could" do an additional short raycast against the collider (hit.collider.Raycast), but edges of colliders
                                // can return the normal of either face.
                                // Instead, check to see if we maybe hit an edge with the bottom hemisphere of the capsule

                                float localHitOffsetY = GetLocalOffsetFromBottom(currentWorldPosition, capsuleCastHitInfo.point).y;

                                // Only update the wall normal when the capsule bottom hemisphere is NOT the hit point, as this will
                                // distort the normal (most likely the top edge of the collider).
                                if (localHitOffsetY >= currentScaledRadius)
                                {
                                    currentClimbingWallNormal = capsuleCastHitInfo.normal;
                                }

                                //Vector3 rayOrigin = capsuleCastHitInfo.point + (capsuleCastHitInfo.normal * 0.01f);
                                //if (capsuleCastHitInfo.collider.Raycast(new Ray(rayOrigin, -capsuleCastHitInfo.normal), out capsuleCastHitInfo, 0.011f))
                                //{
                                //    currentClimbingWallNormal = capsuleCastHitInfo.normal;
                                //}

                                // Move to the point we found with the capsule cast
                                if (currentClimbingWallNormal != currentCharacterUp)
                                {
                                    currentWorldPosition += testWallMoveVector * (capsuleCastHitInfo.distance - sweepTolerance);
                                }
                                else
                                {
                                    isClimbing = false;
                                    isClimbingAtTop = false;
                                }
                            }
                            else
                            {
                                // If we don't find a wall, exit climbing
                                isClimbing = false;

                                if (isClimbingAtTop && stepVerticalThisFrame > 0.0001f)
                                {
                                    // Move forward to avoid getting stuck on the edge
                                    currentWorldPosition += (currentCharacterUp * 0.001f) + (currentCharacterFwd * 0.02f);
                                }
                                isClimbingAtTop = false;
                            }
                        }

                        if (isClimbing)
                        {
                            currentClimbingWallRightDir = Vector3.Cross(currentClimbingWallNormal, currentCharacterUp);
                            float crossProductMagnitude = currentClimbingWallRightDir.magnitude;
                            // Avoid NaN in WallRight and Mathf.Asin due to floating point error. dir.magnitude can be slightly more tha 1f.
                            // Without this, the character can fall off a 90 deg wall when reference frame is rotating.
                            crossProductMagnitude = crossProductMagnitude > 1f ? 1f : (crossProductMagnitude < -1f ? -1f : crossProductMagnitude);
                            currentClimbingWallRightDir /= crossProductMagnitude;
                            // Also calculate wall slope angle as a by-product
                            float wallSlopeAngle = Mathf.Asin(crossProductMagnitude) * Mathf.Rad2Deg;
                            currentClimbingWallUpDir = Vector3.Cross(currentClimbingWallRightDir, currentClimbingWallNormal);

                            // Set is climbing based on the slope angle of the wall
                            isClimbing = minClimbSlopeAngle <= wallSlopeAngle + 0.01f && wallSlopeAngle - 0.01f <= maxClimbSlopeAngle;

                            if (!isClimbing && isClimbingAtTop && stepVerticalThisFrame > 0.0001f)
                            {
                                isClimbingAtTop = false;
                                // character is trying to walk forward so avoid getting stuck at top.
                                currentWorldPosition += (currentCharacterUp * 0.001f) + (currentCharacterFwd * 0.001f);
                            }
                        }
                    }
                    else
                    {
                        // Get the climbable surface normal when not attempting to move
                        RaycastHit capsuleCastHitInfo;
                        Vector3 currentWorldPositionCapsuleBottom = GetBottom(currentWorldPosition, currentCharacterUp, true);
                        Vector3 currentWorldPositionCapsuleTop = GetTop(currentWorldPosition, currentCharacterUp, true);

                        // Capsule cast forward
                        sweepToleranceVector = currentCharacterFwd * sweepTolerance;
                        if (Physics.CapsuleCast(
                            currentWorldPositionCapsuleBottom - sweepToleranceVector, currentWorldPositionCapsuleTop - sweepToleranceVector,
                            currentScaledRadius, currentCharacterFwd, out capsuleCastHitInfo, 1f + sweepTolerance, climbableLayerMask, QueryTriggerInteraction.Ignore))
                        {
                            currentClimbingWallNormal = capsuleCastHitInfo.normal;
                        }
                    }

                    // Rotate towards facing the climbable surface
                    // If the character is not moving, use the last known climbing wall normal.
                    if (isClimbing)
                    {
                        // Get both the -ve normal and the character forward into the same reference frame local space.
                        // Local space direction to face the climbable surface
                        Vector3 desiredFaceWallDir = Quaternion.Inverse(currentReferenceFrameRotation) * -currentClimbingWallNormal;
                        Vector3 charFwdRF = Quaternion.Inverse(currentReferenceFrameRotation) * currentCharacterFwd;

                        // Smoothly add the rotational difference between the -ve surface normal and the character forwards
                        currentRelativeRotation = Quaternion.RotateTowards(currentRelativeRotation,
                                                                           Quaternion.FromToRotation(charFwdRF, desiredFaceWallDir) * currentRelativeRotation,
                                                                           climbFaceSurfaceRate * dTime);
                    }

                    #endregion
                }
                else
                {
                    #region Sweep Iterations with Stepping (check for climbing)
                    stepUpHeight = 0f;

                    // Iterate using sweep tests (in this case we are using capsule casts) until we resolve the motion with collisions
                    while (continueIterating)
                    {
                        // Calculate the magnitude of the world space movement delta,
                        // and use it to normalise the vector
                        worldMoveDeltaMagnitude = worldMoveDelta.magnitude;
                        // Prevent NaN when not moving. This is the actual direction the character is moving.
                        worldMoveDeltaNormalised = worldMoveDeltaMagnitude == 0f ? Vector3.zero : worldMoveDelta / worldMoveDeltaMagnitude;

                        // Sweep a capsule through the scene, starting from the current world position and moving along the
                        // current movement delta. Start a given distance (the sweep tolerance) backwards so that if we are up
                        // against a wall, the capsule cast finds the wall.
                        sweepToleranceVector = worldMoveDeltaNormalised * sweepTolerance;

                        // Calculate the current world position top and bottom of the capsule
                        Vector3 currentWorldPositionCapsuleBottom = GetBottom(currentWorldPosition, currentCharacterUp, true);
                        Vector3 currentWorldPositionCapsuleTop = GetTop(currentWorldPosition, currentCharacterUp, true);

                        RaycastHit capsuleCastHitInfo;

                        // Anything in front of the character's current direction, lower than the sweep tolerance, will be stepped up onto if there is
                        // nothing < height of the character above it.
                        if (Physics.CapsuleCast(
                            currentWorldPositionCapsuleBottom - sweepToleranceVector, currentWorldPositionCapsuleTop - sweepToleranceVector,
                            currentScaledRadius, worldMoveDeltaNormalised, out capsuleCastHitInfo, worldMoveDeltaMagnitude + sweepTolerance, collisionLayerMask, QueryTriggerInteraction.Ignore))
                        {
                            #region Interaction RigidBody Collision
                            Rigidbody otherRB = capsuleCastHitInfo.rigidbody;
                            // Did we hit a non-kinematic rigidbody which has a Unity Layer included in the interactionLayerMask?
                            if (interactionLayerMask != 0 && dTime > 0f && otherRB != null && !otherRB.isKinematic && IsLayerInMask(interactionLayerMask, otherRB.gameObject.layer))
                            {
                                // Calculate collision velo and force when hitting a dynamic rigidbody
                                float m1 = rBody.mass;
                                float m2 = otherRB.mass;

                                // Use world space velocity of both colliding objects (similar but not identical to rBody.velocity)
                                Vector3 u1 = transform.rotation * currentLocalVelocity; // rBody.velocity;
                                Vector3 u2 = otherRB.velocity;

                                // Force to apply to the object we hit
                                Vector3 f2 = (m2 / dTime) * ((((2 * u1 * m1) - (u2 * m1) + (u2 * m2)) / (m1 + m2)) - u2);

                                // Apply the force at the point of contact in a single frame
                                otherRB.AddForceAtPosition(f2, capsuleCastHitInfo.point);

                                // Calculate the new velocity of the character after the collision.
                                // BUG: This can make character to walk inside the collider of the other object
                                // if the object couldn't move.
                                currentWorldVelocity = ((u1 * m1) - (u1 * m2) + (2f * u2 * m2)) / (m1 + m2);

                                // Convert the world space velocity into local velocity
                                currentLocalVelocity = Quaternion.Inverse(transform.rotation) * currentWorldVelocity;

                                // Update the relative velocity (not sure if we need this here or not)
                                currentRelativeVelocity = currentRelativeRotation * currentLocalVelocity;
                            }
                            #endregion

                            #region Check if step or climbable obstacle is in front
                            // If there is something in the way, check if we can step up onto it.
                            //Debug.DrawRay(capsuleTopRadiusOffsetPos, raycastRay.direction.normalized * (currentScaledHeight - (2 * currentScaledRadius)), Color.yellow);

                            // Can step up onto an obstacle if character is already on the ground (or is stepping/climbing).
                            // Can step or potentially climb when already climbing.
                            // AllowMovementInAir can put us in contact with a step or climbable surface.
                            if (isGrounded || isStepping || isClimbing || allowMovementInAir)
                            {
                                GetStepAndSlope
                                (currentWorldPositionCapsuleBottom, worldMoveDirection, worldMoveDeltaMagnitude,
                                currentCharacterUp, currentWorldRotation * Vector3.forward,
                                out stepUpHeight, out groundSlopeAngle, out checkIfClimbable, out steppingContactPoint, out steppingContactHeight, out steppingContactNormal);

                                isStepping = stepUpHeight > 0.001f;

                                #region Stepping
                                if (isStepping)
                                {
                                    // Calculate how far up should we move this frame based on step-up speed                                
                                    float stepUpThisFrame = stepUpSpeed * dTime;

                                    // Step-up should be relative or proportional to movement speed yet must have a min speed.
                                    // TODO - use movement xz speed.
                                    float absVeloZ = currentLocalVelocity.z < 0f ? -currentLocalVelocity.z : currentLocalVelocity.z;
                                    if (absVeloZ > walkSpeed) { stepUpThisFrame *= 1f + (stepUpBias * absVeloZ / sprintSpeed); }

                                    // Clamp upwards movement to the step height
                                    if (stepUpThisFrame > stepUpHeight) { stepUpThisFrame = stepUpHeight; }

                                    // Calculate the corresponding amount to move forward
                                    float stepFwdThisFrame = 0f;
                                    // We only want to move forward if we the rounded part of the capsule is at the level
                                    // of the top of the step
                                    if (stepUpHeight < currentScaledRadius)
                                    {
                                        stepFwdThisFrame = stepUpThisFrame * (currentScaledRadius - stepUpHeight) / Mathf.Sqrt((2f * currentScaledRadius * stepUpHeight) - (stepUpHeight * stepUpHeight));
                                    }

                                    // Move an additional distance forward when we reach the top of the step to avoid getting stuck
                                    if (stepUpThisFrame > stepUpHeight - 0.001f)
                                    {
                                        float additionalFwdDist = (stepFwdThisFrame * 0.1f > 0.05f ? stepFwdThisFrame * 0.1f : 0.05f);
                                        stepFwdThisFrame += additionalFwdDist;
                                        stepUpThisFrame += additionalFwdDist * Mathf.Tan(groundSlopeAngle * Mathf.Deg2Rad);
                                    }

                                    // Move the character
                                    currentWorldPosition += currentCharacterUp * stepUpThisFrame;
                                    currentWorldPosition += worldMoveDirection * stepFwdThisFrame;

                                    // Stop iterating, as we have completed movement
                                    continueIterating = false;
                                }
                                #endregion

                                #region Slope too steep
                                if (groundSlopeAngle > maxSlopeAngle)
                                {
                                    // Stop iterating, as we cannot get up this slope
                                    continueIterating = false;
                                }
                                #endregion

                                #region Climbing
                                if (checkIfClimbable && isClimbingEnabled && !isStepping)
                                {
                                    #region Climbing Potential
                                    // GetStepAndSlope(..) checks the Unity Layer of at the contact point.
                                    // If we needed to check other potential contact points in front of the
                                    // character, we could do it here.

                                    currentClimbingWallNormal = steppingContactNormal;

                                    // Only allow climbing if the wall is infront of the character.
                                    // This also prevents climbing animations playing when the character has their back to a climbable wall.
                                    if (Vector3.Dot(-currentClimbingWallNormal, currentCharacterFwd) > 0f)
                                    {
                                        currentClimbingWallRightDir = Vector3.Cross(currentClimbingWallNormal, currentCharacterUp);
                                        float crossProductMagnitude = currentClimbingWallRightDir.magnitude;

                                        // Avoid NaN in WallRightDir and Mathf.Asin due to floating point error. dir.magnitude can be slightly more tha 1f.
                                        // Without this, the character can fall off a 90 deg wall when reference frame is rotating.
                                        crossProductMagnitude = crossProductMagnitude > 1f ? 1f : (crossProductMagnitude < -1f ? -1f : crossProductMagnitude);

                                        currentClimbingWallRightDir /= crossProductMagnitude;

                                        // Also calculate wall slope angle as a by-product
                                        float wallSlopeAngle = Mathf.Asin(crossProductMagnitude) * Mathf.Rad2Deg;
                                        currentClimbingWallUpDir = Vector3.Cross(currentClimbingWallRightDir, currentClimbingWallNormal);

                                        // Set is climbing based on the slope angle of the wall
                                        isClimbing = minClimbSlopeAngle <= wallSlopeAngle + 0.01f && wallSlopeAngle - 0.01f <= maxClimbSlopeAngle;

                                        // Stop iterating, as we have completed movement
                                        continueIterating = false;
                                    }
                                    #endregion
                                }
                                else
                                {
                                    isClimbing = false;
                                    isClimbingAtTop = false;
                                }
                                #endregion
                            }

                            #endregion

                            #region Wall Sliding
                            if (continueIterating)
                            {
                                // Check that we haven't hit something before the character itself (caused by sweep tolerance)
                                float sweepDistance = capsuleCastHitInfo.distance - sweepTolerance;

                                // There is currently a bug (#286 in hacknplan) where the sweep capsule can hit a neighbouring collider that is below the surface.
                                // The character then gets stuck because Wall Sliding prevents it from moving forward
                                // Possibly only run wallsliding code when hitpoint it above the forward-projected plane from the feet.

                                // Is the bottom of the character "above" or "below" this plane based on the character Up direction?
                                //Plane plane = new Plane(currentCharacterUp, capsuleCastHitInfo.point);
                                //bool isHitAbove = plane.GetSide(GetBottom(currentWorldPosition, currentCharacterUp));

                                if (sweepDistance <= 0f)
                                {
                                    // If we hit something before the character itself, we should not move the character
                                    // according to the sweep results (as they were incorrect)
                                    // Instead, offset the character very slightly based on the normal of what we hit 
                                    // This is done so that we don't suffer from issues where the capsule sweep starts very close to the
                                    // colliding surface and even moving parallel to the surface can move into it due to 
                                    // floating-point imprecision, leading to just repeating the same innaccurate sweep over and over
                                    currentWorldPosition += capsuleCastHitInfo.normal * 0.000001f;
                                    //worldMoveDelta += capsuleCastHitInfo.normal * 0.000001f;
                                    // Project the world move delta onto the plane formed by the hit normal
                                    worldMoveDelta = Vector3.ProjectOnPlane(worldMoveDelta, capsuleCastHitInfo.normal);
                                }
                                else
                                {
                                    // Allow the character to slide along a wall

                                    // Otheriwse, sweep worked correctly
                                    // Calculate how far we can move along this sweep before hitting a wall
                                    thisSweepMoveDelta = worldMoveDelta * (sweepDistance / worldMoveDeltaMagnitude);
                                    // Move the current world position by this vector
                                    currentWorldPosition += thisSweepMoveDelta;
                                    // Project the leftover world move delta onto the plane formed by the hit normal,
                                    // and store this as the new world move delta
                                    worldMoveDelta = Vector3.ProjectOnPlane(worldMoveDelta - thisSweepMoveDelta, capsuleCastHitInfo.normal);
                                }
                            }
                            #endregion
                        }
                        else
                        {
                            // We didn't hit anything in the sweep
                            isStepping = false;

                            #region Climbing without Movement OR grabbing a climbable object
                            // We may be climbing but have stopped trying to move
                            if (isClimbing)
                            {
                                // Character is climbing but is not trying to climb up/down, left or right.
                                if (currentLocalSpaceMovementInput.x == 0f && currentLocalSpaceMovementInput.z == 0f)
                                {
                                    // TODO - remove the climbing vector component (what happens if the character has some other retained velocity??)
                                    worldMoveDelta = Vector3.zero;
                                }
                                else
                                {
                                    isClimbing = false;
                                    isClimbingAtTop = false;
                                }
                            }
                            else if (isClimbingEnabled && !isGrounded && !allowMovementInAir)
                            {
                                // Is character trying to grab a climbable collider?
                                if (currentLocalSpaceMovementInput.x != 0f || currentLocalSpaceMovementInput.z > 0f)
                                {
                                    // TODO - check from shoulder height (rather than from just in-front of the centre of character colllider)
                                    Vector3 _startPoint = GetCentre(currentWorldPosition, currentCharacterUp) + (currentCharacterFwd * currentScaledRadius);
                                    RaycastHit grabHitInfo;

                                    // TODO - this prob should be a more expensive capsule-cast so we can safely move (OR do a raycast first, then a capsule cast if we find something)
                                    // TODO - If wall slopes towards the characters feet, be careful not to put character inside the wall.

                                    // TODO - consider actual xz current input.

                                    if (Physics.Raycast(_startPoint, currentCharacterFwd, out grabHitInfo, maxGrabDistance, climbableLayerMask, QueryTriggerInteraction.Ignore))
                                    {
                                        // We hit something now check how far it is actually safe to move with a CapsuleCast
                                        // as the wall may not be flat or parallel with our character.

                                        // Sometimes accelerates in an unexpected way climbing around a corner.
                                        worldMoveDelta += currentCharacterFwd * (grabHitInfo.point - _startPoint).magnitude;

                                        isClimbingAtTop = false;
                                        isClimbing = true;
                                    }
                                }
                            }
                            #endregion

                            // We didn't hit anything in the sweep, so simply move the current world position by the world move delta
                            currentWorldPosition += worldMoveDelta;

                            // Stop iterating, as we have completed movement
                            continueIterating = false;
                        }

                        // Exit the loop when we reach the max sweep iterations
                        sweepIterationsCount++;
                        if (sweepIterationsCount >= maxSweepIterations) { continueIterating = false; }
                    }
                    #endregion
                }
            }

            // Convert current position into the provided reference frame
            currentRelativePosition = Quaternion.Inverse(currentReferenceFrameRotation) * (currentWorldPosition - currentReferenceFramePosition);

            #endregion

            // Remember our final un-adjusted relative position for velocity purposes
            unadjustedRelativePosition = currentRelativePosition;

            #region Compute New Relative Angular Velocity, Rotation, or camera orbit (free look only)

            // *****************
            // WARNING: currentLocalAngularVelocity currently isn't being updated when Root Motion is enabled with isRootMotionTurning.
            // currentRelativeAngularVelocity currently also isn't being updated when Root Motion is enabled with isRootMotionTurning.
            // *****************

            // Turning left/right unless climbing or the climb adjust to surface normal is 0.
            if (!isClimbing || climbFaceSurfaceRate == 0f)
            {
                #region RootMotion
                if (isRootMotion && isRootMotionTurning)
                {
                    if (isMovementEnabled && !isPositionLocked)
                    {
                        // Turning is being driven by the rotation of the avatar. i.e. from animation rotation
                        //currentLocalAngularVelocity.y = defaultAnimator.angularVelocity.y;
                        currentRelativeRotation *= rootMotionRotDelta;
                    }
                    // TODO - add isFreeLook support for root motion
                }
                #endregion

                #region Look VR
                else if (isLookVREnabled)
                {
                    currentLocalAngularVelocity.y = 0f;

                    if (isUpdateLookMovement)
                    {
                        float localAngleAdjustmentY = 0f;

                        if (isRoomScaleVR)
                        {
                            // Project the Head Mounted Device camera direction onto the HMD x-z plane
                            Vector3 camFwd = Vector3.ProjectOnPlane(currentXRLookInput * Vector3.forward, Vector3.up);

                            // Calc just the y-axis local component
                            localAngleAdjustmentY = Vector3.SignedAngle(Vector3.forward, camFwd, Vector3.up);

                            /// TODO - try adding some smooth rotation

                            // Get the difference between the current y-axis rotation and the previous value
                            currentLocalAngularVelocity.y = localAngleAdjustmentY - previousLookY;

                            previousLookY = localAngleAdjustmentY;
                        }

                        else if (isSnapTurnVR)
                        {
                            if (snapTurnTimer > 0f) { snapTurnTimer -= Time.deltaTime; }

                            // After the last snap turn has finished, did we get any horizontal look input?
                            if (snapTurnTimer <= 0f && (currentHorizontalLookInput < -0.1f || currentHorizontalLookInput > 0.1f))
                            {
                                snapTurnTimer = snapTurnIntervalTime;
                                localAngleAdjustmentY = currentHorizontalLookInput > 0f ? snapTurnDegrees : -snapTurnDegrees;

                                currentLocalAngularVelocity.y = localAngleAdjustmentY;
                            }
                        }
                        else
                        {
                            // Project the Head Mounted Device camera direction onto the HMD x-z plane
                            Vector3 camFwd = Vector3.ProjectOnPlane(currentXRLookInput * Vector3.forward, Vector3.up);

                            // Calc just the y-axis local component
                            localAngleAdjustmentY = Vector3.SignedAngle(Vector3.forward, camFwd, Vector3.up);

                            // Get the difference between the current y-axis rotation and the previous value
                            currentLocalAngularVelocity.y = localAngleAdjustmentY - previousLookY;

                            previousLookY = localAngleAdjustmentY;
                        }

                        // keep track of how much the character has turned since the last camera movement
                        localTurnedY += currentLocalAngularVelocity.y;
                    }
                }
                #endregion

                #region AimIK
                else if (isAimAtTargetEnabled && !isPositionLocked && (isUpdateLookMovement || isNPC))
                {
                    currentLocalAngularVelocity.y = 0f;

                    // Transistion 
                    if (isAimIKSmoothEnable)
                    {
                        // The position to be aimed at shouldn't change during the transition to aiming.
                        /// TODO - this looks wrong for stopping smooth transition to aiming. SHOULD NOT BE currentWorldPosition...
                        if ((aimTargetPosSmoothEnable - currentWorldPosition).sqrMagnitude < Mathf.Epsilon)
                        {
                            isAimIKSmoothEnable = false;
                            aimTurnAngle = 0f;
                            aimingTurnedAngleY = 0f;
                            aimIKTurnDelayTimer = 0f;
                        }
                        else
                        {
                            // If required, decrement the turn delay timer.
                            if (aimIKTurnDelayTimer > 0f)
                            {
                                aimIKTurnDelayTimer -= dTime;

                                if (aimIKTurnDelayTimer <= 0f)
                                {
                                    aimIKTurnDelayTimer = 0f;
                                }
                            }

                            // Only start turning toward the target, when the held to aim animation
                            // has had time to complete.
                            if (aimIKTurnDelayTimer == 0f)
                            {
                                // If in Free Look mode, when going into aiming, attempt to turn
                                // the character to face where they were looking.
                                // See also EnableOrDisableAimIK(..).
                                if (isAimIKFromFreeLook || aimingFreeLookY != 0f)
                                {
                                    aimingFreeLookYTimer += dTime;

                                    if (aimingFreeLookDuration > 0f)
                                    {
                                        // Clamp to avoid overshooting the horizontal turn angle
                                        if (aimingFreeLookYTimer > aimingFreeLookDuration) { aimingFreeLookYTimer = aimingFreeLookDuration; }

                                        // Lerp toward aimingFreeLookY based on % FreeLook turn duration
                                        float targetAngleLS = Mathf.LerpAngle(0f, aimingFreeLookY, aimingFreeLookYTimer / aimingFreeLookDuration);

                                        // How much do we need to turn in this frame?
                                        aimTurnAngle = targetAngleLS - aimingFreeLookHasTurned;
                                    }
                                    else
                                    {
                                        // Cater for scenario where this is an instant turn or aimingFreeLookY is 0.
                                        aimTurnAngle = aimingFreeLookY;
                                    }

                                    // Keep track of how much we've turned since transition to aiming began
                                    aimingFreeLookHasTurned += aimTurnAngle;
                                }
                                // Third person without FreeLook
                                else if (isThirdPerson)
                                {
                                    aimTurnAngle = 0f;
                                }
                                else
                                {
                                    aimTurnAngle = AimAtTargetHorizontalAngle();
                                }

                                currentLocalAngularVelocity.y = aimTurnAngle;

                                // Should Smooth Enable be disabled?
                                if (aimTurnAngle > -0.01f && aimTurnAngle < 0.01f)
                                {
                                    isAimIKSmoothEnable = false;
                                    aimingTurnedAngleY = 0f;
                                    aimIKTurnDelayTimer = 0f;
                                }

                                aimTurnAngle = 0f;

                                // keep track of how much the character has turned since the last camera movement
                                localTurnedY += currentLocalAngularVelocity.y;
                            }
                        }

                        // Has smooth aim enable finished and do we need to fire off a post aim event?
                        if (!isAimIKSmoothEnable)
                        {
                            if (onPostStartAim != null)
                            {
                                // Assume right hand weapon aiming, if a weapon is held in right hand.
                                // Otherwise check left hand weapon.
                                onPostStartAim.Invoke(StickyID, isRightHandHoldingWeapon ? rightHandInteractiveId : (isLeftHandHoldingWeapon ? leftHandInteractiveId : 0), false, Vector3.zero);
                            }
                        }
                    }
                    else
                    {
                        // When aiming, rotating left-right rotates the whole character left-right.
                        currentLocalAngularVelocity.y = currentHorizontalLookInput * lookHorizontalSpeed;
                        aimingTurnedAngleY += currentLocalAngularVelocity.y;
                    }
                }
                #endregion

                #region isLockCamToWorldPos
                else if (isThirdPerson && isLockCamToWorldPos)
                {
                    // Allow rotation from player input or from external input like SampleMoveTo.cs.
                    currentLocalAngularVelocity.y = currentHorizontalLookInput * lookHorizontalSpeed;
                }
                #endregion

                #region FreeLook
                // Ignore NPCs with FreeLook. Force isLockCamToWorldPos to fall through to "Other with Movement" 
                else if (isFreeLook && !isNPC && !(isLockCamToWorldPos && isThirdPerson))
                {
                    // In Free Look mode, the camera position on the horizontal plane is determined
                    // by how many degrees the camera has rotated around the character. 

                    // Default to character not be rotating on the y-axis. Character is only rotated
                    // around y-axis when they are moving (otherwise, only the camera moves and/or rotates)
                    currentLocalAngularVelocity.y = 0f;

                    // First person camera is rotated in MoveFirstPersonCamera(..).
                    // The third person camera is moved in MoveThirdPersonCamera(..).
                    if (isUpdateLookMovement)
                    {
                        // Is the character moving forward/back or left/right
                        if (currentLocalVelocity.x != 0f || currentLocalVelocity.z != 0f)
                        {
                            // Project the camera direction onto the characters x-z plane
                            Vector3 camFwd = Vector3.ProjectOnPlane(currentLookRotation * Vector3.forward, Vector3.up);

                            // How much does the character have to change direction to match the camera (lerped over time)
                            camFwd = Vector3.RotateTowards(Vector3.forward, camFwd, turnRotationRate * dTime * Mathf.Deg2Rad, 0f);

                            // Calc just the y-axis local component
                            float localAngleAdjustmentY = Vector3.SignedAngle(Vector3.forward, camFwd, Vector3.up);

                            currentLocalAngularVelocity.y = localAngleAdjustmentY;

                            // keep track of how much the character has turned since the last camera movement
                            localTurnedY += localAngleAdjustmentY;

                            // Is the camera looking in a different direction to where the character is facing?
                            if (isThirdPerson && (orbitHorizontalAngle != 0f || orbitVerticalAngle != 0f))
                            {
                                // Currently smooth camera follow doesn't work with Free Look when character is moving
                                isSmoothCameraUpdate = false;
                            }
                        }
                    }
                }
                #endregion

                #region Other with movement
                // First person or Third person (without Free Look)
                // When position is locked, shouldn't be able to rotate the character
                // NPCs should still be directed to change direction with horizontal input.
                // Allow rotation when isLockCamToWorldPos from player input or from external input like SampleMoveTo.cs.
                else if ((isUpdateLookMovement || isNPC) && !isPositionLocked)
                {
                    // If the character has just picked up a weapon without FreeLook,
                    // decrement the timer.
                    if (heldTransitionTimer > 0f)
                    {
                        heldTransitionTimer -= dTime;

                        if (heldTransitionTimer < 0f) { heldTransitionTimer = 0f; }
                    }

                    // Currently, local angular velocity is just controlled by steering input
                    // This is calculated in the local space of the character
                    currentLocalAngularVelocity.y = currentHorizontalLookInput * lookHorizontalSpeed;
                }
                #endregion

                #region None of the above
                else
                {
                    // Added v1.0.9 to solve character continually rotating issue with SampleSitActionPopup
                    // when isFreeLook is OFF. Basically, it would keep using the previous value after
                    // LockPosition() was called.
                    currentLocalAngularVelocity.y = 0f;
                }
                #endregion
            }

            // Transform the local space angular velocity back into the provided reference frame
            currentRelativeAngularVelocity = currentRelativeRotation * currentLocalAngularVelocity;

            // Update current relative rotation based on the calculated current relative angular velocity
            currentRelativeRotation *= Quaternion.Euler(currentRelativeAngularVelocity);

            // Now, we need to rotate the character to match the ground direction of the reference frame
            // First, calculate the "target" rotation
            // Find the forwards direction of the character
            Vector3 relativeFwd = currentRelativeRotation * Vector3.forward;
            // Remove the y-component of the forwards direction so that the character stands perpendicular to the target up direction
            relativeFwd = Vector3.ProjectOnPlane(relativeFwd, currentRelativeTargetUp);
            // Calculate the new relative rotation using the projected forwards direction
            Quaternion targetRelativeRotation = Quaternion.LookRotation(relativeFwd, currentRelativeTargetUp);

            // Check if we have matched the target relative rotation
            float oldToTargetAngle = Quaternion.Angle(currentRelativeRotation, targetRelativeRotation) * Mathf.Deg2Rad;
            if (oldToTargetAngle > 0.001f && isMovementEnabled)
            {
                // Rotate towards the target relative rotation at a given speed
                currentRelativeRotation = Quaternion.RotateTowards(currentRelativeRotation, targetRelativeRotation, verticalRotationRate * dTime);
                if (isGrounded)
                {
                    // If the character was previously grounded, we need to shift the character upwards in order 
                    // to not have issues with clipping through the ground
                    float newToTargetAngle = Quaternion.Angle(currentRelativeRotation, targetRelativeRotation) * Mathf.Deg2Rad;

                    // ** DAVID ** - this could be a problem...
                    //if (newToTargetAngle == 90f) { Debug.LogWarning("ERROR: S3D Cos(90) = 0!! oldToTargetAngle: " + oldToTargetAngle + " newToTargetAngle: " + newToTargetAngle); }

                    float upwardsShiftAmount = ((height * 0.5f) - pivotToCentreOffsetY) * (1f - (Mathf.Cos(oldToTargetAngle) / Mathf.Cos(newToTargetAngle)));
                    // Shift the character upwards by the calculated amount and convert it into world space
                    currentRelativePosition += currentRelativeRotation * Vector3.up * upwardsShiftAmount;
                    currentWorldPosition = currentReferenceFramePosition + (currentReferenceFrameRotation * currentRelativePosition);
                }
            }

            // Convert current rotation into world space
            currentWorldRotation = currentReferenceFrameRotation * currentRelativeRotation;

            #endregion

            #region Move Character, set currentRelativeVelocity

            if (isMovementEnabled)
            {
                if (isLookVREnabled && isRoomScaleVR && isHeightCalibratedVR)
                {
                    // Only update position if height has been calibrated and initial position
                    // has been set.
                    //UpdatePositionFromHMD(isFixedUpdate ? Time.fixedDeltaTime : Time.deltaTime);
                }

                // Assign our new position and rotation
                MoveCharacter(isFixedUpdate);

                // Calculate current relative velocity and angular velocity based on how far we moved during this frame
                if (stepUpHeight > 0.001f)
                {
                    // When climbing steps we may need to calculate relative velocity differently
                    // We don't want to be launched upwards at a rapid rate.

                    //float _relVelo = currentRelativeVelocity.magnitude;

                    //Debug.Log("[DEBUG] Step relVelo " + (_relVelo < Vector3.kEpsilon ? "0.000" : _relVelo.ToString("0.000")));

                }
                else if (isRootMotion)
                {
                    // Not sure what we should do with root motion
                }
                else
                {
                    //currentRelativeVelocity = (currentRelativePosition - postDepenetrationRelativePosition) / dTime;
                    currentRelativeVelocity = (unadjustedRelativePosition - postDepenetrationRelativePosition) / dTime;
                    // TODO angular velocity
                }
            }

            #endregion

            #region Update Non-XR First Person Look
            if (isUpdateLookMovement && !isThirdPerson && !isLookVREnabled)
            {
                // NOTE: For XR camera we need to handle this separately
                // due to timing issues. See MoveXRCamera(..)
                if (isFixedUpdate && isLookFixedUpdate) { MoveFirstPersonCamera(isFixedUpdate); }
            }

            #endregion

            #region Jet Pack

            if (isJetPackAvailable)
            {
                // If the jet pack feature is available, toggle it's state
                // Only toggle jetpack once before StickyInputModule updates next.
                if (currentJetPackInput && !isInputProcessed) { EnableOrDisableJetPack(!isJetPackEnabled); }

                // If we are out of fuel, turn off the Jet Pack
                if (isJetPackEnabled && jetPackFuelLevel <= 0f) { EnableOrDisableJetPack(false); }
            }

            #endregion

            CheckIsStuck();

            #region Animate
            if (numAnimateActions > 0 && isAnimateEnabled) { AnimateCharacter(false); }

            if (isHandVR) { XRAnimateHand(); }
            #endregion

            // If we were jumping this frame, reset it now
            // Do not reset it before AnimateCharacter().
            if (currentJumpInput) { currentJumpInput = false; }

            #region FootSteps
            if (isFootStepsEnabled && isFootStepsAvailable)
            {
                if (isLanding) { PlayFootStep(); }
                if (isGrounded) { ProcessFootSteps(); }
            }

            #endregion

            #region Switch Look
            // Only switch once before StickyInputModule updates next.
            // This can happen if this method runs say in Fixed Update,
            // and that runs more than once before StickyInputModule updates again.
            if (currentSwitchLookInput && !isInputProcessed)
            {
                ToggleFirstThirdPerson();
            }

            #endregion

            isInputProcessed = true;
        }

        /// <summary>
        /// Move and rotate the character in 3D world space
        /// </summary>
        /// <param name="isFixedUpdate">Has been called from the Fixed Update loop</param>
        private void MoveCharacter(bool isFixedUpdate)
        {
            // If look VR is enabled, only update HMD and velo in Fixed or Update,
            // depending on MoveUpdateType. This avoids situation where fixed and update
            // time are the same (generally recommended for VR) and velo gets set to 0
            // because the second time it is called the HMD hasn't moved.
            if (isLookVREnabled && (isFixedUpdate || !isMoveFixedUpdate))
            {
                //UpdatePositionFromHMD(isFixedUpdate ? Time.fixedDeltaTime : Time.deltaTime);
            }

            if (isFixedUpdate)
            {
                rBody.MovePosition(currentWorldPosition);
                rBody.MoveRotation(currentWorldRotation);
            }
            else
            {
                transform.SetPositionAndRotation(currentWorldPosition, currentWorldRotation);
            }

            // NOTE: bodyPosition can only be updated from OnAnimatorIK() event
        }

        /// <summary>
        /// Get the local velocity required to move the character to the new position of the Head Mounted Device
        /// for roomscale VR.
        /// TODO - GetLocalVelocityFromHMD - take into consideration a moving platform or say space ship
        /// </summary>
        /// <returns></returns>
        private Vector3 GetLocalVelocityFromHMD()
        {
            Vector3 _localVelo = Vector3.zero;
            Vector3 _movedFromStartingPos = GetHMDMoveFromOriginWS();
            Vector3 _targetPositionWS = initialCameraPositionVR + _movedFromStartingPos;
            _targetPositionWS.y = currentWorldPosition.y;

            // Make sure we can fit in the new position
            // Before the character has moved CheckCapsule hits the floor which prevents the HMD from moving the character.
            // So, check slightly above the floor (this may still not work with a rotating platform so it may need more testing).
            if (!CheckCapsule(GetBottom(_targetPositionWS, currentCharacterUp, false, sweepTolerance), currentCharacterUp, currentScaledHeight))
            {
                _localVelo =  Quaternion.Inverse(currentWorldRotation) * (_targetPositionWS - currentWorldPosition);
            }

            return _localVelo;
        }


        /// <summary>
        /// Update the currentWorldPosition and currentRelativePosition based on the changing position
        /// of the VR head-mounted device. It does not actually move the character.
        /// ** IMPORTANT ** This can fail if the new position is (slightly) below the floor.
        /// We may need to develop a different technique for determining the new position.
        /// </summary>
        private void UpdatePositionFromHMD(float dTime)
        {
            bool isUpdatePosition = false;

            Vector3 _targetPositionWS = Vector3.zero;
            Vector3 _deltaMoveXZ = isRoomScaleVR ? GetHMDMoveDeltaLS() : GetHMDMoveDeltaWS();

            if (isRoomScaleVR)
            {
                Vector3 _movedFromStartingPos = GetHMDMoveFromOriginWS();
                _targetPositionWS = initialCameraPositionVR + _movedFromStartingPos;
                _targetPositionWS.y = currentWorldPosition.y;

                // When in room scale, we always want to update the position
                isUpdatePosition = true;
            }
            else
            {
                // When in "stationary" mode, only move the character position when HMD has moved
                // since last checked.
                if (_deltaMoveXZ.x != 0f || _deltaMoveXZ.z != 0f)
                {
                    _targetPositionWS = currentWorldPosition + (currentWorldRotation * _deltaMoveXZ);
                    isUpdatePosition = true;
                }
            }

            if (isUpdatePosition)
            {
                // Make sure we can fit in the new position
                // Before the character has moved CheckCapsule hits the floor which prevents the HMD from moving the character.
                // So, check slightly above the floor (this may still not work with a rotating platform so it may need more testing).
                if (!CheckCapsule(GetBottom(_targetPositionWS, currentCharacterUp, false, sweepTolerance), currentCharacterUp, currentScaledHeight))
                {
                    currentWorldPosition = _targetPositionWS;

                    // Update local velo so that animations work correctly
                    // Convert into metres per second
                    currentLocalVelocity += _deltaMoveXZ / (dTime > 0f ? dTime : 0.02f);

                    // Convert current position into the provided reference frame
                    currentRelativePosition = Quaternion.Inverse(currentReferenceFrameRotation) * (currentWorldPosition - currentReferenceFramePosition);
                }
            }
        }

        /// <summary>
        /// Updates the position of the transform in an Update statement. Only called when we are in fixed update move mode. This
        /// is used to make sure that the visual position of the character doesn't lag one frame behind the position of the
        /// reference frame.
        /// </summary>
        private void UpdateTransformPosition()
        {
            // Get information from reference frame
            if (currentReferenceFrame != null)
            {
                // Get reference frame position and rotation
                currentReferenceFrameRotation = currentReferenceFrameRotationMultiplier * currentReferenceFrame.rotation;
                currentReferenceFramePosition = currentReferenceFrame.position;
                currentReferenceFrameUp = currentReferenceFrame.up;
            }
            else
            {
                // If reference frame is null assume a "zero" reference frame
                currentReferenceFramePosition = Vector3.zero;
                currentReferenceFrameRotation = Quaternion.identity;
                currentReferenceFrameUp = Vector3.up;
            }

            // We retain the relative position and rotation from the last frame
            // Convert current position and rotation into world space
            currentWorldPosition = currentReferenceFramePosition + (currentReferenceFrameRotation * currentRelativePosition);
            currentWorldRotation = currentReferenceFrameRotation * currentRelativeRotation;
            // Assign our new position and rotation to the transform
            MoveCharacter(false);
        }

        #endregion

        #region Move Camera Methods

        /// <summary>
        /// If the relative head bone position changes, the first person camera will move relative to it.
        /// </summary>
        private void LookCameraFollowHead()
        {
            Vector3 _headOffset = Vector3.zero;

            // When aiming in first person, the neck or head bones could be pitching up or down, so
            // we also need to consider the rotation of the head bone.
            if (!isThirdPerson && (isAimAtTargetEnabled || isRightHandHoldingWeapon || IsLeftHandHoldingWeapon))
            {
                if (defaultAnimator != null && defaultAnimator.isHuman)
                {
                    Transform _head = defaultAnimator.GetBoneTransform(HumanBodyBones.Head);

                    if (_head != null)
                    {
                        // Apply the original local space offset between the head and the camera, to the current head position.
                        lookTransform.position = _head.position + (_head.rotation * (initialLookCamOffset - initialLookHeadOffset));
                    }
                }
            }
            // This works in FixedUpdate(), but not LateUpdate()
            else if (GetBoneBottomOffset(HumanBodyBones.Head, ref _headOffset))
            {
                // Get the difference between the current head position and the original head position.
                // Add that to the initial camera position.
                lookTransform.localPosition = _headOffset - initialLookHeadOffset + initialLookCamOffset;
            }
        }

        /// <summary>
        /// If the relative head bone position changes, the third person camera will move relative to it.
        /// </summary>
        private void LookCameraFollowHeadTP(ref Vector3 cameraOffsetLS)
        {
            Vector3 _headOffset = Vector3.zero;

            if (isThirdPerson && defaultAnimator != null && defaultAnimator.isHuman)
            {
                Transform _head = defaultAnimator.GetBoneTransform(HumanBodyBones.Head);

                if (_head != null)
                {
                    // DAVID - Almost correct but... comment out this line to see default behaviour
                    // and lookCameraOffset offset. You can see this better in scene view at runtime.
                    // On a humanoid, lookCameraOffset are initialLookHeadOffsetTP offset from the feet and ara in local space.
                    cameraOffsetLS = GetLocalPosition(_head.position + (_head.rotation * (lookCameraOffset - initialLookHeadOffsetTP)));


                    //cameraOffsetLS = GetLocalPosition(lookTransform.position + (_head.rotation * (lookCameraOffset - initialLookHeadOffsetTP)));

                    //_headOffset = GetLocalOffsetFromBottom(currentWorldPosition, _head.position);
                    //cameraOffsetLS = _headOffset - initialLookHeadOffsetTP + lookCameraOffset;
                }
            }
        }

        /// <summary>
        /// Move (rotate) first person camera
        /// </summary>
        /// <param name="isFixedUpdate"></param>
        private void MoveFirstPersonCamera(bool isFixedUpdate)
        {
            // If character movement is disabled, but look is enabled, update first person rotation
            // unless position is locked
            if (!isMovementEnabled && !isPositionLocked)
            {
                if (isFixedUpdate) { rBody.MoveRotation(currentWorldRotation); }
                else { transform.rotation = currentWorldRotation; }
            }

            float dTime = isFixedUpdate ? Time.fixedDeltaTime : Time.deltaTime;

            // Update the pitch rotation of the look transform
            if (isAimAtTargetEnabled && aimingFreeLookX != 0f)
            {
                aimingFreeLookXTimer += isFixedUpdate ? Time.fixedDeltaTime : Time.deltaTime;

                // Clamp to avoid overshooting the pitch angle. Check if this is an instant pitch adjustment.
                if (aimingFreeLookXTimer >= aimingFreeLookDuration || aimingFreeLookDuration == 0f)
                {
                    currentLookRotEulerAngles.x = aimingFreeLookX;
                    aimingFreeLookX = 0f;
                    aimingFreeLookXTimer = 0f;
                }
                else
                {
                    // Lerp toward aimingFreeLookX based on % FreeLook turn duration
                    currentLookRotEulerAngles.x = Mathf.LerpAngle(aimingFreeLookXStart, aimingFreeLookX, aimingFreeLookXTimer / aimingFreeLookDuration);
                }
            }
            else
            {
                // Subtraction is used to invert the direction
                currentLookRotEulerAngles.x -= currentVerticalLookInput * lookVerticalSpeed;
            }

            // Apply pitch limits
            if (currentLookRotEulerAngles.x < -lookPitchUpLimit) { currentLookRotEulerAngles.x = -lookPitchUpLimit; }
            else if (currentLookRotEulerAngles.x > lookPitchDownLimit) { currentLookRotEulerAngles.x = lookPitchDownLimit; }

            // When AimIK is enabled
            if (isAimAtTargetEnabled)
            {
                currentLookRotEulerAngles.y = 0f;

                // PHASE 1: Aiming has just began and we are turning the character toward the target
                if (localTurnedY != 0f)
                {
                    // Reset difference between cam and character forward directions
                    localTurnedY = 0f;
                }
                // PHASE 2: Weapon is aiming at the target (done in PHASE 1)
                else if (!isAimIKSmoothEnable)
                {
                    // In 1.1.0 Beta 25+ no need to do anything special here.
                }

                // Apply pitch aim limits (which might be more restrictive than look pitch limits)
                if (currentLookRotEulerAngles.x < -aimIKUpLimit) { currentLookRotEulerAngles.x = -aimIKUpLimit; }
                else if (currentLookRotEulerAngles.x > aimIKDownLimit) { currentLookRotEulerAngles.x = aimIKDownLimit; }

                #region OLD FPS AIMING TO DELETE
                #if false
                // PHASE 1: Aiming has just began and we are turning the character toward the target
                if (localTurnedY != 0f)
                {
                    currentLookRotEulerAngles.y = 0f;

                    // Reset difference between cam and character forward directions
                    localTurnedY = 0f;
                }
                // PHASE 2: Weapon is aiming at the target (done in PHASE 1) and
                // now adjust the camera to look where the weapon is aiming.
                else if (!isAimIKSmoothEnable)
                {
                    // Calc angle between where the weapon is pointing and where the camera is pointing
                    Vector3 aimTargetLS = GetLocalPosition(weaponAimPos);
                    Vector3 aimFromLS = GetLocalPosition(lookTransform.position);
                    Vector3 aimDirLS = S3DMath.Normalise(aimFromLS, aimTargetLS);

                    // Project the camera current direction onto the characters x-z plane
                    Vector3 camFwdHorz = Vector3.ProjectOnPlane(currentLookRotation * Vector3.forward, Vector3.up);

                    // Project the camera target direction onto the characters x-z plane
                    Vector3 camTargetFwdHorz = Vector3.ProjectOnPlane(aimDirLS, Vector3.up);

                    /// TODO - When adjusting horizontal camera while aiming, if the angle is great, this is MUCH too slow. e.g. Jody character
                    /// When the camera angle is small this is pretty smooth. e.g. Bob character
                    // How much does the camera have to change direction to look at the weapon target (lerped over time)?
                    camTargetFwdHorz = Vector3.RotateTowards(camFwdHorz, camTargetFwdHorz, lookHorizontalSpeed * dTime * Mathf.Deg2Rad, 0f);

                    // Calc just the y-axis (horzontal left-right) local component
                    // Rotating whole chararcter left-right happens in UpdateController(..).
                    currentLookRotEulerAngles.y = Vector3.SignedAngle(Vector3.forward, camTargetFwdHorz, Vector3.up);

                    // v1.1.0 Beta 24b+ TESTING with weapon parented to camera
                    currentLookRotEulerAngles.y = 0f;
                }

                // Apply pitch aim limits (which might be more restrictive than look pitch limits)
                if (currentLookRotEulerAngles.x < -aimIKUpLimit) { currentLookRotEulerAngles.x = -aimIKUpLimit; }
                else if (currentLookRotEulerAngles.x > aimIKDownLimit) { currentLookRotEulerAngles.x = aimIKDownLimit; }

                // Apply left/right limits
                if (currentLookRotEulerAngles.y < -80f) { currentLookRotEulerAngles.y = -80f; }
                else if (currentLookRotEulerAngles.y > 80f) { currentLookRotEulerAngles.y = 80f; }
                #endif
                #endregion
            }
            else if (isFreeLook)
            {
                currentLookRotEulerAngles.y += (currentHorizontalLookInput * lookHorizontalSpeed) - localTurnedY;

                // Reset difference between cam and character forward directions
                localTurnedY = 0f;

                // Apply left/right limits
                if (currentLookRotEulerAngles.y < -80f) { currentLookRotEulerAngles.y = -80f; }
                else if (currentLookRotEulerAngles.y > 80f) { currentLookRotEulerAngles.y = 80f; }
            }

            // If the relative head bone position changes, the first person camera will move relative to it.
            // If run in LateUpdate(), it needs to run after bones are rotated when aiming with a weapon.
            // See LateUpdate().
            if (isLookCameraFollowHead && isFixedUpdate)
            {
                LookCameraFollowHead();
            }

            currentLookRotation = Quaternion.Euler(currentLookRotEulerAngles);

            // Apply the modified rotation to the transform
            lookTransform.localRotation = currentLookRotation;

            #region Zoom

            // NOTE: Zoom is disabled when aiming
            if (!isAimAtTargetEnabled && (currentZoomLookInput != 0f || zoomFactor != 0f))
            {
                CalcZoomFactor();

                if (zoomFactor <= 0f)
                {
                    lookCamera1.fieldOfView = lookUnzoomedFoV;
                }
                else
                {
                    lookCamera1.fieldOfView = lookUnzoomedFoV - (zoomFactor * (lookUnzoomedFoV - lookZoomedFoV));
                }
            }

            #endregion
        }

        /// <summary>
        /// Move the third person camera in the scene.
        /// When you want to cut directly to a new camera position, set smoothMovement to false
        /// Revised in v1.0.1 to use local space rather than world space calculations.
        /// </summary>
        private void MoveThirdPersonCamera(bool isFixedUpdate, bool smoothMovement = true)
        {
            if (!isUpdateLookMovement) { return; }

            float dTime = isFixedUpdate ? Time.fixedDeltaTime : Time.deltaTime;

            // Convert current camera position, previous optimal camera position and optimal camera position 
            // into the provided reference frame
            //currentCameraPosition = Quaternion.Inverse(currentReferenceFrameRotation) * (currentCameraPosition - currentReferenceFramePosition);
            //previousOptimalCameraPosition = Quaternion.Inverse(currentReferenceFrameRotation) * (previousOptimalCameraPosition - currentReferenceFramePosition);
            //optimalCameraPosition = Quaternion.Inverse(currentReferenceFrameRotation) * (optimalCameraPosition - currentReferenceFramePosition);

            // Convert current camera position, previous optimal camera position and optimal camera position
            // back into world space
            //currentCameraPosition = currentReferenceFramePosition + (currentReferenceFrameRotation * currentCameraPosition);
            //previousOptimalCameraPosition = currentReferenceFramePosition + (currentReferenceFrameRotation * previousOptimalCameraPosition);
            //optimalCameraPosition = currentReferenceFramePosition + (currentReferenceFrameRotation * optimalCameraPosition);

            // Include a local focal point offset from the character position
            //SetFocusPosition(ref currentFocusPosition);

            bool isAdjustHUDReticle = false;

            // Is a weapon being held, not aiming, without FreeLook?
            bool isHeldWeapon = isRightHandHoldingWeapon || isLeftHandHoldingWeapon;
            bool isHeldWeaponNoFreeLook = !isFreeLook && !isAimAtTargetEnabled && isHeldWeapon;

            #region Optimal Camera Position
            // Local space offset from character.
            if (isAimAtTargetEnabled)
            {
                optimalCameraPosition = aimIKCameraOffsetTPS;

                if (isLookCameraFollowHeadTP)
                {
                    LookCameraFollowHeadTP(ref optimalCameraPosition);                    
                }
            }

            /// TODO - consider if isLockCamToWorldPos AND isLockCamToWorldRot is enabled

            /// TODO - Complete implementation of Lock Cam To World Rot
            else if (isLockCamToWorldRot)
            {
                /// TODO - add on the relative rotation 
                // currentCameraRefFrameRot;

                // Assume character is facing in the same direction as ref frame, and apply localCameraOffset.
                Vector3 _wsPos = currentWorldPosition + (currentReferenceFrameRotation * lookCameraOffset);
                optimalCameraPosition = GetLocalPosition(_wsPos);

                //DebugExtension.DebugWireSphere(_wsPos, 0.1f);

            }
            else if (isLockCamToWorldPos)
            {
                // Attempt to prevent the camera moving, relative to the reference frame.
                Vector3 _wsPos = currentReferenceFramePosition + (currentReferenceFrameRotation * currentCameraRefFrameOffset);
                optimalCameraPosition = GetLocalPosition(_wsPos);
            }
            else
            {
                optimalCameraPosition = lookCameraOffset;

                /// TODO - For this to work, we need to enable and disable
                /// it in all the correct places.
                /// When a weapon is first held, Follow Head TP is enabled
                /// See SetHoldingInteractive(..)
                //if (isHeldWeaponNoFreeLook && isLookCameraFollowHeadTP && heldTransitionTimer == 0f)
                if (isLookCameraFollowHeadTP && (!isHeldWeapon || (isHeldWeaponNoFreeLook && heldTransitionTimer == 0f)))
                {
                    LookCameraFollowHeadTP(ref optimalCameraPosition);
                }
            }

            #endregion

            #region Calculate Aiming
            if (isAimAtTargetEnabled)
            {
                // PHASE 1: Aiming has just began and we are turning the character toward the target
                if (localTurnedY != 0f)
                {
                    orbitHorizontalAngle = 0f;

                    // Reset difference between cam and character forward directions
                    localTurnedY = 0f;

                    // At the end of phase 1, ensure the prev Camera Aim Target is where the weapon is pointing.
                    prevCameraAimTarget = weaponAimPos;
                }
                else
                {
                    // PHASE 2: Weapon is aiming at the target (done in PHASE 1) and
                    // now adjust the camera to look where the weapon is aiming.
                    if (!isAimIKSmoothEnable && false)
                    {
                        // Calc angle between where the weapon is pointing and where the camera is pointing
                        Vector3 aimTargetLS = GetLocalPosition(weaponAimPos);
                        Vector3 aimFromLS = GetLocalPosition(lookTransform.position);
                        Vector3 aimDirLS = S3DMath.Normalise(aimFromLS, aimTargetLS);

                        // Project the camera current direction onto the characters x-z plane
                        Vector3 camFwdHorz = Vector3.ProjectOnPlane(currentLookRotation * Vector3.forward, Vector3.up);

                        // Project the camera target direction onto the characters x-z plane
                        Vector3 camTargetFwdHorz = Vector3.ProjectOnPlane(aimDirLS, Vector3.up);

                        // How much does the camera have to change direction to look at the weapon target (lerped over time)?
                        //camTargetFwdHorz = Vector3.RotateTowards(camFwdHorz, camTargetFwdHorz, lookHorizontalSpeed * dTime * Mathf.Deg2Rad, 0f);

                        // Calc just the y-axis (horzontal left-right) local component
                        orbitHorizontalAngle = Vector3.SignedAngle(Vector3.forward, camTargetFwdHorz, Vector3.up);

                        if (orbitHorizontalAngle >= 360f) { orbitHorizontalAngle -= 360f; }
                        else if (orbitHorizontalAngle <= -360f) { orbitHorizontalAngle += 360f; }
                    }

                    #region Previous David Aiming Code

                    // This would theoretically replace the above code I think
                    if (!isAimIKSmoothEnable)
                    {
                        // New code - 22/09/22
                        // Currently this gets an error, and I don't know why

                        // Not sure if we need this
                        //currentCameraPosition = lookTransform.position;

                        // Horizontal camera rotation

                        // First, get the distances from the character to the aim target and the camera
                        float characterToCameraDistance = Mathf.Sqrt(currentCameraPosition.x * currentCameraPosition.x + currentCameraPosition.z * currentCameraPosition.z);
                        Vector3 characterToAimTarget = GetLocalPosition(prevCameraAimTarget - currentWorldPosition);

                        //DebugExtension.DebugWireSphere(lastCameraAimTarget, Color.yellow, 0.02f);
                       
                        float characterToAimTargetDistance = Mathf.Sqrt(characterToAimTarget.x * characterToAimTarget.x + characterToAimTarget.z * characterToAimTarget.z);
                        // Calculate the angle between the direction to the aim target and the camera offset
                        float aimTargetToCameraOffsetAngle = Vector3.SignedAngle(characterToAimTarget, currentCameraPosition, Vector3.up);
                        // Next, find the new distance from the camera to the aim target (after we have completed the rotation)
                        float newCameraToAimTargetDistance = Mathf.Sqrt(characterToAimTargetDistance * characterToAimTargetDistance + characterToCameraDistance * characterToCameraDistance -
                            2f * characterToAimTargetDistance * characterToCameraDistance * Mathf.Cos(aimTargetToCameraOffsetAngle * Mathf.Deg2Rad));

                        // Avoid NaN
                        if (prevCameraToAimTargetDistance < characterToAimTargetDistance)
                        {
                            prevCameraToAimTargetDistance = characterToAimTargetDistance;
                        }

                        // Now, calculate how much we need to rotate the camera back (based on how much the camera was rotated
                        // in the frames preceding this one)
                        float cameraHorzRotation = (Mathf.Asin(characterToAimTargetDistance / newCameraToAimTargetDistance * Mathf.Sin(aimTargetToCameraOffsetAngle * Mathf.Deg2Rad)) -
                            Mathf.Asin(characterToAimTargetDistance / prevCameraToAimTargetDistance * Mathf.Sin((aimTargetToCameraOffsetAngle - aimingTurnedAngleY) * Mathf.Deg2Rad) ) ) * Mathf.Rad2Deg;

                        //Debug.Log("[DEBUG] cameraHorzRotation " + cameraHorzRotation + " aimingTurnedAngleY: " + aimingTurnedAngleY);

                        //orbitHorizontalAngle = cameraHorzRotation;
                        // DISABLE FOR TESTING PITCH ONLY
                        orbitHorizontalAngle = 0f;

                        if (orbitHorizontalAngle >= 360f) { orbitHorizontalAngle -= 360f; }
                        else if (orbitHorizontalAngle <= -360f) { orbitHorizontalAngle += 360f; }

                        // Reset variables for use in the next frame
                        prevCameraAimTarget = weaponAimPos;
                        prevCameraToAimTargetDistance = newCameraToAimTargetDistance;
                        aimingTurnedAngleY = 0f;

                        // After the camera has moved and rotated, attempt to set the
                        // HUD reticle (if any) to where the weapon is aiming.
                        isAdjustHUDReticle = true;

                        // 1.1.0 Beta 25j+ (keep reticle locked in centre of screen)
                        isAdjustHUDReticle = false;

                        //currentFocusPosition = lookCameraOffset + (Vector3.forward * 100f);
                    }

                    // TEST CODE - WRONG BUT WORKS DECENTLY
                    if (!isAimIKSmoothEnable && false)
                    {
                        
                        orbitHorizontalAngle = 0f;

                        // Temp do nothing
                        //orbitVerticalAngle = 0f;
                    }

                    #endregion

                    // Pitch up will be +ve values
                    orbitVerticalAngle -= currentVerticalLookInput * lookVerticalSpeed;

                    if (orbitVerticalAngle < -lookPitchUpLimit) { orbitVerticalAngle = -lookPitchUpLimit; }
                    else if (orbitVerticalAngle > lookPitchDownLimit) { orbitVerticalAngle = lookPitchDownLimit; }

                    // Apply pitch aim limits (which might be more restrictive than orbit angle limits)
                    if (orbitVerticalAngle < -aimIKUpLimit) { orbitVerticalAngle = -aimIKUpLimit; }
                    else if (orbitVerticalAngle > aimIKDownLimit) { orbitVerticalAngle = aimIKDownLimit; }

                    //Debug.Log("[DEBUG] Third Person aiming pitch: " + orbitVerticalAngle + " T:" + Time.time);

                    // Get the new character local space rotation of the camera
                    // Apply vert before horizontal, else will get glitches which camera jumping up/down between some frames
                    currentLookRotation = Quaternion.AngleAxis(orbitVerticalAngle, Vector3.right) * Quaternion.AngleAxis(orbitHorizontalAngle, Vector3.up);

                    // When aiming (for now) don't change the position based on pitch
                    // When aiming we want the camera to stay in the same local space x-z plane as character
                    // and just pitch up and down ralative to the x-axis.
                    //optimalCameraPosition = currentLookRotation * optimalCameraPosition;
                }
            }
            #endregion

            #region Aim IK smooth disable
            else if (isAimIKSmoothDisable)
            {
                // Let the camera smoothly revert to the third person offset.
                if ((currentCameraPosition - optimalCameraPosition).sqrMagnitude < Vector3.kEpsilon)
                {
                    isAimIKSmoothDisable = false;

                    if (onPostStopAim != null)
                    {
                        // Assume right hand weapon aiming, if a weapon is held in right hand.
                        // Otherwise check left hand weapon.
                        onPostStopAim.Invoke(StickyID, isRightHandHoldingWeapon ? rightHandInteractiveId : (isLeftHandHoldingWeapon ? leftHandInteractiveId : 0), false, Vector3.zero);
                    }
                }
            }
            #endregion

            #region Holding Weapon (not aiming) without Free Look
            else if (isHeldWeaponNoFreeLook)
            {
                if (heldTransitionTimer == 0f)
                {
                    // Pitch up will be +ve values
                    orbitVerticalAngle -= currentVerticalLookInput * lookVerticalSpeed;
                }

                if (orbitVerticalAngle < -lookPitchUpLimit) { orbitVerticalAngle = -lookPitchUpLimit; }
                else if (orbitVerticalAngle > lookPitchDownLimit) { orbitVerticalAngle = lookPitchDownLimit; }

                // Apply pitch aim limits (which might be more restrictive than orbit angle limits)
                if (orbitVerticalAngle < -aimIKUpLimit) { orbitVerticalAngle = -aimIKUpLimit; }
                else if (orbitVerticalAngle > aimIKDownLimit) { orbitVerticalAngle = aimIKDownLimit; }

                currentLookRotation = Quaternion.AngleAxis(orbitVerticalAngle, Vector3.right);
            }
            #endregion

            #region Calc FreeLook
            else if (isThirdPerson && isFreeLook && !isLockCamToWorldPos && !isLockCamToWorldRot)
            {
                if (localTurnedY != 0f)
                {
                    orbitHorizontalAngle -= localTurnedY;

                    // If the orbit angle and the character turn angle are almost the same, assume they are the same.
                    if (orbitHorizontalAngle > -0.0001f && orbitHorizontalAngle < 0.0001f) { orbitHorizontalAngle = 0f; }
                }

                // Update camera orbit for horizontal look movement
                orbitHorizontalAngle += currentHorizontalLookInput * lookHorizontalSpeed;

                if (orbitHorizontalAngle >= 360f) { orbitHorizontalAngle -= 360f; }
                else if (orbitHorizontalAngle <= -360f) { orbitHorizontalAngle += 360f; }

                // Pitch up will be +ve values
                orbitVerticalAngle -= currentVerticalLookInput * lookVerticalSpeed;

                if (orbitVerticalAngle < -lookPitchUpLimit) { orbitVerticalAngle = -lookPitchUpLimit; }
                else if (orbitVerticalAngle > lookPitchDownLimit) { orbitVerticalAngle = lookPitchDownLimit; }

                // Get the new character local space rotation of the camera
                // Apply vert before horizontal, else will get glitches which camera jumping up/down between some frames
                currentLookRotation = Quaternion.AngleAxis(orbitVerticalAngle, Vector3.right) * Quaternion.AngleAxis(orbitHorizontalAngle, Vector3.up);

                // Reset difference between cam and character forward directions
                localTurnedY = 0f;

                // The orbit angle for Free Look mode is calculated in UpdateController(..).
                if (orbitHorizontalAngle != 0f)
                {
                    // local space
                    optimalCameraPosition = currentLookRotation * optimalCameraPosition;
                }
            }
            #endregion

            #region Calc Orbit
            else if (!isLockCamToWorldPos && (currentOrbitLookInput != 0f || orbitHorizontalAngle != 0f))
            {
                // Is the user attempting to manually orbit the camera?
                if (currentOrbitLookInput != 0f)
                {
                    // Clockwise are -ve input
                    orbitHorizontalAngle -= 360f * currentOrbitLookInput * dTime / orbitDuration;

                    if (orbitHorizontalAngle > lookOrbitMaxAngle) { orbitHorizontalAngle = lookOrbitMaxAngle; }
                    else if (orbitHorizontalAngle < lookOrbitMinAngle) { orbitHorizontalAngle = lookOrbitMinAngle; }

                    if (orbitHorizontalAngle >= 360f) { orbitHorizontalAngle -= 360f; }
                    else if (orbitHorizontalAngle <= -360f) { orbitHorizontalAngle += 360f; }

                    unorbitTimer = lookUnorbitDelay;
                }
                else if (unorbitTimer <= 0f)
                {
                    // +ve orbit, start reducing orbit towards no orbit
                    if (orbitHorizontalAngle > 0f)
                    {
                        // If it has almost returned to 0, stop orbiting
                        if (orbitHorizontalAngle < Vector3.kEpsilon) { orbitHorizontalAngle = 0f; }
                        else
                        {
                            orbitHorizontalAngle -= 360f * dTime / orbitDuration;
                            if (orbitHorizontalAngle < 0f) { orbitHorizontalAngle = 0f; }
                        }
                    }
                    // -ve orbit, start increasing orbit towards no orbit
                    else
                    {
                        // If it has almost returned to 0, stop orbiting
                        if (-orbitHorizontalAngle < Vector3.kEpsilon) { orbitHorizontalAngle = 0f; }
                        else
                        {
                            orbitHorizontalAngle += 360f * dTime / orbitDuration;
                            if (orbitHorizontalAngle > 0f) { orbitHorizontalAngle = 0f; }
                        }
                    }
                }
                else
                {
                    unorbitTimer -= dTime;
                    if (unorbitTimer < 0f) { unorbitTimer = 0f; }
                }

                // Is the camera orbiting?
                // Change Camera orbit position here
                if (orbitHorizontalAngle != 0f)
                {
                    // local space
                    optimalCameraPosition = Quaternion.AngleAxis(orbitHorizontalAngle, Vector3.up) * optimalCameraPosition;
                }
            }

            #endregion

            // Include a local focal point offset from the character position
            // When TP Follow Head is enabled, this depends on the optimal local space camera position
            SetFocusPosition(ref currentFocusPosition);

            #region Optimal Camera Direction and Rotation

            // local space camera aim direction and rotation
            // For LockCamToWorldRot, add the offset rotation to the ref frame WS rotation, get the direction, then convert that direction into local space.
            Vector3 cameraAimDirection = isLockCamToWorldRot ? GetLocalDirection((currentReferenceFrameRotation * currentCameraRefFrameRot) * Vector3.forward) : (isAimAtTargetEnabled || isHeldWeaponNoFreeLook) && !isAimIKSmoothEnable ? currentLookRotation * Vector3.forward : S3DMath.Normalise(optimalCameraPosition, currentFocusPosition);
            optimalCameraRotation = (isAimAtTargetEnabled || isHeldWeaponNoFreeLook) && !isAimIKSmoothEnable ? currentLookRotation : Quaternion.LookRotation(cameraAimDirection, Vector3.up);

            #endregion

            #region Calculate Zoom

            // NOTE: Zoom is disabled when aiming
            if (!isAimAtTargetEnabled && (currentZoomLookInput != 0f || zoomFactor != 0f))
            {
                CalcZoomFactor();

                // Are we zooming?
                if (zoomFactor != 0f)
                {
                    // calculate zoom distance - which cannot be closer than twice the radius + the camera near clip plane
                    // Negative zoom pushes the camera further away - which isn't affected by the character radius.
                    float zoomDistance = lookCameraOffsetDistance * zoomFactor * (zoomFactor < 0f ? lookZoomOutFactor : 1f);

                    // Clamp when zooming in (when zooming out the zoomDistance will be -ve)
                    float maxZoomInDistance = lookCameraOffsetDistance - (currentScaledRadius * 2f + lookCamera1.nearClipPlane);
                    zoomDistance = zoomDistance > maxZoomInDistance ? maxZoomInDistance : zoomDistance;

                    // Add the zoom distance
                    optimalCameraPosition += cameraAimDirection * zoomDistance;
                }
            }

            #endregion

            #region Object Clipping
            bool isClippingThisFrame = false;
            if (clipObjects) { isClippingThisFrame = ObjectClipping(currentFocusPosition, currentWorldRotation, ref optimalCameraPosition, ref optimalCameraRotation, ref previousClipHitDistance); }
            else { previousClipHitDistance = 0f; }
            #endregion

            #region Calculate and set Final Position and Rotation

            // Is camera still shaking?
            if (isShaking)
            {
                shakeTimer -= dTime;
                if (shakeTimer <= 0f) { StopCameraShake(); }
            }

            if (smoothMovement && !isLockCamToWorldPos)
            {
                optimalCameraPosition = SmoothFollowPosition(currentCameraPosition, previousOptimalCameraPosition, optimalCameraPosition, dTime, isClippingThisFrame && lookMoveSpeed < minClipMoveSpeed ? minClipMoveSpeed : lookMoveSpeed);
            }
            else if (isFixedUpdate)
            {
                // If we're cutting to the camera location and we're also in fixedUpdate, we have
                // to update the transform position before the next MoveThirdPersonCamera is called in FixedUpdate(),
                // otherwise SmoothFollowPosition thinks currentCameraPosition is still at the old location. 

                // NEW - prob don't need this any more as currentCameraPosition is being stored (we are no longer relying on the lookCamera transform position.
                //lookTransform.SetPositionAndRotation(currentWorldPosition + (currentWorldRotation * optimalCameraPosition), currentWorldRotation * optimalCameraRotation);
            }

            currentCameraPosition = optimalCameraPosition;

            //Debug.Log("[DEBUG] camera y: " + currentCameraPosition.y + " T:" + Time.time);

            // Convert from Local Space to World Space
            // Is camera shaking?
            if (isShaking)
            {
                currentCameraPosWS = GetWorldPosition(optimalCameraPosition + (Vector3)(Random.insideUnitCircle * shakeStrength));
            }
            else
            {
                currentCameraPosWS = GetWorldPosition(optimalCameraPosition);
            }
            currentCameraRotWS = GetWorldRotation(optimalCameraRotation);

            // Assign our new position and rotation
            if (isFixedUpdate)
            {
                rBodyCamera.MovePosition(currentCameraPosWS);
                rBodyCamera.MoveRotation(currentCameraRotWS);
            }
            else
            {
                lookTransform.SetPositionAndRotation(currentCameraPosWS, currentCameraRotWS);
            }

            #endregion

            #region Adjust HUD Reticle (for 3rd person aiming)

            // For some reason this is jittery...
            if (isAdjustHUDReticle && StickyDisplayModule.GetActiveDisplayModule() != null)
            {
                Vector2 viewPoint = lookCamera1.WorldToViewportPoint(weaponAimPos);

                // Convert 0.0 to 1.0 into -1.0 to 1.0.
                StickyDisplayModule.GetActiveDisplayModule().SetDisplayReticleOffset(viewPoint.x * 2f - 1f, viewPoint.y * 2f - 1f);
            }

            #endregion

            previousOptimalCameraPosition = optimalCameraPosition;
        }

        /// <summary>
        /// When lookVR is enabled, camera movement takes input from the XR HMD rotation. 
        /// This takes the HMD rotation and feeds it back into the S3D variables.
        /// In the default continuous turn, the character direction matches the HMD forward
        /// direction which is calculated in UpdateController(..) - so y-axis is always 0.
        /// When Snap Turn is enabled, the camera matches the forward direction on y-axis
        /// of the HMD.
        /// Pitch and Tilt always use the HMD x and z-axis values.
        /// </summary>
        private void MoveXRCamera(bool isFixedUpdate)
        {
            if (!isUpdateLookMovement) { return; }

            // If character movement is disabled, but look is enabled, update first person rotation
            // unless position is locked
            if (!isMovementEnabled && !isPositionLocked)
            {
                if (isFixedUpdate) { rBody.MoveRotation(currentWorldRotation); }
                else { transform.rotation = currentWorldRotation; }
            }

            if (isRoomScaleVR)
            {
                // Room Scale uses continuous move and turn, assuming HMD is stationary but can tilt and pitch.
                // For this we can use the world rotation of the HMD and just remove the y-axis component.
                currentLookRotEulerAngles = currentXRLookInput.eulerAngles;

                // The character is always facing in the direction the HMD is facing.
                // Character turning gets done in UpdateController(..).
                currentLookRotEulerAngles.y = 0f;
            }
            // Use Modify pitch and tilt of HMD, and calc y-axis rotation.
            else if (isSnapTurnVR)
            {
                // When Snap Turn is enabled, we still want to be able to look left and right without
                // changing the direction the character is facing.
                currentLookRotEulerAngles = currentXRLookInput.eulerAngles;

                // Project the Head Mounted Device camera direction onto the HMD x-z plane
                Vector3 camFwd = Vector3.ProjectOnPlane(currentXRLookInput * Vector3.forward, Vector3.up);

                // Calc just the y-axis local component
                currentLookRotEulerAngles.y = Vector3.SignedAngle(Vector3.forward, camFwd, Vector3.up);
            }
            else
            {
                // In continuous move and turn, assume HMD is stationary but can tilt and pitch.
                // For this we can use the world rotation of the HMD and just remove the y-axis component.
                currentLookRotEulerAngles = currentXRLookInput.eulerAngles;

                // Currently, in VR without snap turn, the character is always facing in the direction
                // the HMD is facing. This gets done in UpdateController(..).
                currentLookRotEulerAngles.y = 0f;
            }

            localTurnedY = 0f;

            currentLookRotation = Quaternion.Euler(currentLookRotEulerAngles);

            // Apply the modified rotation to the transform
            lookTransform.localRotation = currentLookRotation;

            #region Local Y Position of head-mounted device

            // Ensure we don't try to adjust the camera position before the floor offset and height
            // has been calibrated.
            if (isHeightCalibratedVR)
            {
                Vector3 _targetCameraPos = initialFirstPersonCameraOffsetVR;

                if (isMatchHumanHeightVR)
                {
                    _targetCameraPos.y = currentCharInputXR.hmdPosition.y;
                }
                else if (humanPostureVR == HumanPostureVR.Sitting)
                {
                    //_targetCameraPos.y += currentCharInputXR.hmdPosition.y - initialFirstPersonCameraOffsetVR.y;
                    _targetCameraPos.y = currentCharInputXR.hmdPosition.y - initialHMDCameraDelta.y;
                }
                // Assume HumanPostureVR.Standing
                else
                {
                    // Adjust the camera to the correct eye position
                    //_targetCameraPos.y += currentCharInputXR.hmdPosition.y - initialFirstPersonCameraOffsetVR.y;
                    _targetCameraPos.y = currentCharInputXR.hmdPosition.y - initialHMDCameraDelta.y;
                }

                lookTransform.localPosition = _targetCameraPos;
            }
            #endregion

            #region Zoom

            // This currently doens't work in VR because it uses FOV...
            if (currentZoomLookInput != 0f || zoomFactor != 0f)
            {
                CalcZoomFactor();

                if (zoomFactor <= 0f)
                {
                    lookCamera1.fieldOfView = lookUnzoomedFoV;
                }
                else
                {
                    lookCamera1.fieldOfView = lookUnzoomedFoV - (zoomFactor * (lookUnzoomedFoV - lookZoomedFoV));
                }
            }

            #endregion
        }

        /// <summary>
        /// Calculate the zoom factor based on zoom input and any unzoom delay.
        /// </summary>
        private void CalcZoomFactor()
        {
            // Is the user attempting to manually zoom in or out
            if (currentZoomLookInput != 0f)
            {
                zoomFactor += currentZoomLookInput * Time.deltaTime / zoomDuration;

                if (zoomFactor > 1f) { zoomFactor = 1f; }
                else if (!isThirdPerson) { if (zoomFactor < 0f) { zoomFactor = 0f; } }
                else if (zoomFactor < -1f) { zoomFactor = -1f; }

                unzoomTimer = lookUnzoomDelay;
            }
            else if (unzoomTimer <= 0f)
            {
                // +ve zoom, start reducing zoom towards no zoom
                if (zoomFactor > 0f)
                {
                    // If it has almost returned to 0, stop zooming
                    if (zoomFactor < Vector3.kEpsilon) { zoomFactor = 0f; }
                    else
                    {
                        zoomFactor -= Time.deltaTime / zoomDuration;
                        if (zoomFactor < 0f) { zoomFactor = 0f; }
                    }
                }
                // -ve zoom, start increasing zoom towards no zoom
                else
                {
                    // If it has almost returned to 0, stop zooming
                    if (-zoomFactor < Vector3.kEpsilon) { zoomFactor = 0f; }
                    else
                    {
                        zoomFactor += Time.deltaTime / zoomDuration;
                        if (zoomFactor > 0f) { zoomFactor = 0f; }
                    }
                }
            }
            else
            {
                unzoomTimer -= Time.deltaTime;
                if (unzoomTimer < 0f) { unzoomTimer = 0f; }
            }
        }

        #endregion

        #region Non-Update Events

        private void OnDestroy()
        {
            if (hposeHandler != null) { hposeHandler.Dispose(); }

            // Prevent any Invokes from trying to run after it is destroyed.
            // For example UnpauseWeaponsFiring(delay)
            CancelInvoke();
        }

        /// <summary>
        /// Called by Unity when an animator layer has "IK Pass" enabled.
        /// Marked "internal" so it can be called from S3DIKEnabler if required.
        /// If the animator Update Mode is Animate Physics, this will be called
        /// at the same rate as FixedUpdate, else it will be called at Update rate.
        /// </summary>
        /// <param name="layerIndex"></param>
        internal void OnAnimatorIK(int layerIndex)
        {
            if (isAnimateEnabled)
            {
                float dTime = Time.deltaTime;

                #region Head IK

                // Disable Head IK when Aim IK is enabled.
                if (isHeadIK && !isAimAtTargetEnabled && headIKAnimIKPassLayerIndex == layerIndex)
                {
                    if (isMovementEnabled || headIKWhenMovementDisabled)
                    {
                        // Having a headTargetTfrm will overwrite the targetHeadIKPos.
                        // See SetHeadIKTarget(..) variants.
                        if (headTargetTrfm != null)
                        {
                            targetHeadIKPos = headTargetTrfm.position;
                            // Add local space offset if required
                            if (targetHeadIKPosOffset.x != 0f) { targetHeadIKPos += headTargetTrfm.right * targetHeadIKPosOffset.x; }
                            if (targetHeadIKPosOffset.y != 0f) { targetHeadIKPos += headTargetTrfm.up * targetHeadIKPosOffset.y; }
                            if (targetHeadIKPosOffset.z != 0f) { targetHeadIKPos += headTargetTrfm.forward * targetHeadIKPosOffset.z; }
                        }

                        // Smoothly enable HeadIK by ramping up the overall weight
                        if (isHeadIKSmoothEnable)
                        {
                            currentMaxHeadIKWeight += headIKMoveMaxSpeed * Time.deltaTime;
                            if (currentMaxHeadIKWeight >= 1f)
                            {
                                currentMaxHeadIKWeight = 1f;
                                isHeadIKSmoothEnable = false;
                            }
                        }

                        HeadIKGetPosition(targetHeadIKPos, prevHeadIKPos, currentMaxHeadIKWeight, ref prevHeadIKAngles, ref currentHeadIKPos, ref currentHeadIKVelo, ref prevHeadIKDeltaVelo);

                        HeadIKSetPosition(currentHeadIKPos);

                        prevHeadIKPos = currentHeadIKPos;

                        // Start smooth disable after 1 more update. This means we don't need to check currentMaxHeadIKWeight every frame.
                        // Ramp down the overall weight over many frames.
                        if (isHeadIKSmoothDisable)
                        {
                            currentMaxHeadIKWeight -= headIKMoveMaxSpeed * dTime;
                            if (currentMaxHeadIKWeight <= 0f)
                            {
                                currentMaxHeadIKWeight = 0f;
                                isHeadIKSmoothDisable = false;
                                EnableOrDisableHeadIK(false, false, false);
                            }
                        }
                    }
                    else
                    {
                        // TODO - Needs testing
                        //HeadIKSetPosition(prevHeadIKPos);
                    }
                }

                #endregion

                #region Hand IK

                // Aim IK uses Hand Ik and the layer indicated in Aim IK.
                if (isHandIK && ((isAimAtTargetEnabled && aimIKAnimIKPassLayerIndex == layerIndex) || (!isAimAtTargetEnabled && handIKAnimIKPassLayerIndex == layerIndex)))
                {
                    if (isMovementEnabled || handIKWhenMovementDisabled)
                    {
                        // Smoothly enable HandIK by ramping up the overall weight
                        if (isHandIKSmoothEnable)
                        {
                            currentMaxHandIKWeight += handIKMoveMaxSpeed * Time.deltaTime;
                            if (currentMaxHandIKWeight >= 1f)
                            {
                                currentMaxHandIKWeight = 1f;
                                isHandIKSmoothEnable = false;
                            }
                        }

                        // First person aiming uses Hand IK (no smoothing) and pitch spine bones from OnAnimateIK
                        // When holding a weapon and FreeLook is false and NOT aiming, AimBonesFPS can run in LateUpdate.
                        if (!isThirdPerson && !isLookVREnabled && (isAimAtTargetEnabled || (!isFreeLook && (isAnimatorFixedUpdate || isLookFixedUpdate))))
                        {
                            currentMaxHandIKWeight = 1f;
                            AimBonesFPS(true);
                        }

                        // Update here if NOT (FPS aiming while crouching). Otherwise do it in LateUpdate()
                        if (!(!isThirdPerson && isAimAtTargetEnabled && !isNPC && currentCrouchInput))
                        {
                            // These do nothing if the target transforms are null.
                            HandIKAdjustForHandHold(leftHandData, leftHandTargetTrfm);
                            HandIKAdjustForHandHold(rightHandData, rightHandTargetTrfm);
                        }

                        // call these BEFORE HandIKGetRotation
                        // If we are currently blending out an individual left or right hand IK, use the left/right hand max weights
                        HandIKGetPosition(leftHandData, isHandIKLeftBlendOut ? currentMaxLHandWeight : currentMaxHandIKWeight);
                        HandIKGetPosition(rightHandData, isHandIKRightBlendOut ? currentMaxRHandWeight : currentMaxHandIKWeight);

                        // call these AFTER HandIKGetPosition
                        HandIKGetRotation(leftHandData);
                        HandIKGetRotation(rightHandData);

                        HandIKSetPositionAndRotation(leftHandData);
                        HandIKSetPositionAndRotation(rightHandData);

                        leftHandData.prevHandIKPos = leftHandData.currentHandIKPos;
                        rightHandData.prevHandIKPos = rightHandData.currentHandIKPos;

                        leftHandData.prevHandIKRot = leftHandData.currentHandIKRot;
                        rightHandData.prevHandIKRot = rightHandData.currentHandIKRot;

                        // Start smooth disable after 1 more update. This means we don't need to check currentMaxHandIKWeight every frame.
                        // Ramp down the overall weight over many frames.
                        if (isHandIKSmoothDisable)
                        {
                            currentMaxHandIKWeight -= handIKMoveMaxSpeed * Time.deltaTime;
                            if (currentMaxHandIKWeight <= 0f)
                            {
                                currentMaxHandIKWeight = 0f;
                                isHandIKSmoothDisable = false;
                                EnableOrDisableHandIK(false, false, false);
                            }
                        }
                        else
                        {
                            // Blend out a left Hand IK target
                            if (isHandIKLeftBlendOut)
                            {
                                currentMaxLHandWeight -= leftHandIKBlendOutDuration * Time.deltaTime;

                                if (currentMaxLHandWeight <= 0f)
                                {
                                    currentMaxLHandWeight = 0f;
                                    isHandIKLeftBlendOut = false;

                                    // Reset left hand interactive target
                                    HandIKResetInteractiveTarget(true);
                                }
                            }

                            // Blend out a right Hand IK target
                            if (isHandIKRightBlendOut)
                            {
                                currentMaxRHandWeight -= rightHandIKBlendOutDuration * Time.deltaTime;

                                if (currentMaxRHandWeight <= 0f)
                                {
                                    currentMaxRHandWeight = 0f;
                                    isHandIKRightBlendOut = false;

                                    // Reset right hand interactive target
                                    HandIKResetInteractiveTarget(false);
                                }
                            }
                        }
                    }
                }

                #endregion

                #region Foot IK
                if (isFootIK)
                {
                    if (isMovementEnabled)
                    {
                        #region FootIK - Movement
                        if (footIKAnimIKPassLayerIndex == layerIndex)
                        {
                            FootIKGetPosition(leftFootData, paramHashLFootIKWeightCurve, dTime);
                            FootIKGetPosition(rightFootData, paramHashRFootIKWeightCurve, dTime);

                            FootIKCalcBodyY(leftFootData, rightFootData, dTime, ref currentFootIKOffsetY);

                            // Move the animation down a little if required
                            FootIKSetBodyY(currentFootIKOffsetY);

                            prevFootIKOffsetY = currentFootIKOffsetY;

                            // ****** Commented out for testing *****
                            FootIKSetPosition(leftFootData.foot, leftFootData.currentFootIKPos, leftFootData.currentFootIKRot);
                            FootIKSetPosition(rightFootData.foot, rightFootData.currentFootIKPos, rightFootData.currentFootIKRot);

                            leftFootData.prevFootIKPos = leftFootData.currentFootIKPos;
                            leftFootData.prevFootIKRot = leftFootData.currentFootIKRot;

                            rightFootData.prevFootIKPos = rightFootData.currentFootIKPos;
                            rightFootData.prevFootIKRot = rightFootData.currentFootIKRot;
                        }
                        #endregion
                    }
                    else
                    {
                        #region FootIK - Movement Disabled
                        if (footIKAnimIKPassLayerIndex == layerIndex)
                        {
                            // When isMovementEnabled is false we still need to do FootIK else the feet
                            // go back to default position which could be inside the object below a foot.
                            // If look is still enabled, and we rotate, the legs twist in strange ways.
                            // To avoid this, attempt to place the feet in the last position.

                            FootIKSetBodyY(currentFootIKOffsetY);
                            currentFootIKOffsetY = prevFootIKOffsetY;

                            FootIKSetPosition(leftFootData.foot, leftFootData.prevFootIKPos, leftFootData.prevFootIKRot);
                            FootIKSetPosition(rightFootData.foot, rightFootData.prevFootIKPos, rightFootData.prevFootIKRot);
                        }
                        #endregion
                    }
                }
                #endregion

                // This was to test if AimBonesAtTarget could work when Animator is updated in Physics loop.
                // This test was unsuccessful with both Look LateUpdate and Look FixedUpdate.
                //if (isAnimatorFixedUpdate && isThirdPersonValid && isAimAtTargetEnabled)
                //{
                //    Debug.Log("[DEBUG] TPS AimBonesAtTarget OnAnimatorIK T:" + Time.time);
                //    AimBonesAtTarget(true);
                //}
            }
        }

        /// <summary>
        /// Called by Unity from the Animator component. This is called, regardless of if root motion is set or not.
        /// It will not be called if the Animator component doesn't have a controller set.
        /// Marked "internal" so it can be called from S3DIKEnabler if required.
        /// </summary>
        internal void OnAnimatorMove()
        {
            if (isRootMotion && isAnimateEnabled)
            {
                // This calculates how far the character is away from where the animator thinks it should be
                rootMotionLocalPosError = Quaternion.Inverse(currentWorldRotation) * (defaultAnimator.rootPosition - rBody.position);

                rootMotionRotDelta = defaultAnimator.deltaRotation;
            }
        }

#if UNITY_EDITOR

        /// <summary>
        /// Show some gizmos when the S3D character is selected in the editor.
        /// See also SceneGUI(..) in StickyControlModuleEditor.cs.
        /// </summary>
        private void OnDrawGizmosSelected()
        {
            if (isHandIK)
            {
                Color prevGizmoColour = Gizmos.color;
                Gizmos.color = handZoneGizmoColour;
                if (leftHandTrfm != null)
                {
                    Gizmos.DrawWireSphere(leftHandTrfm.position + (leftHandTrfm.rotation * leftHandPalmOffset), leftHandRadius);
                }

                if (rightHandTrfm != null)
                {
                    Gizmos.DrawWireSphere(rightHandTrfm.position + (rightHandTrfm.rotation * rightHandPalmOffset), leftHandRadius);
                }

                // Hand target gizmos
                if (isAnimateEnabled && Application.isPlaying)
                {
                    if (leftHandData.targetHandIKPos != Vector3.zero)
                    {
                        Gizmos.color = handLHTargetGizmoColour;
                        Gizmos.DrawSphere(leftHandData.targetHandIKPos, 0.02f);
                    }

                    if (rightHandData.targetHandIKPos != Vector3.zero)
                    {
                        Gizmos.color = handRHTargetGizmoColour;
                        Gizmos.DrawSphere(rightHandData.targetHandIKPos, 0.02f);
                    }
                }
                Gizmos.color = prevGizmoColour;
            }
        }
#endif

        #endregion

        #region Private and Internal Methods - Animate General

        /// <summary>
        /// Set any animation parameters as configured in the editor.
        /// Use isIgnoreDamping when you want to override all S3DAnimAction.damping values with 0.0.
        /// This is useful when you want to say disable moment and immediately set those values to 0.
        /// If they remain > 0, and Animate is also disabled, the animation will continue running.
        /// </summary>
        private void AnimateCharacter(bool isIgnoreDamping)
        {
            float dTime = Time.deltaTime;

            #region Layer Blend weights
            // If necessary, update animator layer blend weights
            for (int aLayerIdx = 0; aLayerIdx < numAnimLayers; aLayerIdx++)
            {
                S3DAnimLayerData s3dAnimLayerData = animlayerDataList[aLayerIdx];

                if (s3dAnimLayerData.isBlendingIn)
                {
                    s3dAnimLayerData.blendWeight += dTime / s3dAnimLayerData.blendInDuration;
                    if (s3dAnimLayerData.blendWeight >= 1f)
                    {
                        s3dAnimLayerData.blendWeight = 1f;
                        s3dAnimLayerData.isBlendingIn = false;
                        if (s3dAnimLayerData.callBackOnBlendedIn != null) { s3dAnimLayerData.callBackOnBlendedIn.Invoke(s3dAnimLayerData, aLayerIdx); }
                    }

                    defaultAnimator.SetLayerWeight(aLayerIdx, s3dAnimLayerData.blendWeight);
                }
                else if (s3dAnimLayerData.isBlendingOut)
                {
                    s3dAnimLayerData.blendWeight -= dTime / s3dAnimLayerData.blendOutDuration;
                    if (s3dAnimLayerData.blendWeight <= 0f)
                    {
                        s3dAnimLayerData.blendWeight = 0f;
                        s3dAnimLayerData.isBlendingOut = false;
                        if (s3dAnimLayerData.callBackOnBlendedOut != null) { s3dAnimLayerData.callBackOnBlendedOut.Invoke(s3dAnimLayerData, aLayerIdx); }
                    }

                    defaultAnimator.SetLayerWeight(aLayerIdx, s3dAnimLayerData.blendWeight);
                }
            }
            #endregion

            // Loop through all the animate actions. If the animator is null numAnimateActions is set to 0.
            for (int aaIdx = 0; aaIdx < numAnimateActions; aaIdx++)
            {
                S3DAnimAction aa = s3dAnimActionList[aaIdx];

                if (CheckAnimateConditions(aa))
                {
                    // Currently StandardAction is mostly cosmetic (apart from Custom) but may be used in
                    // the future when potentially users can set up their own.
                    // Might be able to optimise based on the StandardAction by skipping actions
                    // that don't apply...
                    int aaStandardActionInt = (int)aa.standardAction;

                    int aaParamTypeInt = (int)aa.parameterType;

                    if (aaParamTypeInt != S3DAnimAction.ParameterTypeNoneInt)
                    {
                        #region Float
                        if (aaParamTypeInt == S3DAnimAction.ParameterTypeFloatInt)
                        {
                            if (aaStandardActionInt == S3DAnimAction.StandardActionCustomInt)
                            {
                                /// TODO - Test sending a blendRate value with a custom action float
                                defaultAnimator.SetFloat(aa.paramHashCode, aa.customActionFloatValue * aa.floatMultiplier);
                                // Reset custom value after use
                                aa.customActionFloatValue = 0f;
                            }
                            // Is this animate action configured to send a fixed float value to the animation controller parameter?
                            else if ((int)aa.actionFloatValue == S3DAnimAction.ActionFloatValueFixedInt)
                            {
                                defaultAnimator.SetFloat(aa.paramHashCode, aa.fixedFloatValue, isIgnoreDamping ? 0f : aa.damping, dTime);
                            }
                            else
                            {
                                defaultAnimator.SetFloat(aa.paramHashCode, GetAnimateFloatValue(aa.actionFloatValue) * aa.floatMultiplier, isIgnoreDamping ? 0f : aa.damping, dTime);
                            }
                        }
                        #endregion

                        #region Bool
                        else if (aaParamTypeInt == S3DAnimAction.ParameterTypeBoolInt)
                        {
                            if (aaStandardActionInt == S3DAnimAction.StandardActionCustomInt)
                            {
                                defaultAnimator.SetBool(aa.paramHashCode, aa.isInvert ? !aa.customActionBoolValue : aa.customActionBoolValue);
                                // Reset custom value after use (should be on by default)
                                if (aa.isResetCustomAfterUse && !aa.isToggle) { aa.customActionBoolValue = false; }
                            }
                            // Is this animate action configured to send a fixed bool value (true or false) to the animation controller parameter?
                            else if ((int)aa.actionBoolValue == S3DAnimAction.ActionBoolValueFixedInt)
                            {
                                defaultAnimator.SetBool(aa.paramHashCode, aa.fixedBoolValue);
                            }
                            else
                            {
                                defaultAnimator.SetBool(aa.paramHashCode, aa.isInvert ? !GetAnimateBoolValue(aa.actionBoolValue) : GetAnimateBoolValue(aa.actionBoolValue));
                            }
                        }
                        #endregion

                        #region Trigger
                        else if (aaParamTypeInt == S3DAnimAction.ParameterTypeTriggerInt)
                        {
                            // Triggers are only set if the condition is true
                            if (aaStandardActionInt == S3DAnimAction.StandardActionCustomInt)
                            {
                                if (aa.customActionTriggerValue)
                                {
                                    defaultAnimator.SetTrigger(aa.paramHashCode);
                                }
                                // Reset custom value after use
                                aa.customActionTriggerValue = false;
                            }
                            else if (GetAnimateTriggerValue(aa.actionTriggerValue))
                            {
                                defaultAnimator.SetTrigger(aa.paramHashCode);
                            }
                        }
                        #endregion

                        #region Integer
                        else if (aaParamTypeInt == S3DAnimAction.ParameterTypeIntegerInt)
                        {
                            if (aaStandardActionInt == S3DAnimAction.StandardActionCustomInt)
                            {
                                defaultAnimator.SetInteger(aa.paramHashCode, aa.customActionIntegerValue);
                                // Reset custom value after use
                                aa.customActionIntegerValue = 0;
                            }
                            else
                            {
                                defaultAnimator.SetInteger(aa.paramHashCode, GetAnimateIntegerValue(aa.actionIntegerValue));
                            }
                        }
                        #endregion
                    }

                    // TEST CODE
                    //CheckTransistions(aa);
                }
            }
        }

        /// <summary>
        /// TEST CODE ONLY
        /// </summary>
        /// <param name="s3dAnimAction"></param>
        private void CheckTransistions(S3DAnimAction s3dAnimAction)
        {
            if (s3dAnimAction != null)
            {
                if (defaultAnimator.IsInTransition(0))
                {
                    // These are all read only...
                    AnimatorTransitionInfo trInfo = defaultAnimator.GetAnimatorTransitionInfo(0);
                    var stateInfo = defaultAnimator.GetCurrentAnimatorStateInfo(0);

                    //AnimationClip[] clips = defaultAnimator.runtimeAnimatorController.animationClips;

                    //defaultAnimator.get_an

                    //var beh = defaultAnimator.GetBehaviours();

                    //trInfo.duration = 5f;

                    Debug.Log("[DEBUG is in transition duration:" + trInfo.duration + " T:" + Time.time);
                }
            }
        }

        /// <summary>
        /// Attempt to enable or disable animate
        /// </summary>
        /// <param name="isEnabled"></param>
        internal void EnableOrDisableAnimate(bool isEnabled)
        {
            isAnimateEnabled = isEnabled;

            if (isEnabled)
            {
                if (defaultAnimator == null)
                {
                    isAnimateEnabled = false;
                    isAnimatorFixedUpdate = false;
#if UNITY_EDITOR
                    Debug.LogWarning("Sticky3D on " + name + " could not enable animate because there is no Animator set on the Animate tab");
#endif
                }
                else if (defaultAnimator.runtimeAnimatorController == null)
                {
                    isAnimateEnabled = false;
                    isAnimatorFixedUpdate = false;
                    //defaultAnimator.speed = 0f;
#if UNITY_EDITOR
                    Debug.LogWarning("Sticky3D  on " + name + " could not enable animate because there is no controller set on the Animator component");
#endif
                }
                else
                {
                    // Get number of Animator layers
                    numAnimLayers = defaultAnimator.layerCount;

                    if (animlayerDataList == null) { animlayerDataList = new List<S3DAnimLayerData>(numAnimLayers); }
                    else { animlayerDataList.Clear(); }

                    // Populate the list with layer data from the animator
                    for (int aLayerIdx = 0; aLayerIdx < numAnimLayers; aLayerIdx++)
                    {
                        S3DAnimLayerData s3dAnimLayerData = new S3DAnimLayerData()
                        {
                            layerIndex = aLayerIdx,
                            blendWeight = defaultAnimator.GetLayerWeight(aLayerIdx)
                        };

                        animlayerDataList.Add(s3dAnimLayerData);
                    }

                    IsAnimatorFixedUpdate(true);
                }
            }
        }

        /// <summary>
        /// Get standard in-built boolean values from Sticky3D controller to pass to an animation controller.
        /// These typically indicate a state of the character. e.g. is on the ground, or is walking.
        /// </summary>
        /// <param name="actionBoolValue"></param>
        /// <returns></returns>
        private bool GetAnimateBoolValue(S3DAnimAction.ActionBoolValue actionBoolValue)
        {
            bool bValue = false;

            // The cases must match those found in the S3DAnimAction.ActionBoolValue enumeration 
            switch (actionBoolValue)
            {
                case S3DAnimAction.ActionBoolValue.IsGrounded:
                    bValue = isGrounded;
                    break;
                case S3DAnimAction.ActionBoolValue.IsStepping:
                    bValue = isStepping;
                    break;
                case S3DAnimAction.ActionBoolValue.IsSteppingDown:
                    bValue = isSteppingDown;
                    break;
                case S3DAnimAction.ActionBoolValue.IsCrouching:
                    bValue = IsCrouching;
                    break;
                case S3DAnimAction.ActionBoolValue.IsIdle:
                    // If you change this, also change IsIdle public property "IsIdle"
                    bValue = !isInitialised || !isMovementEnabled || (!isClimbing && currentLocalVelocity.sqrMagnitude < moveIdleThreshold);
                    break;
                case S3DAnimAction.ActionBoolValue.IsJetPacking:
                    bValue = isJetPackEnabled && isJetPackAvailable;
                    break;
                case S3DAnimAction.ActionBoolValue.IsGroundedOrJetPacking:
                    bValue = isGrounded || isJetPackEnabled;
                    break;
                case S3DAnimAction.ActionBoolValue.IsGroundedOrClimbing:
                    bValue = isGrounded || isClimbing;
                    break;
                case S3DAnimAction.ActionBoolValue.IsGroundedOrClimbingOrSteppingDown:
                    bValue = isGrounded || isClimbing || isSteppingDown;
                    break;
                case S3DAnimAction.ActionBoolValue.IsGroundedOrSteppingDown:
                    bValue = isGrounded || isSteppingDown;
                    break;
                case S3DAnimAction.ActionBoolValue.IsWalking:
                    bValue = IsWalking;
                    break;
                case S3DAnimAction.ActionBoolValue.IsWalkingForward:
                    bValue = IsWalkingForward;
                    break;
                case S3DAnimAction.ActionBoolValue.IsWalkingBackward:
                    bValue = IsWalkingBackward;
                    break;
                case S3DAnimAction.ActionBoolValue.IsWalkingOrStrafing:
                    bValue = IsWalkingOrStrafing;
                    break;
                case S3DAnimAction.ActionBoolValue.IsStrafing:
                    bValue = IsStrafing;
                    break;
                case S3DAnimAction.ActionBoolValue.IsStrafingRight:
                    bValue = IsStrafingRight;
                    break;
                case S3DAnimAction.ActionBoolValue.IsStrafingLeft:
                    bValue = IsStrafingLeft;
                    break;
                case S3DAnimAction.ActionBoolValue.IsSprinting:
                    bValue = IsSprinting;
                    break;
                case S3DAnimAction.ActionBoolValue.HasLanded:
                    bValue = isLanding;
                    break;
                case S3DAnimAction.ActionBoolValue.HasJumped:
                    // When jump button can be held down we can get a false positive for a jump action.
                    // Typically the button is set to held down for use with the Jet Pack.
                    bValue = currentJumpInput && isJumpStartedThisFrame;
                    break;
                case S3DAnimAction.ActionBoolValue.IsClimbing:
                    bValue = isClimbing;
                    break;
                case S3DAnimAction.ActionBoolValue.IsClimbingAtTop:
                    bValue = isClimbingAtTop;
                    break;
                case S3DAnimAction.ActionBoolValue.IsSprintInput:
                    bValue = IsSprintInput;
                    break;
                case S3DAnimAction.ActionBoolValue.IsStrafeInput:
                    bValue = IsStrafeInput;
                    break;
                case S3DAnimAction.ActionBoolValue.IsWalkInput:
                    bValue = IsWalkInput;
                    break;
                case S3DAnimAction.ActionBoolValue.IsLookLeftInput:
                    bValue = IsLookLeftInput;
                    break;
                case S3DAnimAction.ActionBoolValue.IsLookRightInput:
                    bValue = IsLookRightInput;
                    break;
                case S3DAnimAction.ActionBoolValue.IsLookDownInput:
                    bValue = IsLookDownInput;
                    break;
                case S3DAnimAction.ActionBoolValue.IsLookUpInput:
                    bValue = IsLookUpInput;
                    break;
                case S3DAnimAction.ActionBoolValue.IsLookWhileIdle:
                    bValue = IsLookWhileIdle;
                    break;
                case S3DAnimAction.ActionBoolValue.IsLookLeftOrRightWhileIdle:
                    bValue = IsLookLeftOrRightWhileIdle;
                    break;
                case S3DAnimAction.ActionBoolValue.IsLookUpOrDownWhileIdle:
                    bValue = IsLookUpOrDownWhileIdle;
                    break;
                default: break;
            }

            return bValue;
        }

        /// <summary>
        /// Get standard in-built float values from Sticky3D controller to pass to an animation controller.
        /// e.g. the speed the character is walking.
        /// </summary>
        /// <param name="actionFloatValue"></param>
        /// <returns></returns>
        private float GetAnimateFloatValue(S3DAnimAction.ActionFloatValue actionFloatValue)
        {
            float fvalue = 0f;

            // The cases must match those found in the S3DAnimAction.ActionFloatValue enumeration 

            switch (actionFloatValue)
            {
                case S3DAnimAction.ActionFloatValue.MovingSpeed:
                    fvalue = currentLocalVelocity.magnitude;
                    break;
                case S3DAnimAction.ActionFloatValue.MovingForwardSpeed:
                    fvalue = currentLocalVelocity.z > moveIdleThreshold ? currentLocalVelocity.z : 0f;
                    break;
                case S3DAnimAction.ActionFloatValue.MovingBackwardSpeed:
                    fvalue = currentLocalVelocity.z < -moveIdleThreshold ? currentLocalVelocity.z : 0f;
                    break;
                case S3DAnimAction.ActionFloatValue.MovingForwardBackSpeed:
                    fvalue = currentLocalVelocity.z < -moveIdleThreshold || currentLocalVelocity.z > moveIdleThreshold ? currentLocalVelocity.z : 0f;
                    break;
                case S3DAnimAction.ActionFloatValue.MovingDirectionX:
                    fvalue = currentLocalVelocity.normalized.x;
                    if (fvalue > -moveIdleThreshold && fvalue < moveIdleThreshold) { fvalue = 0f; }
                    break;
                case S3DAnimAction.ActionFloatValue.MovingDirectionY:
                    fvalue = currentLocalVelocity.normalized.y;
                    break;
                case S3DAnimAction.ActionFloatValue.MovingDirectionZ:
                    fvalue = currentLocalVelocity.normalized.z;
                    if (fvalue > -moveIdleThreshold && fvalue < moveIdleThreshold) { fvalue = 0f; }
                    break;
                case S3DAnimAction.ActionFloatValue.MovingSpeedInvN:
                    fvalue = S3DMath.InvNormalise(currentLocalVelocity.magnitude, currentSprintInput && !isClimbing ? sprintSpeed : walkSpeed);
                    break;
                case S3DAnimAction.ActionFloatValue.MovingSpeedN:
                    // If sprinting, nromalise sprintSpeed. If strafing but not walking forward or back, normalise strafeSpeed.
                    // Otherwise, normalise te walkSpeed based on the local velocity.
                    fvalue = S3DMath.Normalise(currentLocalVelocity.magnitude, currentSprintInput && !isClimbing ? sprintSpeed : (currentLocalVelocity.x < -moveIdleThreshold || currentLocalVelocity.x > moveIdleThreshold) && (currentLocalVelocity.z > -moveIdleThreshold && currentLocalVelocity.z < moveIdleThreshold) ? strafeSpeed :  walkSpeed);
                    break;
                case S3DAnimAction.ActionFloatValue.CrouchSpeed:
                    fvalue = crouchSpeed;
                    break;
                case S3DAnimAction.ActionFloatValue.CrouchAmount:
                    fvalue = CrouchAmount;
                    break;
                case S3DAnimAction.ActionFloatValue.SprintingSpeed:
                    fvalue = SprintingSpeed;
                    break;
                case S3DAnimAction.ActionFloatValue.StrafingSpeed:
                    fvalue = currentLocalVelocity.x;
                    break;
                case S3DAnimAction.ActionFloatValue.StrafingRightSpeed:
                    fvalue = currentLocalVelocity.x > moveIdleThreshold ? currentLocalVelocity.x : 0f;
                    break;
                case S3DAnimAction.ActionFloatValue.StrafingLeftSpeed:
                    fvalue = currentLocalVelocity.x < -moveIdleThreshold ? currentLocalVelocity.x : 0f;
                    break;
                case S3DAnimAction.ActionFloatValue.StrafingSpeedN:
                    fvalue = S3DMath.Normalise(currentLocalVelocity.x, currentSprintInput && !isClimbing ? sprintSpeed : strafeSpeed);
                    break;
                case S3DAnimAction.ActionFloatValue.TurningSpeed:
                    fvalue = isMovementEnabled ? currentLocalAngularVelocity.y : 0f;
                    break;
                case S3DAnimAction.ActionFloatValue.WalkingSpeed:
                    fvalue = WalkingSpeed;
                    break;
                case S3DAnimAction.ActionFloatValue.WalkingForwardSpeed:
                    fvalue = WalkingForwardSpeed;
                    break;
                case S3DAnimAction.ActionFloatValue.WalkingBackwardSpeed:
                    fvalue = WalkingBackwardSpeed;
                    break;
                case S3DAnimAction.ActionFloatValue.WalkSpeed:
                    fvalue = walkSpeed;
                    break;
                case S3DAnimAction.ActionFloatValue.SprintSpeed:
                    fvalue = sprintSpeed;
                    break;
                case S3DAnimAction.ActionFloatValue.StrafeSpeed:
                    fvalue = strafeSpeed;
                    break;
                case S3DAnimAction.ActionFloatValue.JumpSpeed:
                    fvalue = jumpSpeed;
                    break;
                case S3DAnimAction.ActionFloatValue.ClimbSpeed:
                    fvalue = climbSpeed;
                    break;
                case S3DAnimAction.ActionFloatValue.MovementInputX:
                    fvalue = currentLocalSpaceMovementInput.x;
                    break;
                case S3DAnimAction.ActionFloatValue.MovementInputY:
                    fvalue = currentLocalSpaceMovementInput.y;
                    break;
                case S3DAnimAction.ActionFloatValue.MovementInputZ:
                    fvalue = currentLocalSpaceMovementInput.z;
                    break;
                case S3DAnimAction.ActionFloatValue.MovementInputMagnitude:

                    //fvalue = new Vector3
                    //(
                    //    currentLocalSpaceMovementInput.x * (currentSprintInput ? sprintSpeed : strafeSpeed) * health, 0f,
                    //    currentLocalSpaceMovementInput.z * (currentSprintInput ? sprintSpeed : walkSpeed) * health
                    //).magnitude;

                    fvalue = currentLocalSpaceMovementInput.magnitude;
                    break;
                case S3DAnimAction.ActionFloatValue.LookHorizontalInput:
                    fvalue = currentHorizontalLookInput;
                    break;
                case S3DAnimAction.ActionFloatValue.LookVerticalInput:
                    fvalue = currentVerticalLookInput;
                    break;
                case S3DAnimAction.ActionFloatValue.LookZoomInput:
                    fvalue = currentZoomLookInput;
                    break;
                case S3DAnimAction.ActionFloatValue.LookOrbitInput:
                    fvalue = currentOrbitLookInput;
                    break;
                default: break;
            }

            return fvalue;
        }

        /// <summary>
        /// Get standard in-built integer values from Sticky3D controller to pass to an animation controller.
        /// </summary>
        /// <param name="actionIntegerValue"></param>
        /// <returns></returns>
        private int GetAnimateIntegerValue(S3DAnimAction.ActionIntegerValue actionIntegerValue)
        {
            int ivalue = 0;

            // The cases must match those found in the S3DAnimAction.ActionIntegerValue enumeration 

            switch (actionIntegerValue)
            {
                case S3DAnimAction.ActionIntegerValue.None:
                    ivalue = 0;
                    break;

                default: break;
            }

            return ivalue;
        }

        /// <summary>
        /// Get standard in-built trigger (boolean) values from Sticky3D controller to pass to an animation controller.
        /// These typically occur once as a single event.
        /// </summary>
        /// <param name="actionTriggerValue"></param>
        /// <returns></returns>
        private bool GetAnimateTriggerValue(S3DAnimAction.ActionTriggerValue actionTriggerValue)
        {
            bool bValue = false;

            switch (actionTriggerValue)
            {
                case S3DAnimAction.ActionTriggerValue.Crouch:
                    bValue = IsCrouching;
                    break;
                case S3DAnimAction.ActionTriggerValue.Jump:
                    // When jump button can be held down we can get a false positive for a jump action.
                    // Typically the button is set to held down for use with the Jet Pack.
                    bValue = currentJumpInput && isJumpStartedThisFrame;
                    break;
                case S3DAnimAction.ActionTriggerValue.Land:
                    bValue = isLanding;
                    break;
                default: break;
            }

            return bValue;
        }

        /// <summary>
        /// Refresh and validate Animate settings. Call this after changing any Animate settings.
        /// See also the public API RefreshAnimateSettings().
        /// </summary>
        /// <param name="isInitialising">Is this being called from Initialise()</param>
        private void RefreshAnimateSettings(bool isInitialising)
        {
            if (defaultAnimator != null)
            {
                if (s3dAnimActionList == null) { s3dAnimActionList = new List<S3DAnimAction>(10); }

                numAnimateActions = s3dAnimActionList == null ? 0 : s3dAnimActionList.Count;

                // cache the number of animation conditions for each Animate Action
                for (int aaIdx = 0; aaIdx < numAnimateActions; aaIdx++)
                {
                    S3DAnimAction aa = s3dAnimActionList[aaIdx];
                    if (aa != null)
                    {
                        aa.numConditions = aa.s3dAnimConditionList == null ? 0 : aa.s3dAnimConditionList.Count;
                    }
                }

                RefreshAimBoneTransforms();
            }

            // We always want to have left and right hand data so that when grabbing items etc we don't need
            // to check for their existence. It also avoids allocations AFTER the character is initialised.
            if (leftHandData == null) { leftHandData = new S3DHandData() { hand = AvatarIKGoal.LeftHand }; }
            if (rightHandData == null) { rightHandData = new S3DHandData() { hand = AvatarIKGoal.RightHand }; }

            RefreshAnimateControllerOverride(isInitialising);

            EnableOrDisableHeadIK(isHeadIK, isInitialising, false);
            EnableOrDisableHandIK(isHandIK, isInitialising, false);
            EnableOrDisableFootIK(isFootIK, isInitialising);
            EnableOrDisableRootMotion(isRootMotion);

            EnableOrDisableHandVR(isHandVR, isInitialising);
        }

        /// <summary>
        /// Initialise the Human Pose structure.
        /// INCOMPLETE WIP
        /// </summary>
        private bool GetHumanPose()
        {
            bool isSuccessful = false;
            // Use humanPose.muscles[muscleIndex] = 0..1 to change muscles
            // then hposeHandler.SetHumanPose(ref humanPose);

            Avatar avatar = defaultAnimator == null ? null : defaultAnimator.avatar;

            // TODO - get the root transform of the character
            if (hposeHandler == null)
            {
                if (avatar != null && IsValidHumanoid(true))
                {
                    Transform rootTfrm = defaultAnimator.GetBoneTransform(HumanBodyBones.Hips);

                    //Debug.Log("Root: " + rootTfrm.parent);

                    //hposeHandler = new HumanPoseHandler(avatar, rootTfrm.parent);
                    hposeHandler = new HumanPoseHandler(avatar, defaultAnimator.transform);

                    if (hposeHandler != null)
                    {
                        humanPose = new HumanPose();
                        hposeHandler.GetHumanPose(ref humanPose);

                        isSuccessful = true;
                    }
                }
            }
            else
            {
                hposeHandler.GetHumanPose(ref humanPose);
                isSuccessful = true;
            }

            return isSuccessful;
        }

        /// <summary>
        /// Get sign, pre and post rotations via reflection.
        /// This may be required to calculate Hand IK local rotations.
        /// </summary>
        /// <param name="bone"></param>
        /// <param name="sign"></param>
        /// <param name="preRot"></param>
        /// <param name="postRot"></param>
        /// <returns></returns>
        private bool GetInternalBoneRotations(HumanBodyBones bone, ref Vector3 sign, ref Quaternion preRot, ref Quaternion postRot)
        {
            Avatar avatar = defaultAnimator == null ? null : defaultAnimator.avatar;

            if (avatar != null)
            {
                object[] boneObj = new object[] { bone };
                // Sign of x,y,z
                sign = (Vector3)miGetLimitSign.Invoke(avatar, boneObj);
                preRot = (Quaternion)miGetPreRotation.Invoke(avatar, boneObj);
                postRot = (Quaternion)miGetPostRotation.Invoke(avatar, boneObj);

                return true;
            }
            else
            {
                return false;
            }
        }

        /// <summary>
        /// [INTERNAL ONLY]
        /// Temporarily override an animation clip with a new clip.
        /// NOTE: This will replace ALL clips in all layers with the same name.
        /// WARNING: This currently breaks the PUBLIC API ReplaceAnimationClip(..)
        ///          animOverrideController is now null...
        /// </summary>
        /// <param name="currentClip"></param>
        /// <param name="newClip"></param>
        internal void OverrideAnimationClip(AnimationClip currentClip, AnimationClip newClip)
        {
            if (isInitialised && currentClip != null && newClip != null)
            {
                //AnimClipOverrides ao = new AnimClipOverrides(1);

                // Get the current runtime controller, which could be a previously used override controller.
                AnimatorOverrideController currentOverrideController = defaultAnimator.runtimeAnimatorController as AnimatorOverrideController;

                if (currentOverrideController[currentClip.name] != newClip)
                {
                    RuntimeAnimatorController originalRTController = currentOverrideController.runtimeAnimatorController;

                    // Disconnect the orignal controller first otherwise when deleting this override it will send a callback
                    // to the animator to reset the state machine
                    currentOverrideController.runtimeAnimatorController = null;

                    AnimatorOverrideController newOverrideController = new AnimatorOverrideController();
                    newOverrideController.runtimeAnimatorController = originalRTController;

                    newOverrideController[currentClip.name] = newClip;
                    defaultAnimator.runtimeAnimatorController = newOverrideController;

                    Object.Destroy(currentOverrideController);
                }
            }
        }

        /// <summary>
        /// Overriding the controller is necessary when we want to replace an animation clip
        /// </summary>
        /// <param name="forceRefresh"></param>
        private void RefreshAnimateControllerOverride(bool forceRefresh)
        {
            if (defaultAnimator != null && defaultAnimator.runtimeAnimatorController != null)
            {
                if (forceRefresh || animOverrideController == null)
                {
                    animOverrideController = new AnimatorOverrideController(defaultAnimator.runtimeAnimatorController);
                    defaultAnimator.runtimeAnimatorController = animOverrideController;
                }
            }
        }

        /// <summary>
        /// Check if character is a valid humanoid, then get transforms for common humanoid bones
        /// </summary>
        private bool RefreshBoneTransforms(bool isForceRefresh)
        {
            bool isRefreshed = false;

            if (IsValidHumanoid(true))
            {
                //Debug.Log("[DEBUG] RefreshBoneTransforms isForceRefresh: " + isForceRefresh);

                // If not already set, get some bone transforms
                if (isForceRefresh || leftHandTrfm == null) { leftHandTrfm = defaultAnimator.GetBoneTransform(HumanBodyBones.LeftHand); }
                if (isForceRefresh || rightHandTrfm == null) { rightHandTrfm = defaultAnimator.GetBoneTransform(HumanBodyBones.RightHand); }

                // Note: The shoulder is an optional bone and may not be present in all humanoids.
                // Upper Arm, Lower Arm, and Hand are mandatory for a valid humanoid.
                if (isForceRefresh || leftUpperArmTrfm == null) { leftUpperArmTrfm = defaultAnimator.GetBoneTransform(HumanBodyBones.LeftUpperArm); }
                if (isForceRefresh || rightUpperArmTrfm == null) { rightUpperArmTrfm = defaultAnimator.GetBoneTransform(HumanBodyBones.RightUpperArm); }

                if (isForceRefresh || leftLowerArmTrfm == null) { leftLowerArmTrfm = defaultAnimator.GetBoneTransform(HumanBodyBones.LeftLowerArm); }
                if (isForceRefresh || rightLowerArmTrfm == null) { rightLowerArmTrfm = defaultAnimator.GetBoneTransform(HumanBodyBones.RightLowerArm); }

                if (miGetLimitSign == null)
                {
                    miGetLimitSign = S3DUtils.ReflectionGetMethod(typeof(Avatar), "GetLimitSign", true, false);
                }
                if (miGetPreRotation == null)
                {
                    miGetPreRotation = S3DUtils.ReflectionGetMethod(typeof(Avatar), "GetPreRotation", true, false);
                }
                if (miGetPostRotation == null)
                {
                    miGetPostRotation = S3DUtils.ReflectionGetMethod(typeof(Avatar), "GetPostRotation", true, false);
                }

                isRefreshed = true;
            }

            return isRefreshed;
        }

        #endregion

        #region Private and Internal Methods - Animate Aim IK

        /// <summary>
        /// Attempt to aim towards where the character is looking.
        /// Currently we're only trying to adjust the pitch here.
        /// Horizontal adjustment happens when we first start aiming in UpdateController().
        /// Search for AimAtTargetHorizontalAngle().
        /// Called from AimBonesAtTarget() and currently used for 3rd person.
        /// NOTE: FPS uses AimBonesFPS() and AimBoneWithPitch(..).
        /// </summary>
        /// <param name="aimBone"></param>
        /// <param name="remainingTotalBonesWeight"></param>
        /// <param name="isOnAnimatorIK"></param>
        private void AimBoneAtTarget(S3DHumanBone aimBone, float remainingTotalBonesWeight, bool isOnAnimatorIK)
        {
            if (aimBone.isValid)
            {
                // Determine if the aim position is in front of the weapon
                //Vector3 aimTargetLS = GetLocalPosition(aimTargetPos);
                Vector3 aimTargetLS = GetLocalPosition(weaponAimPos);
                Vector3 aimFromLS = GetLocalPosition(aimFromPos);
                Vector3 aimDirLS = S3DMath.Normalise(aimFromLS, aimTargetLS);
                float dotProdToTarget = Vector3.Dot(aimDirLS, Vector3.forward);

                // Only consider targets that are infront of the weapon
                // NOTE: we might want to discard or weight targets on the extreme left or right edges
                if (dotProdToTarget >= 0f && aimBone.weight > Vector3.kEpsilon)
                {
                    // Calculate the effective weight for this bone
                    float boneWeight = aimBone.weight / remainingTotalBonesWeight;

                    // Calculate the difference between the weapon aim angle and the target,
                    // and multiply it by the bone weight. This is how much we want to rotate
                    // this bone by
                    float deltaPitchAngle = AimAtTargetPitchAngle(aimBone.boneTransform) * boneWeight;

                    // TESTING - attempt to fix issue with 3rd person
                    if (isThirdPersonValid)
                    {
                        float targetPitchAngle = aimBone.currentPitchAngle + deltaPitchAngle;

                        // Pitch up
                        if (targetPitchAngle < -aimIKUpLimit)
                        {
                            deltaPitchAngle = -aimIKUpLimit - aimBone.currentPitchAngle;
                        }
                        // Pitch down
                        else if (targetPitchAngle > aimIKDownLimit)
                        {
                            deltaPitchAngle = aimIKDownLimit - aimBone.currentPitchAngle;
                        }
                    }

                    // Add this angle to the stored current pitch angle for this bone
                    aimBone.currentPitchAngle += deltaPitchAngle;
                    // Rotate the bone by the stored current pitch angle
                    Quaternion wsRotation = Quaternion.AngleAxis(-aimBone.currentPitchAngle, transform.right) * aimBone.boneTransform.rotation;

                    if (isOnAnimatorIK)
                    {
                        // Convert it to local space rotation for use in method called in OnAnimatorIK
                        defaultAnimator.SetBoneLocalRotation(aimBone.bone, Quaternion.Inverse(aimBone.boneTransform.rotation) * wsRotation);
                    }
                    else
                    {
                        aimBone.boneTransform.rotation = wsRotation;
                    }

                    if (aimBone.isPaired && aimBone.isTwinValid)
                    {
                        // Rotate the paired bone by the same amount this bone was rotated by
                        wsRotation = Quaternion.AngleAxis(-aimBone.currentPitchAngle, transform.right) * aimBone.boneTransformTwin.rotation;

                        if (isOnAnimatorIK)
                        {
                            // Convert it to local space rotation for use in method called in OnAnimatorIK
                            defaultAnimator.SetBoneLocalRotation(aimBone.boneTwin, Quaternion.Inverse(aimBone.boneTransformTwin.rotation) * wsRotation);
                        }
                        else
                        {
                            aimBone.boneTransformTwin.rotation = wsRotation;
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Pitch up or down as FPS camera is pitched up or down.
        /// Called from AimBonesFPS() to sync bone pitch with FP camera pitch up/down.
        /// </summary>
        /// <param name="aimBone"></param>
        /// <param name="remainingTotalBonesWeight"></param>
        /// <param name="isOnAnimatorIK">Is this called from OnAnimatorIK event?</param>
        private void AimBoneWithPitch(S3DHumanBone aimBone, float remainingTotalBonesWeight, bool isOnAnimatorIK)
        {
            if (aimBone.isValid && aimBone.weight > Vector3.kEpsilon)
            {
                // Ignore shoulders when run from OnAnimatorIK as we get extreme results because the bones haven't yet been rotated
                // in the OnAnimatorIK event.
                //if (isOnAnimatorIK && (aimBone.bone == HumanBodyBones.LeftShoulder || aimBone.bone == HumanBodyBones.RightShoulder)) { return; }
                if (aimBone.bone == HumanBodyBones.LeftShoulder || aimBone.bone == HumanBodyBones.RightShoulder) { return; }

                // Calculate the effective weight for this bone
                float boneWeight = aimBone.weight / remainingTotalBonesWeight;

                // Project the bone direction onto the characters y-z plane
                Vector3 boneFwdVert = Vector3.ProjectOnPlane(GetLocalDirection(aimBone.boneTransform.forward), Vector3.right);
                // Calc just the x-axis (vertical up/down or pitch) local component
                float bonePitchAngle = Vector3.SignedAngle(Vector3.forward, boneFwdVert, Vector3.right);

                // multiply by aimIKBoneWeightFPS to help sync bone pitch rate with camera.
                aimBone.currentPitchAngle = (currentLookRotEulerAngles.x * aimIKBoneWeightFPS * boneWeight) + bonePitchAngle;
                //aimBone.currentPitchAngle = (currentLookRotEulerAngles.x * 0.9f * boneWeight) + bonePitchAngle;

                // The bone may pitch up and down in the wrong direction when called from
                // OnAnimatorIK and it is set using SetBoneLocalRotation. If set in the Inspector, correct this.
                if (isOnAnimatorIK && aimBone.isFlipPitch) { aimBone.currentPitchAngle *= -1f; }

                // Rotate the bone by the stored current pitch angle

                // Get the target world space rotation of the bone
                Quaternion wsRotation = Quaternion.AngleAxis(aimBone.currentPitchAngle, transform.right) * aimBone.boneTransform.rotation;

                if (isOnAnimatorIK)
                {
                    // Convert it to local space rotation for use in method called in OnAnimatorIK
                    defaultAnimator.SetBoneLocalRotation(aimBone.bone, Quaternion.Inverse(aimBone.boneTransform.rotation) * wsRotation);
                }
                else
                {
                    aimBone.boneTransform.rotation = wsRotation;
                }

                if (aimBone.isPaired && aimBone.isTwinValid)
                {
                    // Rotate the paired bone by the same amount this bone was rotated by

                    // Get the world space rotation of the twin
                    wsRotation = Quaternion.AngleAxis(aimBone.currentPitchAngle, transform.right) * aimBone.boneTransformTwin.rotation;

                    if (isOnAnimatorIK)
                    {
                        // Convert it to local space rotation for use in method called in OnAnimatorIK
                        defaultAnimator.SetBoneLocalRotation(aimBone.boneTwin, Quaternion.Inverse(aimBone.boneTransformTwin.rotation) * wsRotation);
                    }
                    else
                    {
                        aimBone.boneTransformTwin.rotation = wsRotation;
                    }
                }
            }
        }

        /// <summary>
        /// Reset the currentPitchAngle for each bone
        /// </summary>
        /// <returns></returns>
        private void AimBoneReset()
        {
            for (int bIdx = 0; bIdx < numAimBones; bIdx++)
            {
                aimBones[bIdx].currentPitchAngle = 0f;
            }
        }

        /// <summary>
        /// Get the total weighting or influence of all aimBones. This is used to determine
        /// the normalised influence (weight) of each bone.
        /// </summary>
        /// <param name="isOnAnimatorIK"></param>
        /// <returns></returns>
        private float AimBoneTotalWeight (bool isOnAnimatorIK)
        {
            float totalBoneWeight = 0f;

            for (int bIdx = 0; bIdx < numAimBones; bIdx++)
            {
                if (isOnAnimatorIK)
                {
                    // Ignore shoulders when running from the OnAnimatorIK event
                    S3DHumanBone s3DHumanBone = aimBones[bIdx];
                    if (s3DHumanBone.bone != HumanBodyBones.LeftShoulder && s3DHumanBone.bone != HumanBodyBones.RightShoulder)
                    {
                        totalBoneWeight += s3DHumanBone.weight;
                    }
                }
                else
                {
                    totalBoneWeight += aimBones[bIdx].weight;
                }
            }

            return totalBoneWeight;
        }

        /// <summary>
        /// Attempt to aim body toward where the character is looking.
        /// This currently only affects pitch and is used in 3rd person.
        /// </summary>
        private void AimBonesAtTarget(bool isOnAnimatorIK)
        {
            float remainingTotalBoneWeight = AimBoneTotalWeight(false);

            for (int bIdx = 0; bIdx < numAimBones; bIdx++)
            {
                AimBoneAtTarget(aimBones[bIdx], remainingTotalBoneWeight, isOnAnimatorIK);
                remainingTotalBoneWeight -= aimBones[bIdx].weight;
            }
        }

        /// <summary>
        /// Attempt to aim body in sync with FPS camera pitch
        /// </summary>
        /// <param name="isOnAnimatorIK">Is this called from OnAnimatorIK event?</param>
        private void AimBonesFPS(bool isOnAnimatorIK)
        {
            //float remainingTotalBoneWeight = AimBoneTotalWeight(isOnAnimatorIK);
            float remainingTotalBoneWeight = AimBoneTotalWeight(true);

            for (int bIdx = 0; bIdx < numAimBones; bIdx++)
            {
                AimBoneWithPitch(aimBones[bIdx], remainingTotalBoneWeight, isOnAnimatorIK);
                remainingTotalBoneWeight -= aimBones[bIdx].weight;
            }
        }

        /// <summary>
        /// Calculates the angle we need to rotate the character by horizontally to aim
        /// the held weapon towards aimTargetPosSmoothEnable or weaponAimPos.
        /// </summary>
        /// <returns></returns>
        private float AimAtTargetHorizontalAngle()
        {
            Vector3 characterWeaponPivotHorz = currentWorldPosition;
            Vector3 weaponOffsetHorz = weaponFirePosition - characterWeaponPivotHorz;
            Vector3 targetOffsetHorz = (isAimIKSmoothEnable ? aimTargetPosSmoothEnable : weaponAimPos) - characterWeaponPivotHorz;

            // Project vectors into horizontal ("flat") plane
            Vector3 weaponOffsetProjHorz = Vector3.ProjectOnPlane(weaponOffsetHorz, currentCharacterUp);
            Vector3 targetOffsetProjHorz = Vector3.ProjectOnPlane(targetOffsetHorz, currentCharacterUp);
            Vector3 weaponAimDirProjHorz = Vector3.ProjectOnPlane(weaponAimDirection, currentCharacterUp);
            // Calculate angles
            float weaponAngleOffsetHorz = Vector3.SignedAngle(weaponOffsetProjHorz, weaponAimDirProjHorz, currentCharacterUp);
            float handToAimAngleHorz = Vector3.SignedAngle(weaponOffsetProjHorz, targetOffsetProjHorz, currentCharacterUp);
            // Calculate horizontal delta angle
            float horzAngle = handToAimAngleHorz - weaponAngleOffsetHorz +
                (Mathf.Asin(weaponOffsetProjHorz.magnitude / targetOffsetProjHorz.magnitude * Mathf.Sin((180f - weaponAngleOffsetHorz) * Mathf.Deg2Rad)) * Mathf.Rad2Deg);           

            return horzAngle;
        }

        /// <summary>
        /// Calculates the angle we need to rotate by vertically to aim towards aimTargetPos.
        /// Pass in the cached bone transform rather than looking it up each frame with 
        /// defaultAnimator.GetBoneTransform(..).
        /// Typically, this will return values between -90 and +90 degrees.
        /// </summary>
        /// <param name="boneTransform"></param>
        /// <returns></returns>
        private float AimAtTargetPitchAngle(Transform boneTransform)
        {
            float pitchAngle = 0f;

            Vector3 characterWeaponPivotVert = boneTransform.position;

            // Useful data:
            //  weaponFireDirection (there direction the barrel is pointing)
            //  weaponFirePosition (basically the where the bullet is comes out the end of the barrel)
            //  lookTransform - the current character camera (first or third person)

            Vector3 weaponOffsetVert = weaponFirePosition - characterWeaponPivotVert;
            //Vector3 targetOffsetVert = aimTargetPos - characterWeaponPivotVert;
            Vector3 targetOffsetVert = weaponAimPos - characterWeaponPivotVert;

            // VERTICAL CALCULATIONS
            float dotProdWeaponToTarget = Vector3.Dot(targetOffsetVert, weaponAimDirection);
            // Find the normal for a plane containing the current direction to target and up directions
            Vector3 wpnPitchPlaneNormal = Vector3.Cross(targetOffsetVert, currentCharacterUp);
            // Project vectors into this plane (this is the pitch plane in which we desire to be aiming)
            Vector3 weaponOffsetProjPitchTarget = Vector3.ProjectOnPlane(dotProdWeaponToTarget > 0f ?
                weaponOffsetVert : -weaponOffsetVert, wpnPitchPlaneNormal);
            Vector3 targetOffsetProjPitchTarget = Vector3.ProjectOnPlane(dotProdWeaponToTarget > 0f ?
                targetOffsetVert : -targetOffsetVert, wpnPitchPlaneNormal);
            Vector3 weaponAimDirProjPitchTarget = Vector3.ProjectOnPlane(dotProdWeaponToTarget > 0f ?
                weaponAimDirection : -weaponAimDirection, wpnPitchPlaneNormal);

            // Calculate angles (measure them in our current aiming plane)
            float weaponAngleOffsetPitch = Vector3.SignedAngle(weaponOffsetProjPitchTarget, weaponAimDirProjPitchTarget, wpnPitchPlaneNormal);
            float handToAimAnglePitch = Vector3.SignedAngle(weaponOffsetProjPitchTarget, targetOffsetProjPitchTarget, wpnPitchPlaneNormal);
            // Calculate pitch delta angle
            pitchAngle = handToAimAnglePitch - weaponAngleOffsetPitch +
                (Mathf.Asin(weaponOffsetProjPitchTarget.magnitude / targetOffsetProjPitchTarget.magnitude * Mathf.Sin((180f - weaponAngleOffsetPitch) * Mathf.Deg2Rad)) * Mathf.Rad2Deg);

            //Debug.DrawRay(characterWeaponPivotVert, weaponOffsetProjPitchTarget, Color.blue);
            //Debug.DrawRay(characterWeaponPivotVert, targetOffsetProjPitchTarget, Color.yellow);
            //Debug.DrawRay(weaponFirePosition, weaponAimDirProjPitchTarget, Color.green);

            //Debug.DrawRay(characterWeaponPivotVert, wpnPitchPlaneNormal, Color.cyan);

            //Vector3 rotWFP = (Quaternion.Euler(-pitchAngle, 0f, 0f) * weaponOffsetVert) + characterWeaponPivotVert;
            //Vector3 rotWAD = Quaternion.Euler(-pitchAngle, 0f, 0f) * weaponAimDirection;
            //Debug.DrawRay(rotWFP, rotWAD * 20f, Color.magenta);

            //Debug.Break();

            return pitchAngle;
        }

        /// <summary>
        /// Check if first-person camera was being used for aiming while in third-person.
        /// </summary>
        /// <returns>True if was using first-person camera for third-person weapon aiming</returns>
        internal bool CheckDisableAimTPUsingFPCamera()
        {
            bool hasBeenDisabled = false;

            if (isAimTPUsingFPCameraEnabled)
            {
                if (!isThirdPerson)
                {
                    SetLookThirdPerson(lookThirdPersonCamera1, true);

                    hasBeenDisabled = true;
                }
                #if UNITY_EDITOR
                else
                {
                    // If isAimTPUsingFPCameraEnabled is true, the first-person camera should have been enabled. 
                    Debug.LogWarning("[ERROR] CheckDisableAimTPUsingFPCamera() isAimTPUsingFPCameraEnabled was true but was already in third-person. PLEASE REPORT. T:" + Time.time);
                }
                #endif
                
                isAimTPUsingFPCameraEnabled = false;
            }

            return hasBeenDisabled;
        }

        /// <summary>
        /// Check to see if we need to enable the first-person camera when aiming in third-person.
        /// See also S3DWeaponAnimSet (isAimTPUsingFPCamera)
        /// </summary>
        /// <returns>True if first-person camera has been enabled while in third-person weapon aiming</returns>
        internal bool CheckEnableAimTPUsingFPCamera()
        {
            isAimTPUsingFPCameraEnabled = false;

            if (isThirdPerson && isAimTPUsingFPCamera && lookFirstPersonCamera1 != null)
            {
                // Set to be enabled before calling SetLookFirstPerson(..) as that will
                // call SetLookCamera1(..), and eventually stickyWeapon.CharacterChangedCamera(oldCamera,..).
                // The later method uses isAimTPUsingFPCameraEnabled to check if it needs to avoid calling
                // stickyWeapon.EnableOrDisableAiming(..).
                isAimTPUsingFPCameraEnabled = true;
                SetLookFirstPerson(lookFirstPersonCamera1, lookFirstPersonTransform1, true);
            }

            return isAimTPUsingFPCameraEnabled;
        }

        /// <summary>
        /// Attempt to enable or disable Aim At Target (aka Aim IK).
        /// TODO - support smoothEnable and smoothDisable like HeadIK.
        /// </summary>
        /// <param name="isEnabled"></param>
        /// <param name="isSmooth"></param>
        private void EnableOrDisableAimIK(bool isEnabled, bool isSmooth)
        {
            // Is this attempting to change the current state?
            bool isChanging = isEnabled != isAimAtTargetEnabled;

            if (isEnabled)
            {
                #region Enable Aim IK
                if (isChanging)
                {
                    isAimIKSmoothDisable = false;

                    if (isFreeLookWhenWeaponHeld)
                    {
                        savedFreeLook = savedFreeLook || isFreeLook;
                        savedFollowHeadPosition = savedFollowHeadPosition || isLookCameraFollowHead;
                        savedFollowHeadPositionTP = savedFollowHeadPositionTP || isLookCameraFollowHeadTP;
                    }

                    SaveAndSetLockedReticleToCursor(false);

                    // Start rotate character toward where we free look position.
                    isAimIKSmoothEnable = isSmooth;
                    aimTurnAngle = 0f;
                    localTurnedY = 0f;
                    aimingTurnedAngleY = 0f;
                    prevCameraToAimTargetDistance = 1f;
                    prevCameraAimTarget = Vector3.one;
                    aimTargetPosSmoothEnable = aimTargetPos;

                    aimIKTurnDelayTimer = aimIKTurnDelay;

                    AimBoneReset();

                    // TESTING ONLY
//#if UNITY_EDITOR
//                    tempAimGO = S3DUtils.CreateSphere(aimTargetPos, 0.05f, false);
//#endif

                    if (isFreeLook)
                    {
                        // Default to look pitch (up-down)
                        aimingFreeLookX = currentLookRotation.eulerAngles.x;

                        // Default to look rotation (left-right)
                        aimingFreeLookY = currentLookRotation.eulerAngles.y;
                        aimingFreeLookHasTurned = 0f;

                        isAimIKFromFreeLook = true;

                        if (!isNPC)
                        {
                            // If Free Look is enabled AND the reticle is shown on the HUD, then we need to
                            // turn toward the reticle RATHER than where the camera is looking AS THEY MAY BE DIFFERENT.

                            StickyDisplayModule stickyDisplayModule = StickyDisplayModule.GetActiveDisplayModule();

                            if (stickyDisplayModule != null && stickyDisplayModule.IsDisplayShown && stickyDisplayModule.IsDisplayReticleShown)
                            {
                                // Get the reticle screen position in screen metrics (0,0 is bottom left). Cast as Vector3 with z = 0.
                                Vector3 reticleScreenPoint = stickyDisplayModule.DisplayReticleScreenPoint;

                                Ray ray = GetLookingAtRay(reticleScreenPoint);

                                StickyManager stickyManager = StickyManager.GetOrCreateManager(sceneHandle);

                                float maxRange = 100f;
                                LayerMask hitLayerMask = ~0;

                                // Assume right hand weapon takes priority if a weapon is held in each hand
                                if (isRightHandHoldingWeapon)
                                {
                                    maxRange = rightHandWeapon.MaxRange;
                                    hitLayerMask = rightHandWeapon.HitLayerMask;
                                }
                                else if (isLeftHandHoldingWeapon)
                                {
                                    maxRange = leftHandWeapon.MaxRange;
                                    hitLayerMask = leftHandWeapon.HitLayerMask;
                                }

                                // Where is the character looking?
                                Vector3 _aimAtWSPos = stickyManager.GetHitOrMaxPoint(ray.origin, ray.direction, maxRange, hitLayerMask, StickyID, true);

                                // Get the local character direction to the target object (if any)
                                Vector3 _aimDirLS = S3DMath.Normalise(GetLocalPosition(ray.origin), GetLocalPosition(_aimAtWSPos));

                                // Project direction to the reticle onto the characters x-z plane
                                Vector3 _aimFwd = Vector3.ProjectOnPlane(_aimDirLS, Vector3.up);

                                // Calc just the y-axis (left-right) local component
                                aimingFreeLookY = Vector3.SignedAngle(Vector3.forward, _aimFwd, Vector3.up);

                                /// NOTE: aimingFreeLookX may not be accurate because the aim (spine) bones pitch
                                /// up and down with first person camera does NOT calculate where the bones are aiming.
                                /// It does a more simplistic +/- angle when the mouse is moved up or down the screen.
                                /// It attempts to sync the spine bones with the camera pitch.
                                /// See AimBonesFPS(..) and AimBoneWithPitch(..).

                                // Project the direction to the reticle onto the character y-z plane
                                Vector3 _aimRight = Vector3.ProjectOnPlane(_aimDirLS, Vector3.right);

                                // Calc just the x-axis (up-down) pitch local component
                                aimingFreeLookX = Vector3.SignedAngle(Vector3.forward, _aimRight, Vector3.right);
                            }

                            // How long, in seconds, should it take to rotate the character to face the aim position?
                            // Balance the turn and pitch speed.
                            aimingFreeLookDuration = Mathf.Sqrt((aimingFreeLookY * aimingFreeLookY) + (aimingFreeLookX * aimingFreeLookX)) / aimIkTurnRotationRate;
                        }

                        aimingFreeLookXStart = currentLookRotation.x;
                        aimingFreeLookXTimer = 0f;
                        aimingFreeLookYTimer = 0f;

                        // Turn off free look when aiming. This may need revising with lookVR as that
                        // currently requires isFreeLook to be enabled (but shouldn't require aiming).
                        SetFreeLook(false);
                    }
                    else
                    {
                        isAimIKFromFreeLook = false;
                        aimingFreeLookX = 0f;
                        aimingFreeLookY = 0f;
                    }

                    if (!isLookCameraFollowHead) { SetLookFollowHead(true); }
                    if (!isLookCameraFollowHeadTP) { SetLookFollowHeadTP(true); }
                }

                isAimAtTargetEnabled = isAnimateEnabled;
                #endregion
            }
            // Disable AimIK
            else
            {
                // TESTING ONLY
//#if UNITY_EDITOR
//                if (tempAimGO != null) { DestroyImmediate(tempAimGO); }
//#endif

                #region Disable Aim IK
                if (isChanging)
                {
                    isAimIKSmoothDisable = isSmooth;

                    if (isThirdPerson || isAimTPUsingFPCameraEnabled)
                    {
                        orbitHorizontalAngle = 0f;
                        orbitVerticalAngle = 0f;
                    }

                    // Restore Free Look (if required).
                    if (isFreeLookWhenWeaponHeld)
                    {
                        CheckRestoreFreeLook();
                        CheckRestoreFollowHead();
                        CheckRestoreFollowHeadTP();
                    }

                    SetLookFollowHeadTP(false);

                    // Not sure if this causes issues or not (needs more testing)
                    CheckRestoreLockedReticleToCursor();

                    aimTurnAngle = 0f;
                    localTurnedY = 0f;
                    aimingTurnedAngleY = 0;
                    aimIKTurnDelayTimer = 0f;
                }

                isAimIKSmoothEnable = false;
                isAimAtTargetEnabled = false;
                #endregion
            }
        }

        #endregion

        #region Private and Internal Methods - Animate Foot IK

#if UNITY_EDITOR
        /// <summary>
        /// [INTERNAL ONLY]
        /// This is a editor hack to get round an issue enabling and disabling
        /// FootIK in the editor at runtime.
        /// </summary>
        public void EditorInternalOnlyFootIK()
        {
            isFootIK = !isFootIK;
        }
#endif

        /// <summary>
        /// Turn FootIK on or off.
        /// forceChange should generally only be set to true when the controller is first initialised
        /// </summary>
        /// <param name="isEnabled"></param>
        /// <param name="forceChange"></param>
        private void EnableOrDisableFootIK(bool isEnabled, bool forceChange = false)
        {
            if (leftFootData == null) { leftFootData = new S3DFootData() { foot = AvatarIKGoal.LeftFoot }; }
            if (rightFootData == null) { rightFootData = new S3DFootData() { foot = AvatarIKGoal.RightFoot }; }

            // is it changing?
            if (forceChange || isFootIK != isEnabled)
            {
                if (isEnabled)
                {
                    if (defaultAnimator != null)
                    {
                        leftFootTrfm = defaultAnimator.GetBoneTransform(HumanBodyBones.LeftFoot);
                        rightFootTrfm = defaultAnimator.GetBoneTransform(HumanBodyBones.RightFoot);

                        // Caching left/rightFeetBottomHeight as these shouldn't change
                        leftFootData.footToSoleDist = defaultAnimator.leftFeetBottomHeight;
                        rightFootData.footToSoleDist = defaultAnimator.rightFeetBottomHeight;

                        // Cache start rotation of the feet
                        if (forceChange)
                        {
                            leftFootData.startFootRotLS = leftFootTrfm != null ? GetLocalRotation(leftFootTrfm.rotation) : Quaternion.identity;
                            rightFootData.startFootRotLS = rightFootTrfm != null ? GetLocalRotation(rightFootTrfm.rotation) : Quaternion.identity;
                        }

#if UNITY_EDITOR
                        if (leftFootTrfm == null)
                        {
                            Debug.LogWarning("StickyControlModule Foot IK - could not find the Left Foot. Is it exposed in the model Rig? If Optimise Game Objects is enabled, make sure the left foot is enabled.");
                        }

                        if (rightFootTrfm == null)
                        {
                            Debug.LogWarning("StickyControlModule Foot IK - could not find the Right Foot. Is it exposed in the model Rig? If Optimise Game Objects is enabled, make sure the right foot is enabled.");
                        }
#endif
                    }
#if UNITY_EDITOR
                    else { Debug.LogWarning("StickyControlModule Foot IK - could not find the Animator component."); }
#endif
                }
                // Only change when isFootIK is being turned off if it was previously on.
                else if (isFootIK != isEnabled)
                {
                    // Cache start rotation of the feet
                    if (forceChange)
                    {
                        if (defaultAnimator != null)
                        {
                            leftFootTrfm = defaultAnimator.GetBoneTransform(HumanBodyBones.LeftFoot);
                            rightFootTrfm = defaultAnimator.GetBoneTransform(HumanBodyBones.RightFoot);

                            leftFootData.startFootRotLS = leftFootTrfm != null ? GetLocalRotation(leftFootTrfm.rotation) : Quaternion.identity;
                            rightFootData.startFootRotLS = rightFootTrfm != null ? GetLocalRotation(rightFootTrfm.rotation) : Quaternion.identity;
                        }
                    }

                    // Restore 
                    leftFootTrfm = null;
                    rightFootTrfm = null;
                }
            }

            // Reset
            if (leftFootData != null)
            {
                leftFootData.currentFootIKPos = Vector3.zero;
                leftFootData.currentFootIKRot = Quaternion.identity;
                leftFootData.prevFootIKPos = Vector3.zero;
                leftFootData.prevFootIKRot = Quaternion.identity;
                leftFootData.prevFootIKRotLS = Vector3.zero;
            }

            if (rightFootData != null)
            {
                rightFootData.currentFootIKPos = Vector3.zero;
                rightFootData.currentFootIKRot = Quaternion.identity;
                rightFootData.prevFootIKPos = Vector3.zero;
                rightFootData.prevFootIKRot = Quaternion.identity;
                rightFootData.prevFootIKRotLS = Vector3.zero;
            }

            currentFootIKOffsetY = 0f;
            prevFootIKOffsetY = 0f;

            isFootIK = isEnabled;
            IKCheckEnabler();
        }

        /// <summary>
        /// Calculate the local y-axis movement of the body required to ensure
        /// the leg of the lower foot is fully extended when that foot is on the ground.
        /// If required, the animation model is moved downward from the actual worldspace
        /// position of the character. This avoids having to move the capsule collider up
        /// and resizing it, when Foot IK is enabled (this leads to other issues like stepping
        /// code not working correctly and the character sometimes falling through the floor.
        /// See also FootIKSetBodyY(..)
        /// NOTE: Currently won't work with crouch.
        /// ISSUE: Seems to always bend knees from idle anim on say Amy or Kate. Does not change
        /// hip rotation as earlier suspected.
        /// </summary
        /// <param name="leftFootData"></param>
        /// <param name="rightFootData"></param>
        /// <param name="deltaTime"></param>
        /// <param name="footIKBodyOffsetY"></param>
        private void FootIKCalcBodyY(S3DFootData leftFootData, S3DFootData rightFootData, float deltaTime, ref float footIKBodyOffsetY)
        {
            if (leftFootData.currentFootIKPos != Vector3.zero && rightFootData.currentFootIKPos != Vector3.zero)
            {
                Vector3 _bottom = GetBottom(currentWorldPosition, currentCharacterUp);

                // Convert to local space
                Quaternion invRot = Quaternion.Inverse(currentWorldRotation);
                Vector3 leftFootLocalPos = invRot * (leftFootData.currentFootIKPos - currentWorldPosition);
                Vector3 rightFootLocalPos = invRot * (rightFootData.currentFootIKPos - currentWorldPosition);
                Vector3 _bottomLocalPos = invRot * (_bottom - currentWorldPosition);

                // Determine if left or right foot is lowest in local space
                float leftOffsetY = leftFootLocalPos.y - _bottomLocalPos.y - leftFootData.footToSoleDist;
                float rightOffsetY = rightFootLocalPos.y - _bottomLocalPos.y - rightFootData.footToSoleDist;
                float lowestFootSoleOffsetY = leftOffsetY < rightOffsetY ? leftOffsetY : rightOffsetY;

                // Calc distance between lowest foot and bottom of character on local y-axis
                float footIKTargetDeltaY = lowestFootSoleOffsetY < 0f ? leftOffsetY < rightOffsetY ? leftOffsetY : rightOffsetY : 0f;

                // If we need to move the animation up, it means the legs were slightly bent already.
                // So, instead move the feet up.
                if (footIKTargetDeltaY > 0f)
                {
                    leftFootLocalPos.y += footIKTargetDeltaY;
                    rightFootLocalPos.y += footIKTargetDeltaY;
                    footIKTargetDeltaY = 0f;
                }

                if (footIKBodyOffsetY != footIKTargetDeltaY)
                {
                    footIKBodyOffsetY = Mathf.Lerp(footIKBodyOffsetY, footIKTargetDeltaY, footIKBodyMoveSpeedY * Time.deltaTime);
                }
            }
            else if (footIKBodyOffsetY != 0f)
            {
                // Lerp back to 0
                footIKBodyOffsetY = Mathf.Lerp(footIKBodyOffsetY, 0f, footIKBodyMoveSpeedY * Time.deltaTime);
            }
            else { footIKBodyOffsetY = 0f; }
        }

        /// <summary>
        /// Modify the character animation body position on the local y-axis.
        /// See also FootIKCalcBodyY()
        /// </summary>
        private void FootIKSetBodyY(float offsetY)
        {
            if (offsetY < 0f)
            {
                defaultAnimator.bodyPosition += currentCharacterUp * offsetY;
            }
        }

        /// <summary>
        /// Check to see if the toes are clipping below the ground. If so, raise the toes by rotating the foot.
        /// </summary>
        /// <param name="s3dFootData"></param>
        /// <param name="isLeftFoot"></param>
        private void FootIKCheckToeClipping(S3DFootData s3dFootData, bool isLeftFoot)
        {
            if (footIKToeDistance > 0.01f && isGrounded && (!isJetPackAvailable || !isJetPackEnabled) && ((isLeftFoot && leftFootTrfm != null) || (!isLeftFoot && rightFootTrfm != null)))
            {
                // Get the relative forward direction of the foot
                Quaternion currentFootRotWS = isLeftFoot ? leftFootTrfm.rotation : rightFootTrfm.rotation;
                Vector3 currentFootPos = isLeftFoot ? leftFootTrfm.position : rightFootTrfm.position;
                float deltaAngleX = S3DMath.S3DDeltaAngle(s3dFootData.startFootRotLS.eulerAngles.x, GetLocalRotation(currentFootRotWS).eulerAngles.x);
                Vector3 relFootDirWS = (currentWorldRotation * Quaternion.AngleAxis(-deltaAngleX, Vector3.right)) * Vector3.forward;

                Vector3 origin = s3dFootData.currentFootIKPos + (currentCharacterUp * maxStepOffset) + (relFootDirWS * footIKToeDistance);
                //origin += relFootDirWS * footIKToeDistance;

                // Start the ray maxStepOffset above the edge of the toes (at the front of the foot)
                Ray footRay = new Ray(origin, currentCharacterUp * -1f);
                RaycastHit footHit;

                // Cast a ray from above the end of the toes to the sole of the feet immediately below the end of the toes
                if (Physics.Raycast(footRay, out footHit, s3dFootData.footToSoleDist + maxStepOffset, collisionLayerMask, QueryTriggerInteraction.Ignore))
                {
                    // The toes are most likely clipping below the ground

                    // WS Direction from bottom of foot to ground hit point at the end of the toes
                    Vector3 footBaseWS = currentFootPos - (currentCharacterUp * s3dFootData.footToSoleDist);
                    Vector3 hitDirWS = footHit.point - footBaseWS;

                    // Get the local rotation from the sole under the foot bone, to the tip of the toes where they clip into the ground
                    Quaternion hitRotLS = Quaternion.LookRotation(S3DMath.Normalise(GetLocalPosition(footHit.point) - GetLocalPosition(footBaseWS)));

                    // Get the angle required to lift the toes to the top of the ground by rotating the foot bone
                    float footRotXLS = S3DMath.S3DDeltaAngle(hitRotLS.eulerAngles.x, GetLocalRotation(Quaternion.LookRotation(relFootDirWS)).eulerAngles.x);

                    // Apply the rotation to the foot bone
                    if (isLeftFoot) { leftFootTrfm.rotation *= Quaternion.AngleAxis(-footRotXLS, Vector3.right); }
                    else { rightFootTrfm.rotation *= Quaternion.AngleAxis(-footRotXLS, Vector3.right); }

                    //Debug.Log("[DEBUG] ToeClipping startFootX " + s3dFootData.startFootRotLS.eulerAngles.x + " currFootRot: " + GetLocalRotation(currentFootRotWS).eulerAngles.x + " deltaAngleX:" + deltaAngleX + " footRotXLS: " + footRotXLS);

                    //DebugExtension.DebugArrow(footBaseWS, hitDirWS, Color.yellow);
                    //DebugExtension.DebugArrow(footBaseWS, relFootDirWS, Color.blue);
                }
            }
        }

        /// <summary>
        /// Get the IK position and rotation of a foot on the ground in world space.
        /// </summary>
        /// <param name="s3dFootData"></param>
        /// <param name="hashCodeFootIKWeightParameter"></param>
        /// <param name="deltaTime"></param>
        private void FootIKGetPosition(S3DFootData s3dFootData, int hashCodeFootIKWeightParameter, float deltaTime)
        {
            if (isGrounded && (!isJetPackAvailable || !isJetPackEnabled))
            {
                RaycastHit footHit;
                bool isToesClipping = false;
                Vector3 animFootPosWS = defaultAnimator.GetIKPosition(s3dFootData.foot);

                // Start the ray maxStepOffset above the foot transform
                Ray footRay = new Ray(defaultAnimator.GetIKPosition(s3dFootData.foot) + (currentCharacterUp * maxStepOffset), currentCharacterUp * -1f);

                // If there is no weight parameter, set the weights to 1.0 (which will always move the feet the full distance).
                float footIKWeight = hashCodeFootIKWeightParameter == 0 ? 1f : defaultAnimator.GetFloat(hashCodeFootIKWeightParameter);

                float footIKRotWeight = footIKPositionOnly ? 0f : footIKWeight;

                // Ignore trigger colliders
                if (Physics.Raycast(footRay, out footHit, s3dFootData.footToSoleDist + maxStepOffset + maxStepOffset, collisionLayerMask, QueryTriggerInteraction.Ignore))
                {
                    // Add distance from ground to the foot bone (transform) in world space
                    s3dFootData.currentFootIKPos = footHit.point + (currentCharacterUp * s3dFootData.footToSoleDist);

                    if (footIKWeight < 0.98f)
                    {
                        // If the foot is off the ground in the animation but is clipping through the ground,
                        // due to an uphill slope, attempt to move the foot up accordingly.
                        Vector3 footPosLS = GetLocalPosition(animFootPosWS);
                        Vector3 targetPosLS = GetLocalPosition(s3dFootData.currentFootIKPos);
                        float groundFootY = targetPosLS.y - footPosLS.y;

                        // If the foot is below the ground while the foot is being lifted off the ground by the
                        // animation (reflected in the curve added to the animation clip in the Unity inspector),
                        // force the weight back to 1 so that the foot doesn't pentrate the ground while walking up a slope.
                        if (groundFootY > 0.001f)
                        {
                            footIKWeight = 1f;
                        }
                        else if (!footIKPositionOnly && groundFootY < -0.001f && footIKToeDistance > 0.01f)
                        {
                            // Foot is above the ground, but are the toes?
                            // NOTE: prob should use the forward direction of foot in local character space,
                            // but that's more effort...
                            footRay.origin += currentCharacterFwd * footIKToeDistance;

                            // Check if the ground is above the bottom of the end of the toes
                            // Although the foot is being lifted off the ground in the animation,
                            // the toes could still clip into the ground if moving up, or strafing a slope.
                            if (Physics.Raycast(footRay, out footHit, s3dFootData.footToSoleDist + maxStepOffset, collisionLayerMask, QueryTriggerInteraction.Ignore))
                            {
                                footIKRotWeight = 1f;
                                isToesClipping = true;
                            }
                        }
                    }

                    defaultAnimator.SetIKPositionWeight(s3dFootData.foot, footIKWeight);

                    // NOTE: The t-pose foot bone rotation angles may not match the IK rotation from the animation.
                    // In t-pose, the bones are likely to have been zero'd out (typically recommended to point forward)
                    // To get the actual bone rotation, you'd need to use the bone transform which isn't applied until
                    // just before LateUpdate() starts and the animation is applied.

                    Quaternion invWSRot = Quaternion.Inverse(currentWorldRotation);
                    // Get the existing foot rotation from the animation
                    Quaternion footAnimRotWS = defaultAnimator.GetIKRotation(s3dFootData.foot);
                    Vector3 footAnimRotLS = (invWSRot * footAnimRotWS).eulerAngles;
                    Vector3 footRotLS;

                    if (s3dFootData.prevFootIKRotLS == Vector3.zero)
                    {
                        s3dFootData.prevFootIKRotLS = footAnimRotLS;
                    }

                    #region Calc Foot Rotation
                    if (!footIKPositionOnly && footIKRotWeight > 0f)
                    {
                        // Limit Foot IK roll angle. How far can the foot roll inward or outward?
                        Quaternion footRotTarget = Quaternion.FromToRotation(currentCharacterUp, footHit.normal) * currentWorldRotation;
                        // Convert it to local space Euler rotation angles
                        footRotLS = (invWSRot * footRotTarget).eulerAngles;

                        // Check the slope in the forward/backward local directions to the character.
                        // If the ground is almost flat, attempt to keep the foot pitch from the animation.
                        // The foot toes are likely to clip through the ground, which will be corrected in
                        // LateUpdate. See FootIKCheckToeClipping(..)
                        if (!isToesClipping && footIKSlopeTolerance != 0f && (footRotLS.x < footIKSlopeTolerance || footRotLS.x > 360f - footIKSlopeTolerance))
                        {
                            if (footIKToeDistance > 0.01f)
                            {
                                // Keep the pitch up or down of the feet from the animation
                                footRotLS.x = footAnimRotLS.x;
                            }
                        }
                        // Pitch is rotation around the local x-axis. Clamp pitch to +/- footIKMaxPitchZ
                        // Limit rotation forward or back (z-axis)
                        else if (footRotLS.x < 180f)
                        {
                            if (footRotLS.x > footIKMaxPitchZ) { footRotLS.x = footIKMaxPitchZ; }
                        }
                        else
                        {
                            if (360f - footRotLS.x > footIKMaxPitchZ) { footRotLS.x = 360f - footIKMaxPitchZ; }
                        }

                        // Keep the forward direction of the feet from the animation
                        footRotLS.y = footAnimRotLS.y;

                        // Local z-axis is inner and outer roll of the foot
                        if (footIKSlopeTolerance != 0f && (footRotLS.z < footIKSlopeTolerance || footRotLS.z > 360f - footIKSlopeTolerance))
                        {
                            // Keep the left or right roll of the feet from the animation
                            footRotLS.z = footAnimRotLS.z;

                            // If also keeping pitch from animation, then set rotation weight to 0
                            // as we don't need to apply IK rotation.
                            if (footRotLS.x == footAnimRotLS.x) { footIKRotWeight = 0f; }
                        }
                        else if (s3dFootData.foot == AvatarIKGoal.RightFoot)
                        {
                            // 0-180 rotations are outer for right foot
                            if (footRotLS.z < 180f)
                            {
                                if (footRotLS.z > footIKMaxOutwardRotationX) { footRotLS.z = footIKMaxOutwardRotationX; }
                            }
                            // 360 - 180 inward roll for right foot
                            else if (360f - footRotLS.z > footIKMaxInwardRotationX)
                            {
                                footRotLS.z = 360f - footIKMaxInwardRotationX;
                            }
                        }
                        // Left foot roll
                        else
                        {
                            // 0-180 rotations are inner for left foot
                            if (footRotLS.z < 180f)
                            {
                                if (footRotLS.z > footIKMaxInwardRotationX) { footRotLS.z = footIKMaxInwardRotationX; }
                            }
                            // 360 - 180 outward roll for left foot
                            else if (360f - footRotLS.z > footIKMaxOutwardRotationX)
                            {
                                footRotLS.z = 360f - footIKMaxOutwardRotationX;
                            }
                        }

                        if (footIKRotWeight > 0f && footIKSlopeReactRate > 0f)
                        {
                            float t = footIKSlopeReactRate * deltaTime;

                            if (t > 1f) { t = 1f; }

                            // FootIK slope responsiveness
                            footRotLS.x = S3DMath.S3DLerpEuler(s3dFootData.prevFootIKRotLS.x, footRotLS.x, t);
                            footRotLS.z = S3DMath.S3DLerpEuler(s3dFootData.prevFootIKRotLS.z, footRotLS.z, t);

                            //Debug.Log("[DEBUG] prev: " + s3dFootData.prevFootIKRotLS.x + " target: " + footRotLS.x);
                        }

                        // SetIKRotation uses the local space of the character. We can ignore the starting transform rotation
                        // of the foot, as IK uses Quaterinion.identity to indicate no rotation from the t-pose (or start model pose).
                        s3dFootData.currentFootIKRot = GetWorldRotation(Quaternion.Euler(footRotLS));
                    }
                    else
                    {
                        // Position only, so return the current foot rotation
                        s3dFootData.currentFootIKRot = defaultAnimator.GetIKRotation(s3dFootData.foot);
                        footRotLS = footAnimRotLS;
                    }

                    s3dFootData.prevFootIKRotLS = footRotLS;

                    #endregion

                    defaultAnimator.SetIKRotationWeight(s3dFootData.foot, footIKRotWeight);

                }
                else
                {
                    // TODO - if foot cannot reach the ground, stretch leg out to max
                    s3dFootData.currentFootIKPos = defaultAnimator.GetIKPosition(s3dFootData.foot) - (currentCharacterUp * maxStepOffset);
                    //s3dFootData.currentFootIKPos = s3dFootData.lastKnownFootPos - (currentCharacterUp * maxStepOffset);

                    defaultAnimator.SetIKPositionWeight(s3dFootData.foot, footIKWeight);
                    s3dFootData.currentFootIKPos = Vector3.zero;

                    // If not grounded, foot IK rotation should have no effect
                    defaultAnimator.SetIKRotationWeight(s3dFootData.foot, 0f);
                    s3dFootData.currentFootIKRot = Quaternion.identity;
                }
            }
            else
            {
                // If not grounded or in jetpack mode, foot IK should have no effect
                defaultAnimator.SetIKPositionWeight(s3dFootData.foot, 0f);
                defaultAnimator.SetIKRotationWeight(s3dFootData.foot, 0f);
                s3dFootData.currentFootIKPos = Vector3.zero;
                s3dFootData.currentFootIKRot = Quaternion.identity;
            }
        }

        /// <summary>
        /// Set the position and rotation of the foot in world space
        /// </summary>
        /// <param name="foot"></param>
        /// <param name="footIKPos"></param>
        /// <param name="footIKRot"></param>
        private void FootIKSetPosition(AvatarIKGoal foot, Vector3 footIKPos, Quaternion footIKRot)
        {
            if (footIKPos != Vector3.zero)
            {
                defaultAnimator.SetIKPosition(foot, footIKPos);
                if (!footIKPositionOnly) { defaultAnimator.SetIKRotation(foot, footIKRot); }
            }
        }

        /// <summary>
        /// Update the foot actual positions during LateUpdate as they may have
        /// been modified during OnAnimateIK or maybe even OnAnimateMove.
        /// </summary>
        /// <param name="s3dFootData"></param>
        /// <param name="isLeftFoot"></param>
        private void UpdateFootData(S3DFootData s3dFootData, bool isLeftFoot)
        {
            if (isLeftFoot)
            {
                if (leftFootTrfm != null)
                {
                    s3dFootData.lastKnownFootPos = leftFootTrfm.position;
                    s3dFootData.lastKnownFootRot = leftFootTrfm.rotation;
                }
                else
                {
                    s3dFootData.lastKnownFootPos = Vector3.zero;
                    s3dFootData.lastKnownFootRot = Quaternion.identity;
                }
            }
            else
            {
                if (rightFootTrfm != null)
                {
                    s3dFootData.lastKnownFootPos = rightFootTrfm.position;
                    s3dFootData.lastKnownFootRot = rightFootTrfm.rotation;
                }
                else
                {
                    s3dFootData.lastKnownFootPos = Vector3.zero;
                    s3dFootData.lastKnownFootRot = Quaternion.identity;
                }
            }
        }

        #endregion

        #region Private and Internal Methods - Animate Head IK

        /// <summary>
        /// If headIKLookAtInteractive is enabled, check if we need to be lookng at an interactive-enabled
        /// object, looking where the mouse cursor is, looking at another target, or looking straight ahead.
        /// </summary>
        private void CheckHeadIKLookAtInteractive()
        {
            if (isAnimateEnabled && isHeadIK && headIKLookAtInteractive && !isHeadIKSmoothDisable)
            {
                // Is the character idle?
                if (!isClimbing && currentLocalVelocity.sqrMagnitude < moveIdleThreshold && lookingAtPoint != Vector3.zero)
                {
                    if (headTargetTrfm == null)
                    {
                        SetHeadIKTarget(lookingAtPoint);
                    }

                }
                // Look straight ahead if no (other) head IK target
                else if (headTargetTrfm == null)
                {
                    // Use the character forward rather than the head forward as the head bone
                    // may not be aligned with character Up direction.
                    SetHeadIKTarget(headTrfm.position + currentCharacterFwd);
                }
            }
        }

#if UNITY_EDITOR
        /// <summary>
        /// [INTERNAL ONLY]
        /// This is a editor hack to get round an issue enabling and disabling
        /// HeadIK in the editor at runtime.
        /// </summary>
        public void EditorInternalOnlyHeadIK()
        {
            isHeadIK = !isHeadIK;
        }
#endif

        /// <summary>
        /// Attempt to turn HeadIK on or off.
        /// forceChange should generally only be set to true when the controller is first initialised
        /// </summary>
        /// <param name="isEnabled"></param>
        /// <param name="forceChange"></param>
        /// <param name="isSmooth"></param>
        private void EnableOrDisableHeadIK(bool isEnabled, bool forceChange = false, bool isSmooth = false)
        {
            if (forceChange || isHeadIK != isEnabled)
            {
                if (isEnabled)
                {
                    isHeadIKSmoothDisable = false;

                    isHeadIKSmoothEnable = isSmooth;
                    currentMaxHeadIKWeight = isSmooth ? 0f : 1f;

                    if (defaultAnimator != null)
                    {
                        headTrfm = defaultAnimator.GetBoneTransform(HumanBodyBones.Head);

                        if (headTrfm != null)
                        {
                            // Check a layer has IK_Pass enabled
                            // TODO - find a way of checking if IK_Pass is set on the correct layer
                            for (int lyIdx = 0; lyIdx < defaultAnimator.layerCount; lyIdx++)
                            {
                                //var animLayer = defaultAnimator.lay
                            }
                        }
#if UNITY_EDITOR
                        else
                        {
                            isEnabled = false;
                            Debug.LogWarning("StickyControlModule Head IK - could not find the Head. Is it exposed in the model Rig? If Optimise Game Objects is enabled, you will need to enable that bone.");
                        }
#endif
                    }
#if UNITY_EDITOR
                    else { Debug.LogWarning("StickyControlModule Head IK - could not find the Animator component."); }
#endif
                }
                // Only change when isHeadIK is being turned off if it was previously on.
                else if (isHeadIK != isEnabled)
                {
                    isHeadIKSmoothEnable = false;

                    if (isSmooth)
                    {
                        isHeadIKSmoothDisable = true;
                    }
                    else
                    {
                        isHeadIKSmoothDisable = false;
                        headTrfm = null;
                        isHeadIK = false;
                    }
                }
            }

            if (isEnabled || !isSmooth)
            {
                isHeadIK = isEnabled;
                IKCheckEnabler();
            }
        }

        /// <summary>
        /// Get the world space position the head should be looking at.
        /// </summary>
        /// <param name="targetPos"></param>
        /// <param name="prevHeadIKPos"></param>
        /// <param name="maxHeadIKWeight"></param>
        /// <param name="prevHeadIKRotAngles"></param>
        /// <param name="headIKPos"></param>
        /// <param name="headIKVelo"></param>
        /// <param name="headIKDeltaVelo"></param>
        private void HeadIKGetPosition(Vector3 targetPos, Vector3 prevHeadIKPos, float maxHeadIKWeight, ref Vector3 prevHeadIKRotAngles, ref Vector3 headIKPos, ref float headIKVelo, ref float headIKDeltaVelo)
        {
            if ((!isClimbing || headIKWhenClimbing) && targetPos != Vector3.zero)
            {
                // NOTE: Angle constraints. In early testing it appears that the max up/down/left/right
                // angles permitted by SetLookAtPosition are 90 degrees.

                Vector3 headPos = headTrfm.position;
                Vector3 directionToTarget = (targetPos - headPos).normalized;

                float dotProdToTarget = Vector3.Dot(directionToTarget, currentCharacterFwd);

                // Project forwards direction into some plane containing the direction to target and up directions
                Vector3 projectedPitchVector = Vector3.ProjectOnPlane(dotProdToTarget > 0f ? currentCharacterFwd : -currentCharacterFwd, Vector3.Cross(directionToTarget, currentCharacterUp));
                // Project direction to target into "flat" plane
                Vector3 projectedHorzVector = Vector3.ProjectOnPlane(directionToTarget, currentCharacterUp);

                // Vertical angle +ve is look up, -ve is look down
                float pitchAngle = Vector3.SignedAngle(directionToTarget, projectedPitchVector, dotProdToTarget > 0f ? currentCharacterRight : -currentCharacterRight);
                // Make horizontal angle +ve to the right, -ve to the left
                float horzAngle = Vector3.SignedAngle(currentCharacterFwd, projectedHorzVector, currentCharacterUp);

                // Is the target behind the character. i.e. the angle < -180 or > 180 degrees
                if (dotProdToTarget < 0f)
                {
                    if (headIKConsiderBehind)
                    {
                        // Set to max horizontal angle
                        horzAngle = horzAngle < 0f ? -headIKLookLeftLimit : headIKLookRightLimit;
                    }
                    else { horzAngle = 0f; }
                }
                else
                {
                    // Target is in front of the character, so check it is with the limits.
                    if (horzAngle < -headIKLookLeftLimit) { horzAngle = -headIKLookLeftLimit; }
                    else if (horzAngle > headIKLookRightLimit) { horzAngle = headIKLookRightLimit; }
                }

                // If in-front, or consider targets behind the player
                if (dotProdToTarget >= 0f || headIKConsiderBehind)
                {
                    if (pitchAngle < -90f) { pitchAngle += 90f; }
                    else if (pitchAngle > 90f) { pitchAngle -= 90f; }

                    if (pitchAngle > headIKLookUpLimit) { pitchAngle = headIKLookUpLimit; }
                    else if (pitchAngle < -headIKLookDownLimit) { pitchAngle = -headIKLookDownLimit; }
                }
                else { pitchAngle = 0f; }

                // When the character or target is moving quickly the head cannot rotate quickly enough from the previous world space head position.
                if (headIKAdjustForVelocity)
                {
                    // 1.0.6 and earlier behaviour with Adjust for Velocity
                    // Head bone position + (world space  rotation * 1 in fwd direction)
                    Vector3 desiredTargetPos = headPos + (currentWorldRotation * (Quaternion.Euler(-pitchAngle, horzAngle, 0f) * Vector3.forward));

                    // We "could" switch everything to local space but then we'd still have the issue of the head
                    // not being able to catch up to the moving object as it moved away (unless it was moving with the character).

                    // Use the difference between the target's moving velo and the character velocity
                    // Apply some factor to the delta. For now 0.25 seems ok. Maybe this should be adjustable
                    float deltaMagnitude = ((desiredTargetPos - prevHeadIKPos) - rBody.velocity).magnitude * 0.25f;

                    // This "appears" to help. Changing the smoothTime variable can also help. Prob needs some more fine tuning
                    headIKDeltaVelo = Mathf.SmoothDamp(headIKDeltaVelo, deltaMagnitude, ref headIKVelo, 0.1f, headIKMoveMaxSpeed, Time.deltaTime);

                    if (headIKDeltaVelo > 0.02f)
                    {
                        // Add the delta movement to the head IK move speed
                        float adjMoveSpeed = headIKMoveMaxSpeed * Time.deltaTime + headIKDeltaVelo;

                        headIKPos = Vector3.MoveTowards(prevHeadIKPos, desiredTargetPos, adjMoveSpeed);
                    }
                    else
                    {
                        headIKPos = Vector3.MoveTowards(prevHeadIKPos, desiredTargetPos, headIKMoveMaxSpeed * Time.deltaTime);
                    }

                    if (headIKMoveDamping > 0f)
                    {
                        headIKPos = S3DMath.DampValue(prevHeadIKPos, headIKPos, Time.deltaTime, headIKMoveDamping);
                    }
                }
                else
                {
                    if (headIKMoveDamping > 0f)
                    {
                        pitchAngle = S3DMath.DampValue(prevHeadIKRotAngles.x, pitchAngle, Time.deltaTime, headIKMoveDamping);
                        horzAngle = S3DMath.DampValue(prevHeadIKRotAngles.y, horzAngle, Time.deltaTime, headIKMoveDamping);
                    }

                    pitchAngle = Mathf.MoveTowardsAngle(prevHeadIKRotAngles.x, pitchAngle, 90f * headIKMoveMaxSpeed * Time.deltaTime);
                    horzAngle = Mathf.MoveTowardsAngle(prevHeadIKRotAngles.y, horzAngle, 90f * headIKMoveMaxSpeed * Time.deltaTime);

                    // Head bone position + (world space  rotation * 1 in fwd direction)
                    headIKPos = headPos + (currentWorldRotation * (Quaternion.Euler(new Vector3(-pitchAngle, horzAngle, 0f)) * Vector3.forward));

                    prevHeadIKRotAngles.x = pitchAngle;
                    prevHeadIKRotAngles.y = horzAngle;
                }

                // We could set the clampWeight to 0.5 when headIKConsiderBehind is false but we have already set angles to 0 above.
                defaultAnimator.SetLookAtWeight(maxHeadIKWeight, headIKBodyWeight, headIKHeadWeight, headIKEyesWeight);
            }
            else
            {
                defaultAnimator.SetLookAtWeight(0f, 0f, 0f, 0f);
                //headIKPos = headTrfm.position + headTrfm.forward;
                headIKPos = headTrfm.position + currentCharacterFwd;

                prevHeadIKRotAngles = Vector3.zero;
            }
        }

        /// <summary>
        /// Get the character local space rotation angles, in degrees, of the head bone, relative
        /// to the character forward direction.
        /// This should be called from LateUpdate() after OnAnimatorIK(..) sets the head bone rotation.
        /// [INCOMPLETE - NOT READY - currently pitch does not seem to be correct]
        /// </summary>
        /// <param name="headIKRotationAngles">x: pitch, y:horizontal, z:tilt (unused)</param>
        private void HeadIKGetLocalAngles(out Vector3 headIKRotationAngles)
        {
            // Get current head IK rotation angles relative to character forward direction
            Vector3 headIKTrfmFwd = headTrfm.forward;

            headIKRotationAngles = Vector3.zero;

            // Project head forwards direction into some plane containing where the head is looking and up directions
            Vector3 projectedPitchVector = Vector3.ProjectOnPlane(headIKTrfmFwd, currentCharacterRight);

            //Vector3 projectedPitchVector = Vector3.ProjectOnPlane(currentCharacterFwd, Vector3.Cross(headIKTrfmFwd, currentCharacterUp));

            // Project head direction into "flat" x-z plane
            Vector3 projectedHorzVector = Vector3.ProjectOnPlane(headIKTrfmFwd, currentCharacterUp);

            // Vertical (pitch) angle +ve is look up, -ve is look down
            headIKRotationAngles.x = Vector3.SignedAngle(currentCharacterFwd, projectedPitchVector, currentCharacterRight);
            //headIKRotationAngles.x = Vector3.SignedAngle(headIKTrfmFwd, projectedPitchVector, currentCharacterRight);
            // Make horizontal angle +ve to the right, -ve to the left
            headIKRotationAngles.y = Vector3.SignedAngle(currentCharacterFwd, projectedHorzVector, currentCharacterUp);


            //Vector3 _headDirLS = transform.InverseTransformDirection(headIKTrfmFwd);
            //headIKRotationAngles.x = Mathf.Atan2(_headDirLS.y, _headDirLS.z) * Mathf.Rad2Deg;

            //if (name.Contains("Jane"))
            //{
            //    Debug.Log("[DEBUG] headIKRotationAngles.x " + headIKRotationAngles.x.ToString("0.00") + " T:" + Time.time);
            //}
        }

        /// <summary>
        /// Make the head look at a world space position
        /// </summary>
        /// <param name="headIKPos"></param>
        private void HeadIKSetPosition(Vector3 headIKPos)
        {
            if (headIKPos != Vector3.zero)
            {
                defaultAnimator.SetLookAtPosition(headIKPos);
            }
        }

        #endregion

        #region Private and Internal Methods - Animate Hand IK

#if UNITY_EDITOR
        /// <summary>
        /// [INTERNAL ONLY]
        /// This is a editor hack to get round an issue enabling and disabling
        /// HandIK in the editor at runtime.
        /// </summary>
        public void EditorInternalOnlyHandIK()
        {
            isHandIK = !isHandIK;
        }
#endif

        /// <summary>
        /// Attempt to turn HandIK on or off.
        /// forceChange should generally only be set to true when the controller is first initialised
        /// </summary>
        /// <param name="isEnabled"></param>
        /// <param name="forceChange"></param>
        /// <param name="isSmooth"></param>
        private void EnableOrDisableHandIK(bool isEnabled, bool forceChange = false, bool isSmooth = false)
        {
            if (forceChange || isHandIK != isEnabled)
            {
                if (isEnabled)
                {
                    isHandIKSmoothDisable = false;

                    isHandIKSmoothEnable = isSmooth;
                    currentMaxHandIKWeight = isSmooth ? 0f : 1f;

                    // Check for a valid humanoid and if not already set, get some bone transforms
                    if (!RefreshBoneTransforms(false))
                    {
                        isEnabled = false;
#if UNITY_EDITOR
                        Debug.LogWarning("StickyControlModule Hand IK - the " + name + " character could not access the bones required");
#endif
                    }
                    else
                    {
                        if (leftHandData == null) { leftHandData = new S3DHandData() { hand = AvatarIKGoal.LeftHand }; }
                        if (rightHandData == null) { rightHandData = new S3DHandData() { hand = AvatarIKGoal.RightHand }; }

                        // Update some useful values if they haven't already been set
                        if (leftHandData.handIdlePositionLS == Vector3.zero) { leftHandData.handIdlePositionLS = HandIKGetIdlePositionLS(AvatarIKGoal.LeftHand); }
                        if (rightHandData.handIdlePositionLS == Vector3.zero) { rightHandData.handIdlePositionLS = HandIKGetIdlePositionLS(AvatarIKGoal.RightHand); }

                        if (leftHandData.handIdleRotationLS == Quaternion.identity) { leftHandData.handIdleRotationLS = HandIKGetIdleRotationLS(AvatarIKGoal.LeftHand); }
                        if (rightHandData.handIdleRotationLS == Quaternion.identity) { rightHandData.handIdleRotationLS = HandIKGetIdleRotationLS(AvatarIKGoal.RightHand); }

                        if (leftArmLength == 0f) { GetArmLength(S3Dside.Left, ref leftArmLength); }
                        if (rightArmLength == 0f) { GetArmLength(S3Dside.Right, ref rightArmLength); }

                        if (leftMaxArmReachDistance == 0f) { leftMaxArmReachDistance = HandIKGetMaxReachDistance(AvatarIKGoal.LeftHand); }
                        if (rightMaxArmReachDistance == 0f) { rightMaxArmReachDistance = HandIKGetMaxReachDistance(AvatarIKGoal.RightHand); }

                        if (leftHandTrfm != null)
                        {
                            // Check a layer has IK_Pass enabled
                            // TODO - find a way of checking if IK_Pass is set on the correct layer
                            leftHandData.prevHandIKPos = leftHandTrfm.position;
                            leftHandData.prevHandIKRot = leftHandTrfm.rotation;

                            // Attempt to prevent hand reaching to last enabled position
                            leftHandData.lastKnownHandPos = leftHandData.prevHandIKPos;
                            leftHandData.lastKnownHandRot = leftHandData.prevHandIKRot;
                        }
#if UNITY_EDITOR
                        else
                        {
                            isEnabled = false;
                            Debug.LogWarning("StickyControlModule Hand IK - could not find the LeftHand. Is it exposed in the model Rig? If Optimise Game Objects is enabled, you will need to enable that bone.");
                        }
#endif

                        if (rightHandTrfm != null)
                        {
                            // Check a layer has IK_Pass enabled
                            // TODO - find a way of checking if IK_Pass is set on the correct layer
                            rightHandData.prevHandIKPos = rightHandTrfm.position;
                            rightHandData.prevHandIKRot = rightHandTrfm.rotation;

                            // Attempt to prevent hand reaching to last enabled position
                            rightHandData.lastKnownHandPos = rightHandData.prevHandIKPos;
                            rightHandData.lastKnownHandRot = rightHandData.prevHandIKRot;

                        }
#if UNITY_EDITOR
                        else
                        {
                            isEnabled = false;
                            Debug.LogWarning("StickyControlModule Hand IK - could not find the RightHand. Is it exposed in the model Rig? If Optimise Game Objects is enabled, you will need to enable that bone.");
                        }
#endif

                        //S3DUtils.ReflectionOutputMethods(typeof(Avatar),false, true, true);

                        // FUTURE - Determine appropriate constraint settings. For now select the default one.
                        // Maybe at some point we could work out how rigs are different with hand and bone rotation.
                        // DISABLE FOR NOW while buggy...
                        if (leftHandConstraintSettings == HandConstraintSettings.Auto) { leftHandConstraintSettings = HandConstraintSettings.Disabled; }
                        if (rightHandConstraintSettings == HandConstraintSettings.Auto) { rightHandConstraintSettings = HandConstraintSettings.Disabled; }
                    }

                }
                // Only change when isHandIK is being turned off if it was previously on.
                else if (isHandIK != isEnabled)
                {
                    isHandIKSmoothEnable = false;

                    if (isSmooth)
                    {
                        isHandIKSmoothDisable = true;
                    }
                    else
                    {
                        isHandIKSmoothDisable = false;
                        leftHandTrfm = null;
                        rightHandTrfm = null;
                    }
                }
            }

            // Reset Hand IK blendout variables
            HandIKEnableOrDisableBlendOut(true, false, leftHandIKBlendOutDuration);
            HandIKEnableOrDisableBlendOut(false, false, rightHandIKBlendOutDuration);

            if (isEnabled || !isSmooth)
            {
                isHandIK = isEnabled;
                IKCheckEnabler();
            }
        }

        /// <summary>
        /// Enable or disable Hand IK blending out to smoothly stop Hand IK for the left or right hand.
        /// To turn on/off Hand IK, use EnableOrDisableHandIK(..).
        /// </summary>
        /// <param name="isLeftHand"></param>
        /// <param name="isEnabled"></param>
        /// <param name="blendOutDuration"></param>
        private void HandIKEnableOrDisableBlendOut(bool isLeftHand, bool isEnabled, float blendOutDuration)
        {
            if (isLeftHand)
            {
                isHandIKLeftBlendOut = isEnabled;

                currentMaxLHandWeight = 1f;

                leftHandIKBlendOutDuration = blendOutDuration;
            }
            else
            {
                isHandIKRightBlendOut = isEnabled;

                currentMaxRHandWeight = 1f;

                rightHandIKBlendOutDuration = blendOutDuration;
            }
        }

        /// <summary>
        /// Get the approximate local space position a hand would be in an idle state
        /// hanging down near a humanoid's side.
        /// Position is directly below upper arm, slightly below the upper leg.
        /// Prerequisites: RefreshBoneTransforms(false)
        /// </summary>
        /// <param name="hand"></param>
        /// <returns></returns>
        private Vector3 HandIKGetIdlePositionLS(AvatarIKGoal hand)
        {
            Vector3 handPos = Vector3.zero;

            if (hand == AvatarIKGoal.LeftHand)
            {
                if (leftUpperArmTrfm != null)
                {
                    // Get the local space vertical distance between the upper leg and the lower leg and multiple by a factor of 0.1
                    Transform _leftUpperLeg = defaultAnimator.GetBoneTransform(HumanBodyBones.LeftUpperLeg);

                    Vector3 _leftUpperLegPosLS = GetLocalPosition(_leftUpperLeg.position);

                    handPos.x = -radius;
                    handPos.z = GetLocalPosition(leftUpperArmTrfm.position).z;
                    handPos.y = _leftUpperLegPosLS.y - ((_leftUpperLegPosLS.y - GetLocalPosition(defaultAnimator.GetBoneTransform(HumanBodyBones.LeftLowerLeg).position).y) * 0.1f);
                }
            }
            else if (hand == AvatarIKGoal.RightHand)
            {
                if (rightUpperArmTrfm != null)
                {
                    // Get the local space vertical distance between the upper leg and the lower leg and multiple by a factor of 0.1
                    Transform _rightUpperLeg = defaultAnimator.GetBoneTransform(HumanBodyBones.RightUpperLeg);

                    Vector3 _rightUpperLegPosLS = GetLocalPosition(_rightUpperLeg.position);

                    handPos.x = radius;
                    handPos.z = GetLocalPosition(rightUpperArmTrfm.position).z;
                    handPos.y = _rightUpperLegPosLS.y - ((_rightUpperLegPosLS.y - GetLocalPosition(defaultAnimator.GetBoneTransform(HumanBodyBones.RightLowerLeg).position).y) * 0.1f);
                }
            }

            return handPos;
        }

        /// <summary>
        /// Get rotational difference between the lower arm (elbow) and the hand (wrist)
        /// </summary>
        /// <param name="hand"></param>
        /// <returns></returns>
        private Quaternion HandIKGetIdleRotationLS(AvatarIKGoal hand)
        {
            Quaternion handRot = Quaternion.identity;

            if (hand == AvatarIKGoal.LeftHand)
            {
                handRot = leftHandTrfm.localRotation;
            }
            else if (hand == AvatarIKGoal.RightHand)
            {
                handRot = rightHandTrfm.localRotation;
            }

            return handRot;
        }

        /// <summary>
        /// Get the maximum (hand) reach distance from the upper arm to a potential target.
        /// Prerequisite: GetArmLength(..) 
        /// </summary>
        /// <param name="hand"></param>
        /// <returns></returns>
        private float HandIKGetMaxReachDistance(AvatarIKGoal hand)
        {
            if (hand == AvatarIKGoal.LeftHand)
            {
                return handIKLHMaxReachDist + leftArmLength;
            }
            else
            {
                return handIKRHMaxReachDist + rightArmLength;
            }
        }

        /// <summary>
        /// Set target hand IK position and rotation, taking into account the hand hold offset
        /// and rotation.
        /// This flips the hand hold rotation so it is pointing towards the object (like in the
        /// direction the palm should be pointing).
        /// </summary>
        /// <param name="s3dHandData"></param>
        /// <param name="targetTrfm"></param>
        private void HandIKAdjustForHandHold(S3DHandData s3dHandData, Transform targetTrfm)
        {
            if (targetTrfm != null)
            {
                s3dHandData.targetHandIKPos = targetTrfm.position;
                // Add local space offset if required
                if (s3dHandData.targetHandIKPosOffset.x != 0f) { s3dHandData.targetHandIKPos += targetTrfm.right * s3dHandData.targetHandIKPosOffset.x; }
                if (s3dHandData.targetHandIKPosOffset.y != 0f) { s3dHandData.targetHandIKPos += targetTrfm.up * s3dHandData.targetHandIKPosOffset.y; }
                if (s3dHandData.targetHandIKPosOffset.z != 0f) { s3dHandData.targetHandIKPos += targetTrfm.forward * s3dHandData.targetHandIKPosOffset.z; }

                // Apply local target rotation to the existing rotation of the target object
                // NOTE: Multiply by y=180 to flip the forward direction, so that forward direction matches the intended palm direction
                //s3dHandData.targetHandIKRot = targetTrfm.rotation * Quaternion.Euler(s3dHandData.targetHandIKRotMod) * Quaternion.Euler(0f, 180f, 0f);
                s3dHandData.targetHandIKRot = targetTrfm.rotation * Quaternion.Euler(s3dHandData.targetHandIKRotMod);
            }
        }

        /// <summary>
        /// Calculate the hand position in world space, and the IK weight for the hand.
        /// Take into consideration:
        /// 1. The maximum IK weight (we could be turning Hand IK on/off with smoothing)
        /// 2. The distance from the target
        /// 3. The angle limits of the target in relation to the idle position of the hand
        /// </summary>
        /// <param name="s3dHandData"></param>
        /// <param name="maxHandIKWeight"></param>
        private void HandIKGetPosition(S3DHandData s3dHandData, float maxHandIKWeight)
        {
            if (s3dHandData.targetHandIKPos != Vector3.zero)
            {
                bool isLeftHand = s3dHandData.hand == AvatarIKGoal.LeftHand;
                bool isAimIKOverride = isAimAtTargetEnabled && !isThirdPerson;

                float blendOut = 0f;
                float handIKWeight = maxHandIKWeight;
                // Not sure, but we "may" need to use an idle palm postion here (which we currently don't calculate)
                Vector3 handIdlePos = GetWorldPosition(s3dHandData.handIdlePositionLS);

                // The idle and palm postions are from the previous frame.
                s3dHandData.idleDirToTarget = s3dHandData.targetHandIKPos - handIdlePos;
                float distToTargetSqr = s3dHandData.idleDirToTarget.sqrMagnitude;

                // dot.product = 1.0 is straight ahead
                // dot.product = 0.0 is +/- 90 deg.
                float dotProdToTarget = Vector3.Dot(s3dHandData.idleDirToTarget.normalized, currentCharacterFwd);

                // Project direction to target into character forward horizontal plane
                Vector3 projectedHorzVector = Vector3.ProjectOnPlane(s3dHandData.idleDirToTarget, currentCharacterUp);

                // Make horizontal angle +ve to the right, -ve to the left
                float horzAngle = Vector3.SignedAngle(currentCharacterFwd, projectedHorzVector, currentCharacterUp);

                float deltaLimitAngle = 0f;

                // Is the target behind the character. i.e. the angle < -90 or > 90 degrees
                if (dotProdToTarget < 0f)
                {
                    horzAngle = 0f;
                    handIKWeight = 0f;
                    deltaLimitAngle = 0f;
                }
                else
                {
                    float maxDistanceToTarget = 0;

                    // Check the angle on the forward horizontal plane
                    // As the horizontal angle approaches the limit blend the IK effect out to zero.
                    if (isLeftHand)
                    {
                        // Innner and outer limits are ignored when AimIK and is active
                        if (isAimIKOverride)
                        {
                            blendOut = 0f;
                            deltaLimitAngle = 90f;
                        }
                        else
                        {
                            if (horzAngle > handIKLHInwardLimit) { blendOut += (horzAngle - handIKLHInwardLimit) / 50f; }
                            else if (horzAngle < -handIKLHOutwardLimit) { blendOut += (-horzAngle - handIKLHOutwardLimit) / 50f; }

                            // How close are we to the limits?
                            if (horzAngle > 0f && horzAngle <= handIKLHInwardLimit) { deltaLimitAngle = handIKLHInwardLimit - horzAngle; }
                            else if (horzAngle < 0f && horzAngle >= handIKLHOutwardLimit) { deltaLimitAngle = handIKLHOutwardLimit + horzAngle; }
                        }

                        maxDistanceToTarget = leftMaxArmReachDistance;
                    }
                    else
                    {
                        // Innner and outer limits are ignored when AimIK and is active
                        if (isAimIKOverride)
                        {
                            blendOut = 0f;
                            deltaLimitAngle = 90f;
                        }
                        else
                        {
                            if (horzAngle > handIKRHOutwardLimit) { blendOut += (horzAngle - handIKRHOutwardLimit) / 50f; }
                            else if (horzAngle < -handIKRHInwardLimit) { blendOut += (-horzAngle - handIKRHInwardLimit) / 50f; }

                            // How close are we to the limits?
                            if (horzAngle < 0f) { deltaLimitAngle = handIKRHInwardLimit + horzAngle; }
                            else if (horzAngle >= 0f) { deltaLimitAngle = handIKLHOutwardLimit - horzAngle; }
                        }

                        maxDistanceToTarget = rightMaxArmReachDistance;
                    }

                    float deltaDistSqr = distToTargetSqr - (maxDistanceToTarget * maxDistanceToTarget);

                    // Blend based on target distance from outstretched arm.
                    // Don't reduce Hand IK weight when aiming with a weapon
                    if (deltaDistSqr > 0f && !isAimIKOverride)
                    {
                        if (s3dHandData.blendWeight > 0f)
                        {
                            s3dHandData.blendWeight -= handIKMoveMaxSpeed * Time.deltaTime;
                            if (s3dHandData.blendWeight < 0f) { s3dHandData.blendWeight = 0f; }
                        }
                    }
                    else if (s3dHandData.blendWeight < 1f)
                    {
                        s3dHandData.blendWeight += handIKMoveMaxSpeed * Time.deltaTime;
                        if (s3dHandData.blendWeight > 1f) { s3dHandData.blendWeight = 1f; }
                    }

                    handIKWeight *= s3dHandData.blendWeight;

                    if (handIKWeight > 0f)
                    {
                        // As the target gets closer to being behind the character (rather than in-front), reduce the IK effectiveness.
                        if (deltaLimitAngle < 0) { handIKWeight = 0f; }
                        else if (deltaLimitAngle < 5f)
                        {
                            handIKWeight *= deltaLimitAngle / 5f;
                        }
                    }
                }

                if (isAimAtTargetEnabled)
                {
                    /// TODO - fix hand ik jitter - maybe update in late update
                    // Instantly snap to position (but still has jitter...)
                    s3dHandData.currentHandIKPos = handIdlePos + s3dHandData.idleDirToTarget;
                }
                else
                {
                    // Move the hand from the previous hand IK position to the desired hand IK position at the specified rate.
                    s3dHandData.currentHandIKPos = Vector3.MoveTowards(s3dHandData.prevHandIKPos, handIdlePos + Vector3.Slerp(s3dHandData.idleDirToTarget, currentCharacterFwd, blendOut), handIKMoveMaxSpeed * Time.deltaTime);
                }

                // The desired Hand IK position uses the hand bone. So we need to adjust it for the hand palm offset.
                // We don't want the Hand bone to reach the target, rather we want to use the palm of the hand.
                // This is currently applied as a final step in HandIKSetPosition rather than here which seems to cause issues.

                defaultAnimator.SetIKPositionWeight(s3dHandData.hand, handIKWeight);

                s3dHandData.currentHandIKWeight = handIKWeight;
            }
            else
            {
                defaultAnimator.SetIKPositionWeight(s3dHandData.hand, 0f);
                defaultAnimator.SetIKRotationWeight(s3dHandData.hand, 0f);

                // Set default values
                s3dHandData.currentHandIKPos = Vector3.zero;
                s3dHandData.currentHandIKRot = Quaternion.identity;
                s3dHandData.currentHandIKWeight = 0f;
                s3dHandData.idleDirToTarget = Vector3.forward;
                s3dHandData.palmDirToTarget = Vector3.forward;
                s3dHandData.prevHandIKPos = s3dHandData.lastKnownHandPos;
            }
        }

        /// <summary>
        /// This needs to be called AFTER HandIKGetPosition as it relies on the
        /// currentHandIKWeight to be used as the max weight permitted.
        /// Take into consideration:
        /// 1. The IK weight calculated in the HandIKGetPosition method
        /// </summary>
        /// <param name="s3dHandData"></param>
        /// <param name="maxHandIKWeight"></param>
        private void HandIKGetRotation(S3DHandData s3dHandData)
        {
            bool isLeftHand = s3dHandData.hand == AvatarIKGoal.LeftHand;

            // If position weight is 0 or there is no target rotation, then we don't need to set
            // the IK rotation target
            if (s3dHandData.currentHandIKWeight > 0f && s3dHandData.targetHandIKRot != Quaternion.identity)
            {
                // Apply object rotation
                Quaternion rotationTo = s3dHandData.targetHandIKRot;

                // Apply a constant rotation (not sure why this seems works..)
                rotationTo *= Quaternion.Inverse(Quaternion.Euler(90f, 0f, 90f));

                // =====================================================================================
                // Local space wrist rotation limits get applied in LateUpdate method UpdateHandData(..)  
                // =====================================================================================

                // Store the desired hand rotation. This gets applied in HandIKSetPositionAndRotation(..).
                s3dHandData.currentHandIKRot = rotationTo;
            }
            else
            {
                s3dHandData.currentHandIKWeight = 0f;
                s3dHandData.currentHandIKRot = Quaternion.identity;
            }

            defaultAnimator.SetIKRotationWeight(s3dHandData.hand, s3dHandData.currentHandIKWeight);
        }

        /// <summary>
        /// Set the desired hand (wrist) bone position and rotation.
        /// If required, also updates the IK Hint positions for the elbows.
        /// </summary>
        /// <param name="s3dHandData"></param>
        private void HandIKSetPositionAndRotation(S3DHandData s3dHandData)
        {
            if (s3dHandData.currentHandIKPos != Vector3.zero)
            {
                // The desired Hand IK position uses the hand bone (wrist). So we need to adjust it for the hand palm offset.
                // We don't want the Hand bone to reach the target, rather we want to use the palm of the hand.

                // NOTE: leftHandTrfm.rotation and rightHandTrfm.rotation are prob WRONG as that is probably in the idle state...
                // Might be more accurate to use the rotation from the last frame (s3dHandData.lastKnownHandRot)

                // ELBOW HINTS: These should be at approx elbow height to the left (LeftHand) or right (RightHand) of the character.
                // An x value closer to the character will tuck the elbow closer to the character body. Z should be local space 0 or
                // slightly in front of the spine. If using a transform, it can be attached to one of the spine bones.

                if (s3dHandData.hand == AvatarIKGoal.LeftHand)
                {
                    defaultAnimator.SetIKPosition(s3dHandData.hand, s3dHandData.currentHandIKPos - (s3dHandData.lastKnownHandRot * leftHandPalmOffset));

                    // Set the left elbow hint if provided
                    if (handIKLHElbowHint != null)
                    {
                        defaultAnimator.SetIKHintPositionWeight(AvatarIKHint.LeftElbow, s3dHandData.currentHandIKWeight);
                        defaultAnimator.SetIKHintPosition(AvatarIKHint.LeftElbow, handIKLHElbowHint.position);
                    }
                    else if (isAimAtTargetEnabled)
                    {
                        defaultAnimator.SetIKHintPositionWeight(AvatarIKHint.LeftElbow, s3dHandData.currentHandIKWeight);
                        // If no elbow hint transform, auto-calculate a position around elbow height to the left of the character.
                        // An x value closer to the character will tuck the elbow closer to the character body.
                        defaultAnimator.SetIKHintPosition(AvatarIKHint.LeftElbow, GetBottomWithOffset(currentWorldPosition, currentCharacterUp, new Vector3(-radius * 1.5f, currentScaledHeight * 0.7f, 0f)));
                    }

                    defaultAnimator.SetIKRotation(s3dHandData.hand, s3dHandData.currentHandIKRot);
                }
                else
                {
                    defaultAnimator.SetIKPosition(s3dHandData.hand, s3dHandData.currentHandIKPos - (s3dHandData.lastKnownHandRot * rightHandPalmOffset));

                    // Set the right elbow hint if provided
                    if (handIKRHElbowHint != null)
                    {
                        defaultAnimator.SetIKHintPositionWeight(AvatarIKHint.RightElbow, s3dHandData.currentHandIKWeight);
                        defaultAnimator.SetIKHintPosition(AvatarIKHint.RightElbow, handIKRHElbowHint.position);
                    }
                    else if (isAimAtTargetEnabled)
                    {
                        defaultAnimator.SetIKHintPositionWeight(AvatarIKHint.RightElbow, s3dHandData.currentHandIKWeight);
                        // If no elbow hint transform, auto-calculate a position around elbow height to the right of the character.
                        // An x value closer to the character will tuck the elbow closer to the character body.
                        defaultAnimator.SetIKHintPosition(AvatarIKHint.RightElbow, GetBottomWithOffset(currentWorldPosition, currentCharacterUp, new Vector3(radius * 1.5f, currentScaledHeight * 0.7f, 0f)));
                    }

                    defaultAnimator.SetIKRotation(s3dHandData.hand, s3dHandData.currentHandIKRot);
                }
            }
        }

        /// <summary>
        /// Reset or clear the Hand IK interactive target
        /// </summary>
        /// <param name="isLeftHand"></param>
        private void HandIKResetInteractiveTarget(bool isLeftHand)
        {
            if (isLeftHand)
            {
                leftHandTargetInteractive = null;
                leftHandTargetTrfm = null;
                leftHandData.targetHandIKPos = Vector3.zero;
            }
            else
            {
                rightHandTargetInteractive = null;
                rightHandTargetTrfm = null;
                rightHandData.targetHandIKPos = Vector3.zero;
            }
        }

        private void SetBoneRotation(Transform boneTrfm, Vector3 sign, Quaternion preQ, Quaternion postQ, Vector3 angle)
        {
            //Debug.Log("[DEBUG] angle: " + angle + " sign: " + sign);

            angle = boneTrfm.localEulerAngles;

            angle.x *= sign.x;
            angle.y *= sign.y;
            angle.z *= sign.z;

            // Clamp angles here

            // Without clamping this should have no effect - but instead produces odd results
            boneTrfm.localRotation =
                preQ
                * Quaternion.AngleAxis(new Vector3(0, angle.y, angle.z).magnitude, new Vector3(0, angle.y, angle.z).normalized)
                * Quaternion.AngleAxis(angle.x, new Vector3(1, 0, 0))
                * Quaternion.Inverse(postQ);
        }

        /// <summary>
        /// Set the muscle limits of hand bones by reading the pose, limiting the muscles, and writing the pose back out.
        /// Call this in LateUpdate().
        /// Can return NaN values if the correct root transform is not used in GetHumanPose().
        /// </summary>
        /// <param name="isLeftHand"></param>
        private void SetHandMuscle(bool isLeftHand)
        {
            // muscle x,y,z is -1 to 1 (although can be outside this range)
            // Left and Right Hand do not have a X DoF muscle
            // LH muscle index 44, Down-Up (Y)
            // LH muscle index 45, In-Out (Z)
            // RH muscle index 53, Down-Up (Y)
            // RH muscle index 54, In-Out (Z)

            if (GetHumanPose())
            {
                float limit = 90f;

                if (isLeftHand)
                {
                    float downUp = humanPose.muscles[44];
                    float inOut = humanPose.muscles[45];

                    if (downUp < -handIKLHMaxDownRot / limit) { downUp = -handIKLHMaxDownRot / limit; }
                    else if (downUp > handIKLHMaxUpRot / limit) { downUp = handIKLHMaxUpRot / limit; }
                    if (inOut < -handIKLHMaxInRot / limit) { inOut = -handIKLHMaxInRot / limit; }
                    else if (inOut > handIKLHMaxOutRot / limit) { inOut = handIKLHMaxOutRot / limit; }

                    humanPose.muscles[44] = downUp;
                    humanPose.muscles[45] = inOut;
                }
                else
                {
                    float downUp = humanPose.muscles[53];
                    float inOut = humanPose.muscles[54];

                    //Debug.Log("[RH muscles: down-Up: " + downUp + " in-out: " + inOut);

                    if (downUp < -handIKRHMaxDownRot / limit) { downUp = -handIKRHMaxDownRot / limit; }
                    else if (downUp > handIKRHMaxUpRot / limit) { downUp = handIKRHMaxUpRot / limit; }
                    if (inOut < -handIKRHMaxInRot / limit) { inOut = -handIKRHMaxInRot / limit; }
                    else if (inOut > handIKRHMaxOutRot / limit) { inOut = handIKRHMaxOutRot / limit; }

                    humanPose.muscles[53] = downUp;
                    humanPose.muscles[54] = inOut;
                }

                hposeHandler.SetHumanPose(ref humanPose);
            }
        }

        /// <summary>
        /// Update the hand actual positions during LateUpdate as they may have
        /// been modified during OnAnimateIK or maybe even OnAnimateMove.
        /// If required, call HandTouchNotification.
        /// Limit hand (wrist) rotation.
        /// </summary>
        /// <param name="s3dHandData"></param>
        /// <param name="isLeftHand"></param>
        private void UpdateHandData(S3DHandData s3dHandData, bool isLeftHand)
        {
            if (s3dHandData != null)
            {
                if (isLeftHand)
                {
                    if (leftHandTrfm != null)
                    {
                        // LIMIT HAND (WRIST) ROTATION
                        // Need to do it here which is called in LateUpdate().

                        // handIKLHMaxInRot, handIKLHMaxOutRot - limits left/right rotation of hand
                        // handIKLHMaxUpRot, handIKLHMaxDownRot - limits up/down rotation of hand on local Z axis

                        if (leftHandConstraintSettings != HandConstraintSettings.Disabled)
                        {
                            float angleX = 0f, angleY = 0f, angleZ = 0f;

                            Vector3 rotFwdVector = leftHandTrfm.localRotation * Vector3.forward;
                            Vector3 rotUpVector = leftHandTrfm.localRotation * Vector3.up;


                            // Currently we always use muscles (change to == Disabled to test other options
                            if (leftHandConstraintSettings != HandConstraintSettings.Disabled)
                            {
                                SetHandMuscle(isLeftHand);
                            }
                            else if (leftHandConstraintSettings == HandConstraintSettings.Option1)
                            {
                                // OPTION 1: X and Y

                                // Calculate rotation in terms of two angle rotations: First X, then Y
                                angleX = -Mathf.Asin(rotFwdVector.y) * Mathf.Rad2Deg;
                                angleY = Mathf.Asin(rotFwdVector.x / Mathf.Sqrt(rotFwdVector.x * rotFwdVector.x + rotFwdVector.z * rotFwdVector.z)) * Mathf.Rad2Deg;

                                // Clamp rotation:
                                // X is up/down rotation
                                // Y is in/out rotation
                                if (angleX >= 0f && angleX > handIKLHMaxDownRot) { angleX = handIKLHMaxDownRot; }
                                else if (angleX < 0f && angleX < -handIKLHMaxUpRot) { angleX = -handIKLHMaxUpRot; }
                                if (angleY >= 0f && angleY > handIKLHMaxOutRot) { angleY = handIKLHMaxOutRot; }
                                else if (angleY < 0f && angleY < -handIKLHMaxInRot) { angleY = -handIKLHMaxInRot; }

                                // Calculate new rotation
                                leftHandTrfm.localEulerAngles = new Vector3(angleX, angleY, 0f);
                            }
                            else
                            {
                                // OPTION 2: X and Z

                                // Calculate rotation in terms of two angle rotations: First Z, then X
                                angleZ = -Mathf.Asin(rotUpVector.x) * Mathf.Rad2Deg;
                                angleX = Mathf.Asin(rotUpVector.y / Mathf.Sqrt(rotUpVector.y * rotUpVector.y + rotUpVector.z * rotUpVector.z)) * Mathf.Rad2Deg;

                                // Clamp rotation:
                                // X is up/down rotation
                                // Z is in/out rotation
                                if (angleX >= 0f && angleX > handIKLHMaxDownRot) { angleX = handIKLHMaxDownRot; }
                                else if (angleX < 0f && angleX < -handIKLHMaxUpRot) { angleX = -handIKLHMaxUpRot; }
                                if (angleZ >= 0f && angleZ > handIKLHMaxOutRot) { angleZ = handIKLHMaxOutRot; }
                                else if (angleZ < 0f && angleZ < -handIKLHMaxInRot) { angleZ = -handIKLHMaxInRot; }

                                // Calculate new rotation
                                leftHandTrfm.localEulerAngles = new Vector3(angleX, angleY, 0f);
                            }
                            if (false)
                            {
                                // OPTION 3: Y and Z

                            }
                        }

                        s3dHandData.lastKnownHandPos = leftHandTrfm.position;
                        s3dHandData.lastKnownHandRot = leftHandTrfm.rotation;
                    }
                    else
                    {
                        s3dHandData.lastKnownHandPos = Vector3.zero;
                        s3dHandData.lastKnownHandRot = Quaternion.identity;
                    }
                }
                else
                {
                    if (rightHandTrfm != null)
                    {
                        // LIMIT HAND (WRIST) ROTATION
                        // Need to do it here which is called in LateUpdate().

                        // handIKRHMaxInRot, handIKRHMaxOutRot - limits left/right rotation of hand
                        // handIKRHMaxUpRot, handIKRHMaxDownRot - limits up/down rotation of hand on local Z axis

                        if (rightHandConstraintSettings != HandConstraintSettings.Disabled)
                        {
                            // angleX up/down, angleY in/out (left/right)
                            float angleX = 0f, angleY = 0f, angleZ = 0f;

                            //SetHandMuscle(isLeftHand);

                            // OPTION 1 is original David code

                            // WHAT I THINK SHOULD WORK:
                            // - Jody (Mixamo) rig: OPTION 1
                            // - Rod rig: OPTION 3
                            // - Toon rig: OPTION 2

                            // We might be able to cache these values (prob impacts GC each frame)
                            // _sign is of x,y,z axis.
                            //Vector3 _sign = Vector3.zero;
                            //Quaternion _preRot = Quaternion.identity, _postRot = Quaternion.identity;
                            //GetInternalBoneRotations(HumanBodyBones.RightHand, ref _sign, ref _preRot, ref _postRot);                            
                            //Debug.Log("[DEBUG] sign:" + _sign + " preRot: " + _preRot + " postRot: " + _postRot);

                            // Currently we always use muscles (change to == Disabled to test other options
                            if (rightHandConstraintSettings != HandConstraintSettings.Disabled)
                            {
                                SetHandMuscle(isLeftHand);
                            }
                            else if (rightHandConstraintSettings == HandConstraintSettings.Option1)
                            {
                                // Jody (Mixamo) rig: angleX is up/down (seems correct). AngleY left/right is clamped and has no effect)
                                // PlayerJaneSuited rig: angleX is up/down (seems correct). AngleY seems to control hand twist rather than left/right.
                                // Rod character rig: angleX (clamped and incorrect), AngleY seems to control up/down
                                //angleX = -Mathf.Asin(rotFwdVector.y) * Mathf.Rad2Deg;
                                //angleY = Mathf.Asin(rotFwdVector.x / Mathf.Sqrt(rotFwdVector.x * rotFwdVector.x + rotFwdVector.z * rotFwdVector.z)) * Mathf.Rad2Deg;

                                // OPTION 1: X and Y

                                // Calculate rotation in terms of two angle rotations: First X, then Y
                                Vector3 rotFwdVector = rightHandTrfm.localRotation * Vector3.forward;
                                angleX = -Mathf.Asin(rotFwdVector.y) * Mathf.Rad2Deg;
                                angleY = Mathf.Asin(rotFwdVector.x / Mathf.Sqrt(rotFwdVector.x * rotFwdVector.x + rotFwdVector.z * rotFwdVector.z)) * Mathf.Rad2Deg;

                                // Clamp rotation:
                                // X is up/down rotation
                                // Y is in/out rotation
                                //if (angleX >= 0f && angleX > handIKRHMaxDownRot) { angleX = handIKRHMaxDownRot; }
                                //else if (angleX < 0f && angleX < -handIKRHMaxUpRot) { angleX = -handIKRHMaxUpRot; }
                                //if (angleY >= 0f && angleY > handIKRHMaxInRot) { angleY = handIKRHMaxInRot; }
                                //else if (angleY < 0f && angleY < -handIKRHMaxOutRot) { angleY = -handIKRHMaxOutRot; }

                                // Calculate new rotation (apply X before Y)
                                rightHandTrfm.localEulerAngles = new Vector3(angleX, angleY, 0f);
                            }
                            else if (rightHandConstraintSettings == HandConstraintSettings.Option2)
                            {
                                // Rod character rig: angleX has no effect, AngleY in/out (seems correct).
                                //angleX = -Mathf.Asin(rotFwdVector.y) * Mathf.Rad2Deg;
                                //angleY = Mathf.Asin(rotFwdVector.z / Mathf.Sqrt(rotFwdVector.x * rotFwdVector.x + rotFwdVector.z * rotFwdVector.z)) * Mathf.Rad2Deg;

                                // OPTION 2: X and Z

                                // Calculate rotation in terms of two angle rotations: First Z, then X
                                Vector3 rotUpVector = rightHandTrfm.localRotation * Vector3.up;
                                angleZ = -Mathf.Asin(rotUpVector.x) * Mathf.Rad2Deg;
                                angleX = Mathf.Asin(rotUpVector.y / Mathf.Sqrt(rotUpVector.y * rotUpVector.y + rotUpVector.z * rotUpVector.z)) * Mathf.Rad2Deg;

                                // Clamp rotation:
                                // X is up/down rotation
                                // Z is in/out rotation
                                //if (angleX >= 0f && angleX > handIKRHMaxDownRot) { angleX = handIKRHMaxDownRot; }
                                //else if (angleX < 0f && angleX < -handIKRHMaxUpRot) { angleX = -handIKRHMaxUpRot; }
                                //if (angleZ >= 0f && angleZ > handIKRHMaxInRot) { angleZ = handIKRHMaxInRot; }
                                //else if (angleZ < 0f && angleZ < -handIKRHMaxOutRot) { angleZ = -handIKRHMaxOutRot; }

                                // Calculate new rotation (apply Z before X)
                                rightHandTrfm.localRotation = Quaternion.Euler(angleX, 0f, 0f) * Quaternion.Euler(0f, 0f, angleZ);
                            }
                            else if (rightHandConstraintSettings == HandConstraintSettings.Option3)
                            {
                                // Toon Series character
                                // Rod character rig: angleX is up/down (seems correct), angleY in/out seems to be twist (incorrect)
                                //angleX = Mathf.Asin(rotFwdVector.x / Mathf.Sqrt(rotFwdVector.x * rotFwdVector.x + rotFwdVector.z * rotFwdVector.z)) * Mathf.Rad2Deg;
                                //angleY = -Mathf.Asin(rotFwdVector.y) * Mathf.Rad2Deg;

                                // OPTION 3: Y and Z

                                // Calculate rotation in terms of two angle rotations: First Y, then 
                                Vector3 rotRightVector = leftHandTrfm.localRotation * Vector3.right;
                                angleY = -Mathf.Asin(rotRightVector.z) * Mathf.Rad2Deg;
                                angleZ = Mathf.Asin(rotRightVector.x / Mathf.Sqrt(rotRightVector.x * rotRightVector.x + rotRightVector.y * rotRightVector.y)) * Mathf.Rad2Deg;

                                // Clamp rotation:
                                // Z is up/down rotation
                                // Y is in/out rotation
                                //if (angleZ >= 0f && angleZ > handIKRHMaxDownRot) { angleZ = handIKRHMaxDownRot; }
                                //else if (angleZ < 0f && angleZ < -handIKRHMaxUpRot) { angleZ = -handIKRHMaxUpRot; }
                                //if (angleY >= 0f && angleY > handIKRHMaxInRot) { angleY = handIKRHMaxInRot; }
                                //else if (angleY < 0f && angleY < -handIKRHMaxOutRot) { angleY = -handIKRHMaxOutRot; }

                                // Calculate new rotation (apply Y before Z)
                                rightHandTrfm.localRotation = Quaternion.Euler(0f, 0f, angleZ) * Quaternion.Euler(0f, angleY, 0f);
                            }
                            else if (rightHandConstraintSettings == HandConstraintSettings.Option4)
                            {
                                Vector3 rotFwdVector = rightHandTrfm.localRotation * Vector3.forward;
                                //SetBoneRotation(rightHandTrfm, _sign, _preRot, _postRot, rotFwdVector);

                                SetHandMuscle(isLeftHand);
                            }

                            //float targetAX = angleX;
                            //float targetAY = angleY;

                            //if (angleX >= 0f && angleX > handIKRHMaxDownRot) { angleX = handIKRHMaxDownRot; }
                            //else if (angleX < 0f && angleX < -handIKRHMaxUpRot) { angleX = -handIKRHMaxUpRot; }
                            //if (angleY >= 0f && angleY > handIKRHMaxInRot) { angleY = handIKRHMaxInRot; }
                            //else if (angleY < 0f && angleY < -handIKRHMaxOutRot) { angleY = -handIKRHMaxOutRot; }

                            //rightHandTrfm.localEulerAngles = new Vector3(angleX, angleY, 0f);
                            //rightHandTrfm.localEulerAngles = new Vector3(angleX, 0f, angleY);

                            //Debug.Log("X: " + targetAX.ToString("0.000") + " -> " + angleX.ToString("0.000") +
                            //    ", Y: " + targetAY.ToString("0.000") + " -> " + angleY.ToString("0.000"));

                        }

                        // TODO Apply hand and lower arm twist limits (prob hard code values)


                        s3dHandData.lastKnownHandPos = rightHandTrfm.position;
                        s3dHandData.lastKnownHandRot = rightHandTrfm.rotation;

                        //Debug.Log("[DEBUG] RH loc Rot: " + rightHandTrfm.localRotation.eulerAngles);
                    }
                    else
                    {
                        s3dHandData.lastKnownHandPos = Vector3.zero;
                        s3dHandData.lastKnownHandRot = Quaternion.identity;
                    }
                }
            }

            if (s3dHandData.currentHandIKWeight > 0f && s3dHandData.targetHandIKPos != Vector3.zero)
            {
                // Check if this hand has started touching a touchable interactive-enabled object
                s3dHandData.palmDirToTarget = s3dHandData.targetHandIKPos - (isLeftHand ? GetLeftHandPalmPosition() : GetRightHandPalmPosition());

                // Currently we use the same radius for both hands.
                if (!s3dHandData.isTouching && s3dHandData.palmDirToTarget.sqrMagnitude <= leftHandRadius * leftHandRadius)
                {
                    s3dHandData.isTouching = true;

                    // Is there an interactive-enabled object that is touch-enabled?
                    HandTouchNotification(isLeftHand);
                }
                // If the hand was touching the object, but now the hands are outside the range of the object,
                // stop touching it. The character may still be attempting to reach (target) the object,
                // but the hands cannot quite reach the object any more.
                else if (s3dHandData.isTouching && s3dHandData.palmDirToTarget.sqrMagnitude > leftHandRadius * leftHandRadius)
                {
                    s3dHandData.isTouching = false;

                    // Is there an interactive-enabled object that is touch-enabled?
                    HandTouchNotification(isLeftHand);
                }
            }
            else
            {
                // Check if this hand has stopped touching a touchable interactive-enabled object
                if (s3dHandData.isTouching)
                {
                    s3dHandData.isTouching = false;

                    // Is there an interactive-enabled object that is touch-enabled?
                    HandTouchNotification(isLeftHand);
                }

                s3dHandData.palmDirToTarget = Vector3.forward;
            }
        }

        #endregion

        #region Private and Internal Methods - Animate Hand VR

#if UNITY_EDITOR
        /// <summary>
        /// [INTERNAL ONLY]
        /// This is a editor hack to get round an issue enabling and disabling
        /// HandVR in the editor at runtime.
        /// </summary>
        public void EditorInternalOnlyHandVR()
        {
            isHandVR = !isHandVR;
        }
#endif


        /// <summary>
        /// Try to enable or disable hand VR animate at runtime
        /// </summary>
        /// <param name="isEnabled"></param>
        internal void EnableOrDisableHandVRAnimate(bool isEnabled, bool isLeftHand)
        {
            if (isLeftHand) { isHandVRAnimateLHEnabled = isEnabled; }
            else { isHandVRAnimateRHEnabled = isEnabled; }

            if (isEnabled)
            {
                Animator _handAnimator = isLeftHand ? leftHandAnimator : rightHandAnimator;

                if (_handAnimator == null)
                {
                    if (isLeftHand) { isHandVRAnimateLHEnabled = false; }
                    else { isHandVRAnimateRHEnabled = false; }

#if UNITY_EDITOR
                    Debug.LogWarning("Sticky3D could not enable animate because " + (isLeftHand ? "left" : "right") + " Animator is not set on the Animate tab under Hand VR");
#endif
                }
                else if (_handAnimator.runtimeAnimatorController == null)
                {
                    if (isLeftHand) { isHandVRAnimateLHEnabled = false; }
                    else { isHandVRAnimateRHEnabled = false; }

#if UNITY_EDITOR
                    Debug.LogWarning("Sticky3D could not enable animate because there is no controller set on the Animator component of " + _handAnimator.name);
#endif
                }
            }
        }

        private void EnableOrDisableHandVR(bool isEnabled, bool forceChange = false)
        {
            if (forceChange || isHandVR != isEnabled)
            {
                if (isEnabled)
                {
                    // Check for StickyInputControl is in InputXR mode

#if SCSM_XR && SSC_UIS
                    if (leftHandVRGrip == null) { leftHandVRGrip = new S3DAnimAction() { parameterType = S3DAnimAction.ParameterType.Float}; }
                    if (rightHandVRGrip == null) { rightHandVRGrip = new S3DAnimAction() { parameterType = S3DAnimAction.ParameterType.Float }; }
                    if (leftHandVRTrigger == null) { leftHandVRTrigger = new S3DAnimAction() { parameterType = S3DAnimAction.ParameterType.Float }; }
                    if (rightHandVRTrigger == null) { rightHandVRTrigger = new S3DAnimAction() { parameterType = S3DAnimAction.ParameterType.Float}; }
#endif

                    // Validate left and right animators

                    if (currentCharInputXR == null) { currentCharInputXR = new CharacterInputXR(); }
                    if (previousCharInputXR == null) { previousCharInputXR = new CharacterInputXR(); }
                }
                // Only change when isHandVR is being turned off if it was previously on.
                else if (isHandVR != isEnabled)
                {
                    isHandVR = false;
                }
            }
        }

        /// <summary>
        /// Animate the XR hand models for the character based on input from the hand controllers
        /// </summary>
        private void XRAnimateHand()
        {
            if (isHandVRAnimateLHEnabled)
            {
                if (leftHandVRGrip != null && leftHandVRGrip.paramHashCode != 0)
                {
                    leftHandAnimator.SetFloat(leftHandVRGrip.paramHashCode, currentCharInputXR.leftHandGrip);
                }

                if (leftHandVRTrigger != null && leftHandVRTrigger.paramHashCode != 0)
                {
                    leftHandAnimator.SetFloat(leftHandVRTrigger.paramHashCode, currentCharInputXR.leftHandTrigger);
                }
            }

            if (isHandVRAnimateRHEnabled)
            {
                if (rightHandVRGrip != null && rightHandVRGrip.paramHashCode != 0)
                {
                    rightHandAnimator.SetFloat(rightHandVRGrip.paramHashCode, currentCharInputXR.rightHandGrip);
                }

                if (rightHandVRTrigger != null && rightHandVRTrigger.paramHashCode != 0)
                {
                    rightHandAnimator.SetFloat(rightHandVRTrigger.paramHashCode, currentCharInputXR.rightHandTrigger);
                }
            }
        }

        #endregion

        #region Private and Internal Methods - Animate Ragdoll

        /// <summary>
        /// Attempt to enable or disable ragdoll at runtime.
        /// Has no effect if the value has not changed.
        /// </summary>
        /// <param name="isEnabled"></param>
        private void EnableOrDisableRagdoll (bool isEnabled)
        {
            if (isInitialised)
            {
                bool hasChanged = isEnabled != isRagdollEnabled;
                int numBones = ragdollBoneList == null ? 0 : ragdollBoneList.Count;

                if (hasChanged && numBones > 0)
                {
                    //CharacterJoint joint;
                    S3DHumanBonePersist s3dBone;
                    Transform boneTfrm;
                    Rigidbody boneRBody, hipsRBody = null;
                    Collider boneCollider;

                    if (isEnabled)
                    {
                        #region Enable Ragdoll
                        savedRagdollIsAnimateEnabled = isAnimateEnabled;

                        if (isAnimateEnabled)
                        {
                            EnableOrDisableAnimate(false);
                        }

                        EnableOrDisableMovement(false, false);
                        EnableOrDisablePhysics(false, false);

                        // The animator must be disable, else ragdoll will not work
                        if (defaultAnimator != null) { defaultAnimator.enabled = false; }

                        for (int bIdx = 0; bIdx < numBones; bIdx++)
                        {
                            s3dBone = ragdollBoneList[bIdx];
                            boneTfrm = s3dBone.boneTransform;
                            boneCollider = s3dBone.boneCollider;

                            if (boneTfrm != null)
                            {
                                // Not all bones will have a rigidbody and collider
                                // e.g. hands and feet
                                if (boneTfrm.TryGetComponent(out boneRBody))
                                {
                                    /// TODO - check with VR Hands and decide what to do for ragdoll enable...

                                    if (boneCollider != null || boneTfrm.TryGetComponent(out boneCollider))
                                    {
                                        boneCollider.isTrigger = false;
                                        boneCollider.enabled = true;
                                    }

                                    boneRBody.detectCollisions = true;
                                    boneRBody.isKinematic = false;

                                    if (s3dBone.bone == HumanBodyBones.Hips)
                                    {
                                        hipsRBody = boneRBody;
                                    }
                                }
                            }

                            // Apply any existing velocity of the character to the ragdoll
                            if (hipsRBody != null && currentLocalVelocity != Vector3.zero)
                            {
                                /// TODO - apply any unspent force applied by say a projectile hit

                                hipsRBody.AddForce(transform.rotation * currentLocalVelocity, ForceMode.VelocityChange);
                            }
                        }
                        #endregion
                    }
                    else
                    {
                        #region Disable Ragdoll
                        for (int bIdx = 0; bIdx < numBones; bIdx++)
                        {
                            s3dBone = ragdollBoneList[bIdx];
                            boneTfrm = s3dBone.boneTransform;
                            boneCollider = s3dBone.boneCollider;

                            if (boneTfrm != null)
                            {
                                if (boneTfrm.TryGetComponent(out boneRBody))
                                {
                                    boneRBody.isKinematic = true;

                                    // If there is a damage region for this bone, we need to keep collision detection
                                    // enabled for this rigidbody, else weapon projectile or beam hits won't be recorded.
                                    boneRBody.detectCollisions = HasDamageRegion(s3dBone.bone);

                                    if ((boneCollider != null || boneTfrm.TryGetComponent(out boneCollider)) && !boneCollider.isTrigger)
                                    {
                                        /// TODO - check if there is a matching damage region
                                        /// 
                                        boneCollider.enabled = false;

                                        boneCollider.isTrigger = true;
                                    }
                                }
                            }
                        }

                        EnableOrDisablePhysics(true, true);
                        EnableOrDisableMovement(true, false);

                        if (defaultAnimator != null)
                        {
                            defaultAnimator.enabled = true;
                            if (savedRagdollIsAnimateEnabled)
                            {
                                EnableOrDisableAnimate(true);
                                savedRagdollIsAnimateEnabled = false;
                            }
                        }
                        #endregion
                    }

                    isRagdollEnabled = isEnabled;
                }
            }
        }

        #endregion

        #region Private and Internal Methods - Animate Root Motion

        /// <summary>
        /// Attempt to turn on or off Root Motion on the animator.
        /// </summary>
        /// <param name="isEnabled"></param>
        private void EnableOrDisableRootMotion(bool isEnabled)
        {
            //bool _hasChanged = isEnabled != isRootMotion;

            isRootMotion = isEnabled;

            VerifyRootMotionSettings();

            if (isRootMotion) { moveIdleThreshold = rootMotionIdleThreshold; }
            else { moveIdleThreshold = 0.0001f; }
        }

        /// <summary>
        /// If root motion is enabled, make sure things are configured correctly.
        /// Make changes as required.
        /// </summary>
        private void VerifyRootMotionSettings()
        {
            if (defaultAnimator != null)
            {
                if (isRootMotion)
                {
                    // Root motion needs to run from FixedUpdate().
                    #if UNITY_2023_1_OR_NEWER
                    defaultAnimator.updateMode = AnimatorUpdateMode.Fixed;
                    #else
                    defaultAnimator.updateMode = AnimatorUpdateMode.AnimatePhysics;
                    #endif
                    defaultAnimator.applyRootMotion = true;
                }
                else
                {
                    // When OnAnimatorMove() is in the script (which it always is in our case)
                    // applyRootMotion will be on by default (Unity must set this).
                    defaultAnimator.applyRootMotion = false;
                }
            }

            IKCheckEnabler();
        }

        #endregion

        #region Private or Internal Methods - General

        /// <summary>
        /// Align the character up with ground normal. Update the currentRelativeTargetUp which gets
        /// applied in the "Compute New Relative Angular Velocity / Rotation" section of UpdateController(..).
        /// </summary>
        /// <param name="groundNormal"></param>
        private void AlignToGroundNormal(Vector3 groundNormal)
        {
            currentRelativeTargetUp = Quaternion.Inverse(currentReferenceFrameRotation) * groundNormal;
        }

        /// <summary>
        /// Attempt to change the current (scaled) height.
        /// Returns true if the height was changed.
        /// If standing up from a crouch, only start to stand if can fully fit into space above.
        /// </summary>
        /// <param name="targetScaledHeight"></param>
        private bool ChangeHeight(float targetScaledHeight)
        {
            if (isInitialised)
            {
                // Look above the character to see if we can stand up to full height
                if (targetScaledHeight > currentScaledHeight && CheckCapsule(GetTop(currentWorldPosition, currentCharacterUp), currentCharacterUp, height - currentScaledHeight))
                {
                    return false;
                }
                else
                {
                    // Remember the current bottom or feet position
                    Vector3 _prevBottomPos = GetBottom(currentWorldPosition, currentCharacterUp);

                    // Change the height
                    currentScaledHeight = targetScaledHeight;
                    currentScaledBottomY = (pivotToCentreOffsetY * currentScaledHeight / height) - (currentScaledHeight * 0.5f);

                    currentScaledShoulderHeight = currentScaledHeight - (height - shoulderHeight);

                    // Retain the previous bottom or feet position
                    currentWorldPosition = GetWorldPositionUsingBottom(_prevBottomPos, currentCharacterUp);

                    CrouchAmount = 1.0f - S3DMath.Normalise(currentScaledHeight, height * crouchHeightNormalised, height);

                    return true;
                }
            }
            else { return false; }
        }

        /// <summary>
        /// Check if there are any collision layer non-trigger colliders in the space occupied
        /// by the capsule having the base point at bottomPoint and being capsuleHeight in height.
        /// The "up" direction is from the bottom to the top of the capsule.
        /// Uses the character current scaled radius for the capsule.
        /// </summary>
        /// <param name="bottomPoint"></param>
        /// <param name="upDirection"></param>
        /// <param name="capsuleHeight"></param>
        /// <returns></returns>
        private bool CheckCapsule(Vector3 bottomPoint, Vector3 upDirection, float capsuleHeight)
        {
            // Check if the capsule can fit in the space
            // Physics capsules start and end points are indented by the radius, so convert the bottom
            // anchor point to be inside the capsule, rather than right on the bottom.
            Vector3 bottomAnchor = bottomPoint + (upDirection * currentScaledRadius);

            return Physics.CheckCapsule(bottomAnchor, bottomAnchor + (upDirection * (capsuleHeight - (currentScaledRadius * 2f))), currentScaledRadius, collisionLayerMask, QueryTriggerInteraction.Ignore);
        }

        /// <summary>
        /// Check cursor and update mouse position
        /// </summary>
        private void CheckCursor()
        {
            UpdateCurrentMousePosition();

            if (lookShowCursor)
            {
                cursorTimer += Time.deltaTime;
                // If use has move the mouse, reset the timer
                if (lastMousePosition != currentMousePosition) { cursorTimer = 0f; }
                // After hideCursorTime secs, hide it
                else if (cursorTimer > lookHideCursorTime) { ShowOrHideCursor(false); }
            }
            // Check if mouse has moved (does user wish to click on something?)
            else if (lastMousePosition != currentMousePosition)
            {
                ShowOrHideCursor(true);
            }

            lastMousePosition = currentMousePosition;
        }

        /// <summary>
        /// Enable or disable all the character features.
        /// Movement, Look, Collision detection, Animate, JetPack.
        /// NOTE: Look is not re-enabled on NPCs.
        /// </summary>
        /// <param name="isEnabled"></param>
        /// <param name="resetVelocity"></param>
        internal void EnableOrDisableCharacter(bool isEnabled, bool resetVelocity)
        {
            if (isEnabled)
            {
                // Restore the value when it was disabled
                lookAutoHideCursor = lookAutoHideCursorToRestore;
                EnableOrDisableMovement(isEnabled, resetVelocity);

                // No need to check resetVelocity, as this is already done in EnableOrDisableMovement 
                EnableOrDisablePhysics(isEnabled, false);

                if (!isNPC) { EnableOrDisableLook(isEnabled); }

                // Restore previous state of isLookInteractiveEnabled if it was set.
                if (savedLookInteractiveState > 0)
                {
                    EnableOrDisableLookInteractive(savedLookInteractiveState == 1);
                }

                // Restore previous state of isLookSocketsEnabled if it was set.
                if (savedLookSocketsState > 0)
                {
                    EnableOrDisableLookSockets(savedLookSocketsState == 1);
                }

                EnableOrDisableAnimate(isEnabled);

                // Restore previous state of JetPackAvailable if it was set.
                if (savedJetPackAvailableState > 0)
                {
                    isJetPackAvailable = savedJetPackAvailableState == 1;
                }

                isInputProcessed = true;
            }
            else
            {
                EnableOrDisableAnimate(false);

                savedLookInteractiveState = isLookInteractiveEnabled ? 1 : 2;
                EnableOrDisableLookInteractive(false);

                savedLookSocketsState = isLookSocketsEnabled ? 1 : 2;
                EnableOrDisableLookSockets(false);

                EnableOrDisableLook(false);
                EnableOrDisableMovement(false, resetVelocity);

                // No need to check resetVelocity, as this is already done in EnableOrDisableMovement 
                EnableOrDisablePhysics(isEnabled, false);
                savedJetPackAvailableState = isJetPackAvailable ? 1 : 2;
                isJetPackAvailable = false;

                // Remember the AutoHideCursor setting
                lookAutoHideCursorToRestore = lookAutoHideCursor;
                // Turn it off when the character is diabled
                lookAutoHideCursor = false;
            }
        }

        /// <summary>
        /// Attempt to enable or disable colliders.
        /// Called from EnableOrDisablePhysics(..).
        /// </summary>
        /// <param name="isEnabled"></param>
        private void EnableOrDisableColliders(bool isEnabled)
        {
            GetComponentsInChildren(false, removeColliderList);

            int numColliders = removeColliderList.Count;

            for (int colIdx = 0; colIdx < numColliders; colIdx++)
            {
                Collider _collider = removeColliderList[colIdx];
                if (IsColliderSelf(_collider.GetInstanceID())) { _collider.enabled = isEnabled; }
            }

            removeColliderList.Clear();
        }

        /// <summary>
        /// Enable or disable the Physics on the character.
        /// Where possible, enable or disable colliders.
        /// If resetVelocity and isEnabled are true, resets the velocity of the character to zero.
        /// </summary>
        /// <param name="isEnabled"></param>
        /// <param name="resetVelocity"></param>
        private void EnableOrDisablePhysics(bool isEnabled, bool resetVelocity)
        {
            if (isEnabled)
            {
                rBody.detectCollisions = true;
            }
            else
            {
                rBody.detectCollisions = false;
            }

            EnableOrDisableColliders(isEnabled);

            if (resetVelocity) { StopMoving(); }
        }

        /// <summary>
        /// Enable or disable a list of renderers to show or hide the character
        /// </summary>
        /// <param name="isEnable"></param>
        private void EnableOrDisableVisibility(bool isEnabled)
        {
            if (isInitialised)
            {
                int numRenderers = activeRenderersList.Count;

                if (isEnabled)
                {
                    for (int arIdx = 0; arIdx < numRenderers; arIdx++)
                    {
                        Renderer _ren = activeRenderersList[arIdx];

                        if (_ren != null && !_ren.enabled && (!isStashInitialised || !_ren.transform.IsChildOf(stashParent)))
                        {
                            _ren.enabled = true;
                        }
                    }

                    // Enable held interactive objects
                    if (leftHandInteractiveId != StickyInteractive.NoID && !leftHandInteractive.gameObject.activeSelf)
                    {
                        leftHandInteractive.gameObject.SetActive(true);
                    }

                    if (rightHandInteractiveId != StickyInteractive.NoID && !rightHandInteractive.gameObject.activeSelf)
                    {
                        rightHandInteractive.gameObject.SetActive(true);
                    }

                    isCharacterVisibilityDisabled = false;
                }
                else
                {

                    if (!isCharacterVisibilityDisabled)
                    {
                        // Prevent the list being cleared when the character is already disabled
                        isCharacterVisibilityDisabled = true;

                        // Disable held interactive objects
                        /// TODO - disable weapons
                        if (leftHandInteractiveId != StickyInteractive.NoID)
                        {
                            leftHandInteractive.gameObject.SetActive(false);
                        }

                        if (rightHandInteractiveId != StickyInteractive.NoID)
                        {
                            rightHandInteractive.gameObject.SetActive(false);
                        }

                        // Get all the active renderers in the character and store them in a list
                        // Use a pre-defined reusable list.
                        GetComponentsInChildren(false, activeRenderersList);

                        numRenderers = activeRenderersList.Count;

                        // Disable all renders in the active list that are not stashed
                        for (int arIdx = 0; arIdx < numRenderers; arIdx++)
                        {
                            Renderer _ren = activeRenderersList[arIdx];

                            if (_ren != null && _ren.enabled && (!isStashInitialised || !_ren.transform.IsChildOf(stashParent)))
                            {
                                _ren.enabled = false;
                            }
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Get the bottom position of the character, given the worldspace position.
        /// excludeRadius is useful when using capsule or sphere methods.
        /// Optional offsetY is the distance added in the upDirection.
        /// </summary>
        /// <param name="wsPosition"></param>
        /// <param name="upDirection"></param>
        /// <param name="excludeRadius"></param>
        /// <param name="offsetY"></param>
        /// <returns></returns>
        private Vector3 GetBottom(Vector3 wsPosition, Vector3 upDirection, bool excludeRadius = false, float offsetY = 0f)
        {
            return wsPosition + (upDirection * (currentScaledBottomY + (excludeRadius ? currentScaledRadius : 0f) + offsetY));
        }

        /// <summary>
        /// Get a world space position offset in local space from the bottom of the character
        /// </summary>
        /// <param name="wsPosition"></param>
        /// <param name="upDirection"></param>
        /// <param name="localOffset"></param>
        /// <returns></returns>
        private Vector3 GetBottomWithOffset(Vector3 wsPosition, Vector3 upDirection, Vector3 localOffset)
        {
            Vector3 bottomPos = GetBottom(wsPosition, upDirection);

            if (isInitialised)
            {
                return (currentCharacterRight * localOffset.x) +
                       (currentCharacterUp * localOffset.y) +
                       (currentCharacterFwd * localOffset.z) +
                       bottomPos;
            }
            else
            {
                return (transform.rotation * localOffset) + bottomPos;
            }
        }

        /// <summary>
        /// Get the centre of the character, given a worldspace position.
        /// </summary>
        /// <param name="wsPosition"></param>
        /// <param name="upDirection"></param>
        /// <returns></returns>
        private Vector3 GetCentre(Vector3 wsPosition, Vector3 upDirection)
        {
            return wsPosition + (upDirection * (pivotToCentreOffsetY * currentScaledHeight / height));
        }

        private Vector3 GetLocalOffsetFromBottom(Vector3 wsPosition, Vector3 wsPoint)
        {
            return (Quaternion.Inverse(currentWorldRotation) * (wsPoint - wsPosition)) - (currentScaledBottomY * Vector3.up);
        }

        /// <summary>
        /// Get a position inside a circle with a minimum radius and maximum radius.
        /// </summary>
        /// <param name="minRadius"></param>
        /// <param name="maxRadius"></param>
        /// <returns></returns>
        private Vector3 GetRandomPositionXZ (float minRadius, float maxRadius)
        {
            return new Vector3(
             miscS3DRandom.Range(minRadius, maxRadius) * miscS3DRandom.Sign(), 0f,
             miscS3DRandom.Range(minRadius, maxRadius) * miscS3DRandom.Sign());
        }

        /// <summary>
        /// Get the current centre point between the upper arm bones. If not a humanoid character,
        /// will return the same as GetShoulderCentre with the position of the character.
        /// If assume isHumanoid is true, it will bypass the humanoid test.
        /// NOTE: Not all rigs have shoulder bones, so instead use the Left and Right Upper Arms.
        /// </summary>
        /// <param name="isHumanoid"></param>
        /// <returns></returns>
        private Vector3 GetShoulderBoneCentre(bool isHumanoid)
        {
            if (isHumanoid || IsValidHumanoid(false))
            {
                return (defaultAnimator.GetBoneTransform(HumanBodyBones.RightUpperArm).position + defaultAnimator.GetBoneTransform(HumanBodyBones.LeftUpperArm).position) / 2;
            }
            else
            {
                return GetShoulderCentre(currentWorldPosition, currentCharacterUp);
            }
        }

        /// <summary>
        /// Get the world space centre of the shoulders, given the world space position
        /// of the character.
        /// </summary>
        /// <param name="wsPosition"></param>
        /// <param name="upDirection"></param>
        /// <returns></returns>
        private Vector3 GetShoulderCentre(Vector3 wsPosition, Vector3 upDirection)
        {
            return wsPosition + (upDirection * (currentScaledBottomY + currentScaledShoulderHeight));
        }

        /// <summary>
        /// Get the top position of the character, given the worldspace position.
        /// excludeRadius is useful when using capsule or sphere methods.
        /// Optional offsetY is the distance added in the upDirection.
        /// </summary>
        /// <param name="wsPosition"></param>
        /// <param name="upDirection"></param>
        /// <param name="excludeRadius"></param>
        /// <param name="offsetY"></param>
        /// <returns></returns>
        private Vector3 GetTop(Vector3 wsPosition, Vector3 upDirection, bool excludeRadius = false, float offsetY = 0f)
        {
            return wsPosition + (upDirection * (currentScaledBottomY + currentScaledHeight - (excludeRadius ? currentScaledRadius : 0f) + offsetY));
        }

        /// <summary>
        /// Get the character worldspace position given the current bottom or feet position.
        /// </summary>
        /// <param name="wsBottomPosition"></param>
        /// <param name="upDirection"></param>
        /// <returns></returns>
        private Vector3 GetWorldPositionUsingBottom(Vector3 wsBottomPosition, Vector3 upDirection)
        {
            return wsBottomPosition + (upDirection * (currentScaledHeight * 0.5f - (pivotToCentreOffsetY * currentScaledHeight / height)));
        }

        /// <summary>
        /// This gets invoked from the main loop when the user wants to delay the jump due to an animation
        /// </summary>
        private void DelayedJump()
        {
            // If still on the ground, make the jump happen this frame
            if (isGrounded) { isDelayedJumpThisFrame = true; }
            isJumpingWithDelay = false;
        }

        /// <summary>
        /// [INTERNAL ONLY]
        /// Used to change scene view items outside play mode
        /// </summary>
        public void InitialiseEditorEssentials()
        {
            if (!Application.isPlaying)
            {
                if (defaultAnimator != null) { RefreshBoneTransforms(false); }
                editorMode = true;
            }
            else
            {
                editorMode = false;
#if UNITY_EDITOR
                Debug.LogWarning("ERROR: StickyControlModule - cannot enter Edit Mode when in play mode");
#endif
            }
        }

        /// <summary>
        /// Mute or unmute all audio on the character
        /// </summary>
        /// <param name="isMuted"></param>
        private void MuteOrUnmuteAudio(bool isMuted)
        {
            isAudioMuted = isMuted;
            if (footStepsAudio != null) { footStepsAudio.mute = isMuted; }
            if (audioListener != null) { audioListener.enabled = !isMuted; }
        }

        /// <summary>
        /// Pause or unpause this character without disabling Look.
        /// See also EnableOrDisableCharacter(..).
        /// </summary>
        /// <param name="isPaused"></param>
        private void PauseOrUnPauseCharacter(bool isPaused)
        {
            if (!isPaused)
            {
                // Unpause the character

                // Restore the value when it was disabled
                lookAutoHideCursor = lookAutoHideCursorToRestore;

                // Restore previous state of isMovementEnabled if it was set.
                EnableOrDisableMovement(savedMovementState, false);

                // Restore previous state of look movement
                EnableOrDisableLookMovement(savedLookMovementState);

                // Restore previous state of isLookInteractiveEnabled if it was set.
                EnableOrDisableLookInteractive(savedLookInteractiveState == 1);

                // Restore previous state of isLookSocketsEnabled if it was set.
                EnableOrDisableLookSockets(savedLookSocketsState == 1);

                // Restore previous state of isAnimateEnabled
                EnableOrDisableAnimate(savedAnimateEnabledState);

                // Restore previous state of JetPackAvailable if it was set.
                if (savedJetPackAvailableState > 0)
                {
                    isJetPackAvailable = savedJetPackAvailableState == 1;
                }

                // Restore previous state of isDamageEnabled
                EnableOrDisableDamage(savedDamageEnabledState);

                isInputProcessed = true;
            }
            else
            {
                // Pause the character

                savedDamageEnabledState = isDamageEnabled;
                EnableOrDisableDamage(false);

                savedAnimateEnabledState = isAnimateEnabled;
                EnableOrDisableAnimate(false);

                savedLookInteractiveState = isLookInteractiveEnabled ? 1 : 2;
                EnableOrDisableLookInteractive(false);

                savedLookSocketsState = isLookSocketsEnabled ? 1 : 2;
                EnableOrDisableLookSockets(false);

                savedLookMovementState = isUpdateLookMovement;
                EnableOrDisableLookMovement(false);

                savedMovementState = isMovementEnabled;
                EnableOrDisableMovement(false, false);

                savedJetPackAvailableState = isJetPackAvailable ? 1 : 2;
                isJetPackAvailable = false;

                // Remember the AutoHideCursor setting
                lookAutoHideCursorToRestore = lookAutoHideCursor;
                // Turn it off when the character is diabled
                lookAutoHideCursor = false;
            }
        }

        /// <summary>
        /// Get the current position the third person camera should be focusing on or aiming at in camera local space
        /// </summary>
        /// <param name="focusPosition"></param>
        private void SetFocusPosition(ref Vector3 focusPosition)
        {
            if (isAimAtTargetEnabled && isThirdPerson)
            {
                /// TODO - fix third person camera focus while aiming
                /// Could add this as an option in the inspector under Aim IK on Animate tab
                /// or precalculate it
                focusPosition = new Vector3(aimIKCameraOffsetTPS.x, aimIKCameraOffsetTPS.y, 3f);
            }
            else if (isLookCameraFollowHeadTP && !(isAnimateEnabled && isHeadIK))
            {
                // This doesn't work so well when HeadIK is also enabled
                focusPosition = lookFocusOffset - optimalCameraPosition;
            }
            else
            {
                focusPosition = lookFocusOffset;
            }

            // If the height has been scaled, we need to scale the focus point up or down.
            if (!(currentScaledHeight == height || height == 0f))
            {
                focusPosition.y *= currentScaledHeight / height;
            }
        }

        /// <summary>
        /// Check if we need to and can step over an object in front.
        /// The step height is the minimum of maxStepOffset and half the character height.
        /// Get the slope in front of the character.
        /// When stepping, update the groundCollider.
        /// </summary>
        /// <param name="checkPosition"></param>
        /// <param name="moveDirection"></param>
        /// <param name="checkDistance"></param>
        /// <param name="characterUp"></param>
        /// <param name="characterFwd"></param>
        /// <param name="stepHeight"></param>
        /// <param name="slopeAngle"></param>
        /// <param name="checkClimbing"></param>
        /// <returns></returns>
        private void GetStepAndSlope
        (
            Vector3 checkPosition, Vector3 moveDirection, float checkDistance,
            Vector3 characterUp, Vector3 characterFwd,
            out float stepHeight, out float slopeAngle,
            out bool checkClimbing, out Vector3 contactPoint, out float contactHeight, out Vector3 contactNormal
        )
        {
            // Initialise step height and slope angle with default values of zero
            stepHeight = 0f;
            slopeAngle = 0f;

            // Initialise climbing and contact out variables
            checkClimbing = false;
            contactPoint = Vector3.zero;
            contactNormal = Vector3.zero;
            contactHeight = 0f;

            RaycastHit checkStepUpHit;

            // First, cast a capsule forward to see if we can find any obstacles near the feet of the character

            // Calculate the size of the capsule we will cast
            // It should not be taller than the maximum step height (any higher objects we cannot step onto anyway)
            // It also should not be taller than the height of the character (any higher objects we will pass under)
            float capsuleCastHeight = maxStepOffset > currentScaledHeight ? currentScaledHeight : maxStepOffset;
            // Calculate where the top and bottom points of the capsule are
            Vector3 bottomPoint = checkPosition;
            Vector3 topPoint = bottomPoint + (capsuleCastHeight > currentScaledRadius * 2f ? characterUp * (capsuleCastHeight - (currentScaledRadius * 2f)) : Vector3.zero);
            // Start a given distance (the sweep tolerance) backwards so that if we are up
            // against a wall, the capsule cast finds the wall
            Vector3 sweepToleranceVector = moveDirection * sweepTolerance;

            // Cast the capsule in the direction the player is moving in
            if (Physics.CapsuleCast(bottomPoint - sweepToleranceVector, topPoint - sweepToleranceVector, currentScaledRadius, moveDirection, out checkStepUpHit, checkDistance + sweepTolerance, collisionLayerMask, QueryTriggerInteraction.Ignore))
            {
                // If we hit something:

                // First, calculate how high the contact point is above the character's current 
                // position (the absolute bottom of the capsule)
                contactPoint = checkStepUpHit.point;
                contactNormal = checkStepUpHit.normal;
                // If climbing is enabled remember the Unity Layer of the object
                int collisionLayerInt = isClimbingEnabled ? checkStepUpHit.collider.gameObject.layer : 0;

                contactHeight = Vector3.Project(contactPoint - (bottomPoint - (characterUp * currentScaledRadius)), characterUp).magnitude;

                // Project the contact normal into the movement plane of the character (essentially, remove the "up" component)
                // Also, normalise it
                Vector3 projectedContactNormal = (contactNormal - Vector3.Project(contactNormal, characterUp)).normalized;

                // Find the point where we will start the raycast by starting at the contact point and then 
                // moving a small distance along the projected contact normal into the step
                // Also, we move this point upwards so as to not find false roofs below the height of the character
                float marchForwardDistance = 0.01f;
                Vector3 upwardsRaycastStartPoint = checkStepUpHit.point - (projectedContactNormal * marchForwardDistance);
                float upwardsRaycastStartHeight = capsuleCastHeight;
                upwardsRaycastStartPoint += characterUp * (upwardsRaycastStartHeight - contactHeight);
                float upwardsRaycastEndHeight = 0f;
                Vector3 downwardsRaycastStartPoint = Vector3.zero;

                // TODO for above we can probably optimise by only doing the downwards raycast if
                // max step offset is less than the current scaled height

                float stepHeightSlopeCorrection2 = 0f;

                // Next, raycast upwards by the remaining max step height
                if (Physics.Raycast(upwardsRaycastStartPoint, characterUp, out checkStepUpHit, maxStepOffset - upwardsRaycastStartHeight, collisionLayerMask, QueryTriggerInteraction.Ignore))
                {
                    // We have hit a roof, so we need to start our next raycast from this contact point
                    downwardsRaycastStartPoint = checkStepUpHit.point;
                    // Calculate how high off the ground we have reached
                    upwardsRaycastEndHeight = upwardsRaycastStartHeight + checkStepUpHit.distance;
                }
                else
                {
                    // We didn't hit anything, so we can just start our next raycast from the end of the raycast
                    downwardsRaycastStartPoint = upwardsRaycastStartPoint + (characterUp * (maxStepOffset - upwardsRaycastStartHeight));
                    // Calculate how high off the ground we have reached
                    upwardsRaycastEndHeight = maxStepOffset;
                }

                //Debug.DrawRay(downwardsRaycastStartPoint, -characterUp * upwardsRaycastEndHeight, Color.green);

                // Next, raycast downwards by the distance we have travelled above the ground so far
                // This will be used to find the actual contact point of the step, 
                // which will be used to calculate the height and slope of the step
                Vector3 stepContactPoint = Vector3.zero;
                if (Physics.Raycast(downwardsRaycastStartPoint, -characterUp, out checkStepUpHit, upwardsRaycastEndHeight, collisionLayerMask, QueryTriggerInteraction.Ignore))
                {
                    // We hit something - first check whether we have room to fit the character inside the space we found
                    // TODO this section condition probably isn't right
                    if (checkStepUpHit.distance > currentScaledHeight || capsuleCastHeight < currentScaledHeight + 0.001f)
                    {
                        // Calculate the height of the step
                        stepHeight = upwardsRaycastEndHeight - checkStepUpHit.distance;

                        // If the step height is non-zero, this is a viable step
                        if (stepHeight > 0.0001f)
                        {
                            // Get the movement slope angle based on the direction of intended movement.
                            // Vector perpendicular to both up and move directions (this will be "to the right" of the character)
                            Vector3 perpendicularDirection = Vector3.Cross(currentReferenceFrameUp, moveDirection).normalized;
                            // Vector projection of step normal onto perpendicular direction
                            Vector3 projectedStepNormal = (checkStepUpHit.normal - Vector3.Project(checkStepUpHit.normal, perpendicularDirection)).normalized;
                            // Calculate the angle from the cross product
                            slopeAngle = Mathf.Asin(Vector3.Cross(currentReferenceFrameUp, projectedStepNormal).magnitude) * Mathf.Rad2Deg;

                            // Get the step slope angle based on the direction we marched forward to cast the rays
                            // Vector perpendicular to both up and step forward directions (this will be perpendicular and 
                            // "to the right" of the step direction)
                            perpendicularDirection = Vector3.Cross(currentReferenceFrameUp, projectedContactNormal).normalized;
                            // Vector projection of step normal onto perpendicular direction
                            projectedStepNormal = (checkStepUpHit.normal - Vector3.Project(checkStepUpHit.normal, perpendicularDirection)).normalized;
                            // Calculate the angle from the cross product
                            float stepSlopeAngle = Mathf.Asin(Vector3.Cross(currentReferenceFrameUp, projectedStepNormal).magnitude) * Mathf.Rad2Deg;
                            float cosStepSlopeAngle = Mathf.Cos(stepSlopeAngle * Mathf.Deg2Rad);
                            float stepHeightSlopeCorrection1 = currentScaledRadius * (1f - cosStepSlopeAngle);
                            stepHeightSlopeCorrection2 = stepHeightSlopeCorrection1 / cosStepSlopeAngle;

                            if (slopeAngle > 0.01f)
                            {
                                // The distance we moved in the plane of movement for the character from the initial step
                                // contact point to the contact point at the top of the step is given by the march forward distance
                                // From this and the slope we can calculate the distance that we would have moved upwards over
                                // this distance if this was simply a slope and not a sloping step
                                float slopeHeightOverDist = marchForwardDistance * Mathf.Tan(stepSlopeAngle * Mathf.Deg2Rad);
                                // We can also calculate the actual distance moved upwards
                                // Assuming again that this is simply a slope, we have to do a slight correction due to the fact
                                // that the original contact point was obtained from a capsule cast - so it will not have been at the
                                // very bottom of the capsule (which is where the step height is measured from)
                                float actualHeightOverDist = stepHeight - stepHeightSlopeCorrection2;

                                // #SMS added in 1.0.0 Beta 2s
                                // VERY quick hack to allow walking onto x-axis tilted slopes (relative to character forward)
                                // A (bad) side-effect of this hack is that you can slide up steps... so ignore when no forward/back input.
                                if (slopeHeightOverDist > -0.001f && slopeHeightOverDist < 0.001f && currentLocalSpaceMovementInput.z != 0f)
                                {
                                    // THIS NEEDS TO BE FIXED
                                    stepHeightSlopeCorrection2 = currentScaledRadius * 0.5f;
                                }
                                // Now we can compare the two values to see if they match
                                else if (actualHeightOverDist > slopeHeightOverDist + 0.0001f)
                                {
                                    // The step height was greater than the expected slope height - so this is a sloping step
                                    // Hence we need to subtract the slope height over the distance from the step height
                                    stepHeight -= slopeHeightOverDist; // TODO not really sure about this...
                                }
                                else
                                {
                                    // This is a slope, not a step
                                    stepHeight = 0f;
                                    // The collider needs to be climbable. Also, we cannot climb a walkable slope.
                                    checkClimbing = (climbableLayerMask & (1 << collisionLayerInt)) != 0 && slopeAngle > maxSlopeAngle;
                                }
                            }

                            if (stepHeight > 0f)
                            {
                                groundCollider = checkStepUpHit.collider;
                            }

                            // Remember the contact point of the step
                            stepContactPoint = checkStepUpHit.point;
                        }
                        else
                        {
                            // Step is probably too high
                            stepHeight = 0f;
                            checkClimbing = (climbableLayerMask & (1 << collisionLayerInt)) != 0 && contactNormal != characterUp;
                        }
                    }
                    else
                    {
                        stepHeight = 0f;
                        // Is the contact point collider climbable?
                        checkClimbing = (climbableLayerMask & (1 << collisionLayerInt)) != 0 && contactNormal != characterUp;
                    }
                }
                else
                {
                    // If we hit nothing, then there is nothing we can step over
                    stepHeight = 0f;

                    // Is the contact point collider climbable?
                    checkClimbing = (climbableLayerMask & (1 << collisionLayerInt)) != 0 && contactNormal != characterUp;
                }

                // If we are stepping up, check if we can actually fit on the step
                if (stepHeight > 0f)
                {
                    // Check if there are obstacles blocking the character from fitting in the destination on the step
                    // Allow for 0.1mm of inaccuracy
                    // Also need to do a slight correction if we are on a sloping step, to make sure that the capsule cast
                    // does not clip into the step itself
                    if (CheckCapsule(stepContactPoint + (characterUp * (stepHeightSlopeCorrection2 + 0.0001f)), characterUp, currentScaledHeight))
                    {
                        stepHeight = 0f;
                    }
                }
            }
#if UNITY_EDITOR
            else
            {
                //Debug.Log("[DEBUG] No object at feet checkDistance: " + checkDistance + " T:" + Time.time);
            }
#endif
        }

        /// <summary>
        /// Attempt to find the ground. Should only be used when there is no reference frame
        /// and the update mode is set to automatic or auto-first.
        /// </summary>
        private void FindInitialReferenceFrame()
        {
            if (currentReferenceFrame == null)
            {
                // If this is the first time we're using rotation and world position, get it from the transform.
                if (currentWorldRotation == Quaternion.identity) { currentWorldRotation = transform.rotation; }
                if (currentWorldPosition == Vector3.zero) { currentWorldPosition = transform.position; }

                // Cast a ray directly downwards to find the nearest ground
                raycastRay.direction = currentWorldRotation * -Vector3.up;
                // Start sweepTolerance above the bottom of the character to cater for when character is already on the ground.
                raycastRay.origin = currentWorldPosition + raycastRay.direction * (-currentScaledBottomY - sweepTolerance);

                if (Physics.Raycast(raycastRay, out raycastHitInfo, 1000f, referenceFrameLayerMask, QueryTriggerInteraction.Ignore))
                {
                    if (isUseRBodyReferenceFrame && raycastHitInfo.rigidbody != null)
                    {
                        initialReferenceFrame = raycastHitInfo.rigidbody.transform;
                    }
                    else
                    {
                        initialReferenceFrame = raycastHitInfo.transform;
                    }

                    SetCurrentReferenceFrame(raycastHitInfo.transform);
                }
            }
        }

        private void InitialiseScaledValues()
        {
            currentScaledHeight = height;
            prevScaledHeight = height;
            currentScaledRadius = radius;
            currentScaledBottomY = pivotToCentreOffsetY - (height * 0.5f);
            currentScaledShoulderHeight = shoulderHeight;
        }

        /// <summary>
        /// Check to see if a current layer (say 27) is in the LayerMask supplied
        /// </summary>
        /// <param name="layerMask"></param>
        /// <param name="layerNumber"></param>
        /// <returns></returns>
        private bool IsLayerInMask(LayerMask layerMask, int layerNumber)
        {
            return (layerMask & 1 << layerNumber) != 0;
        }

        /// <summary>
        /// Show or hide the hardware (mouse) cursor in the game view
        /// NOTE: This will sometimes fail to turn off the cursor in the editor
        /// Game View when it doesn't have focus, but will work fine in a build.
        /// </summary>
        /// <param name="isShown"></param>
        private void ShowOrHideCursor(bool isShown)
        {
            Cursor.visible = isShown;
            lookShowCursor = isShown;
            if (isShown) { cursorTimer = 0f; }
        }

        /// <summary>
        /// Used with CentreCursor()
        /// </summary>
        /// <returns></returns>
        private IEnumerator UnlockCursor()
        {
            yield return new WaitForEndOfFrame();
            Cursor.lockState = CursorLockMode.None;
        }

        /// <summary>
        /// Updates the local variable for the mouse position.
        /// </summary>
        private void UpdateCurrentMousePosition()
        {
            // Centre of the screen is mouse position x:0.5 y:0.5 z:0
#if SSC_UIS
            currentMousePosition = UnityEngine.InputSystem.Mouse.current.position.ReadValue();
#elif ENABLE_LEGACY_INPUT_MANAGER
            if (Input.mousePresent)
            {
                currentMousePosition = Input.mousePosition;
            }
            else
            {
                // Return the centre of the screen
                currentMousePosition.x = Screen.width * 0.5f;
                currentMousePosition.y = Screen.height * 0.5f;
            }
#else
            // Currently just return centre of screen if UIS and/or Legacy input system not enabled.
            currentMousePosition.x = Screen.width * 0.5f;
            currentMousePosition.y = Screen.height * 0.5f;
#endif
        }

        #endregion

        #region Private and Internal Methods - Move

        /// <summary>
        /// Apply a force to a point on the character which will dissipate over the duration. 
        /// NOTE: Currently ignores point.
        /// </summary>
        /// <param name="forceDirection">The direction the force should act upon the character</param>
        /// <param name="forceAmount">Initial force to apply in Newtons</param>
        /// <param name="duration">The number of seconds the force will act upon the character</param>
        /// <param name="point">Where to apply the force in world space</param>
        private void ApplyForceAtPoint(Vector3 forceDirection, float forceAmount, float duration, Vector3 point)
        {
            // The force is always applied from the same world-space direction
            applyForceDirection = forceDirection;
            applyForceAmount = forceAmount;
            applyForceTimer = duration;
            applyForceDuration = duration;

            // Convert to local space, as the point of impact on the character should not
            // change if the character moves after the impact occurs.
            applyForcePointLS = GetLocalPosition(point);
        }

        /// <summary>
        /// Get additional local space velocity as the result of additional force being applied to a point on the character
        /// </summary>
        /// <returns></returns>
        private Vector3 CalculateVeloForceAtPoint()
        {
            if (!isPositionLocked && applyForceTimer > 0f)
            {
                float _deltaTime = Time.deltaTime;
                Vector3 addVelocityLS = Vector3.zero;

                // Force dissipates in a linear manner over the duration it is applied.
                float currentForceAmount = applyForceAmount * applyForceTimer / applyForceDuration;

                // The world space impact direction does not change after impact (for example, from a moving projectile),
                // however the local space direction needs to be calculated every fram.
                Vector3 forceDirectionLS = GetLocalDirection(applyForceDirection);

                // change the velocity of the character by applyForceAmount * _deltaTime / mass.
                addVelocityLS = forceDirectionLS * (currentForceAmount * _deltaTime / rBody.mass);

                applyForceTimer -= _deltaTime;

                // Stop force when close to 0.
                if (applyForceTimer <= 0.01f || applyForceAmount < 0.001f)
                {
                    applyForceTimer = 0f;
                    applyForceAmount = 0f;
                }

                return addVelocityLS;
            }
            else { return Vector3.zero; }
        }

        /// <summary>
        /// Check if the shoulders are level with or above the top edge of the climbable obstacle
        /// </summary>
        /// <param name="stepVertical"></param>
        private void CheckIsClimbingAtTop(float stepVertical)
        {
            Vector3 shoulderPos = GetShoulderCentre(currentWorldPosition, currentCharacterUp);

            // Can we climb onto the top of a collidable object?
            // NOTE we check the collisionLayerMask not the climbableLayerMask as we are checking for any object that is in the way.
            // Start looking at the edge of the character, immediately in-front of the shoulders.
            if (climbTopDetection && (stepVertical < 0.0001f || stepVertical > 0.0001f) &&
                !Physics.Raycast(shoulderPos + (currentCharacterFwd * currentScaledRadius), currentCharacterFwd, currentScaledRadius * 2f, collisionLayerMask, QueryTriggerInteraction.Ignore))
            {
                //Debug.Log("[DEBUG] Climbing up near top of wall T:" + Time.time);

                isClimbingAtTop = true;
            }
            else { isClimbingAtTop = false; }
        }

        /// <summary>
        /// Check if the character is stuck.
        /// Invoke the callback method if it is defined.
        /// </summary>
        private void CheckIsStuck()
        {
            if (!isInitialised || stuckTime <= 0f) { isStuck = false; }
            else
            {
                // velo in m/s
                if (currentLocalVelocity.z > stuckSpeedThreshold || currentLocalVelocity.z < -stuckSpeedThreshold)
                {
                    stuckTimer = 0f;
                    isStuck = false;
                }
                // Check if character is trying to move
                else if (currentLocalSpaceMovementInput != Vector3.zero)
                {
                    stuckTimer += Time.deltaTime;
                    isStuck = stuckTimer >= stuckTime;

                    if (isStuck && callbackOnStuck != null) { callbackOnStuck(this); }
                }
            }
        }

        /// <summary>
        /// This is a state when the NPC or Player cannot make the character move,
        /// while the character's position and rotation can still be updated to keep
        /// in sync with the reference frame.
        /// </summary>
        /// <param name="isEnabled"></param>
        internal void EnableOrDisableLockPosition(bool isEnabled)
        {
            isPositionLocked = isEnabled;
        }

        /// <summary>
        /// Is character moment permitted?
        /// </summary>
        /// <param name="isEnabled"></param>
        /// <param name="resetVelocity"></param>
        internal void EnableOrDisableMovement(bool isEnabled, bool resetVelocity)
        {
            isMovementEnabled = isEnabled;

            if (resetVelocity) { StopMoving(); }

            // Updated animations which should stop all movement-related animation
            if (!isEnabled && numAnimateActions > 0)
            {
                // Damping on animation values could leave some values in a intermediate
                // state if more values are not sent to the animator controller.
                // NOTE: This may affect the smoothness of other non-movement animations...
                AnimateCharacter(true);
            }
        }

        /// <summary>
        /// Is the character permitted to climb walls and slopes?
        /// </summary>
        /// <param name="isEnabled"></param>
        internal void EnableOrDisableClimbing(bool isEnabled)
        {
            isClimbingEnabled = isEnabled;

            if (isClimbingEnabled)
            {
                // Validate Climbing settings
                if (minClimbSlopeAngle < maxSlopeAngle)
                {
#if UNITY_EDITOR
                    Debug.LogWarning("StickyControlModule - EnableClimbing changed minClimbSlopeAngle to match the general maxSlopeAngle");
#endif
                    minClimbSlopeAngle = maxSlopeAngle;
                }
                if (maxClimbSlopeAngle < minClimbSlopeAngle)
                {
#if UNITY_EDITOR
                    Debug.LogWarning("StickyControlModule - EnableClimbing changed maxClimbSlopeAngle to match the minClimbSlopeAngle");
#endif
                    maxClimbSlopeAngle = minClimbSlopeAngle;
                }

                isClimbingAtTop = false;
            }
            else
            {
                // Stop climping if it becomes disabled
                isClimbing = false;
                isClimbingAtTop = false;
            }
        }

        /// <summary>
        /// Process the foot steps for this frame
        /// </summary>
        private void ProcessFootSteps()
        {
            if (footStepsUseMoveSpeed)
            {
                // Are we moving on local x or z axis? Get absolute speeds
                float fwdBackSpeed = currentLocalVelocity.z < -moveIdleThreshold ? -currentLocalVelocity.z : currentLocalVelocity.z > moveIdleThreshold ? currentLocalVelocity.z : 0f;
                float strafeSpeed = currentLocalVelocity.x < -moveIdleThreshold ? -currentLocalVelocity.x : currentLocalVelocity.x > moveIdleThreshold ? currentLocalVelocity.x : 0f;

                float absMoveSpeed = fwdBackSpeed > strafeSpeed ? fwdBackSpeed : strafeSpeed;

                if (absMoveSpeed > 0f)
                {
                    footStepTimer += Time.deltaTime;

                    // There are 2 feet so multiple by 0.5.
                    float stepInterval = (absMoveSpeed > walkSpeed ? 1f / footStepSprintFrequency : 1f / footStepWalkFrequency) * 0.5f;
                    // Consider the actual moving speed
                    stepInterval *= 1f / absMoveSpeed;

                    if (footStepTimer >= stepInterval)
                    {
                        PlayFootStep();
                        footStepTimer = 0f;
                    }
                }
                else
                {
                    // Not moving so reset timer
                    footStepTimer = 0f;
                }
            }
            else
            {
                // Check the feet - y-axis offset in local space
            }
        }

        /// <summary>
        /// Play a footstep audio clip
        /// </summary>
        internal void PlayFootStep()
        {
            if (isFootStepsAvailable)
            {
                AudioClip audioClip = null;

                // Provide a default slight deviation
                float minVolume = 0.9f;
                float maxVolume = 1.0f;
                float minPitch = 0.9f;
                float maxPitch = 1.0f;

                // Are there any Footstep Surfaces configured?
                if (numFootSteps > 0)
                {
                    S3DFootstep s3dFootstep = null;

                    if (groundCollider != null)
                    {
                        // Does this collider have a StickySurface component?
                        groundCollider.GetComponents(stickySurfaceList);

                        if (stickySurfaceList != null && stickySurfaceList.Count > 0)
                        {
                            // What is the Surface Type assigned to this collider?
                            StickySurface stickySurface = stickySurfaceList[0];

                            if (stickySurface.isTerrain)
                            {
                                // Check terrain textures
                                for (int fsIdx = 0; fsIdx < numFootSteps; fsIdx++)
                                {
                                    S3DFootstep footstep = s3dFootstepList[fsIdx];

                                    // Does this footstep surface action have any Terrain Textures configured?
                                    if (footstep != null && footstep.numTerrainTextures > 0)
                                    {
                                        // Optimise for a single Terrain Texture test
                                        if (footstep.numTerrainTextures == 1)
                                        {
                                            S3DTerrainTexture s3dTerrainTexture = footstep.s3dTerrainTextureList[0];

                                            if (stickySurface.GetTextureAtPosition(groundHitPoint, s3dTerrainTexture.MinWeight) == s3dTerrainTexture.ID)
                                            {
                                                s3dFootstep = footstep;
                                                break;
                                            }
                                        }
                                        // Check multiple terrain textures with their min weights
                                        else if (stickySurface.IsTextureAtPosition(groundHitPoint, footstep.terrainTextureIDArray, footstep.terrainTextureWeightArray))
                                        {
                                            s3dFootstep = footstep;
                                            break;
                                        }
                                    }
                                }
                            }
                            else
                            {
                                // Find first matching mesh surface type in list of S3DFootsteps
                                int guidHashSurfaceType = stickySurface.guidHashSurfaceType;

                                for (int fsIdx = 0; fsIdx < numFootSteps; fsIdx++)
                                {
                                    S3DFootstep footstep = s3dFootstepList[fsIdx];
                                    if (footstep != null && footstep.GetSurfaceTypeIndex(guidHashSurfaceType) >= 0)
                                    {
                                        s3dFootstep = footstep;
                                        break;
                                    }
                                }
                            }
                        }
                    }

                    // If not muted, determine which audio clip to play (if any)
                    if (!isAudioMuted)
                    {
                        if (s3dFootstep == null || s3dFootstep.numAudioClips == 0)
                        {
                            audioClip = footStepsDefaultClip;
                        }
                        else
                        {
                            if (s3dFootstep.numAudioClips == 1)
                            {
                                audioClip = s3dFootstep.audioclipList[0];
                            }
                            else
                            {
                                // FUTURE: Use other methods like alternating first to last.

                                // Randomly assign a clip
                                int audioClipIdx = audioclipRandom.Range(0, s3dFootstep.numAudioClips - 1);
                                audioClip = s3dFootstep.audioclipList[audioClipIdx];
                            }

                            minVolume = s3dFootstep.minVolume;
                            maxVolume = s3dFootstep.maxVolume;
                            minPitch = s3dFootstep.minPitch;
                            maxPitch = s3dFootstep.maxPitch;
                        }
                    }

                    // Future - Determine which particle effect to play when foot stikes the ground
                }

                if (!isAudioMuted)
                {
                    // If there is no matching audioClip, attempt to use the default
                    if (audioClip == null) { audioClip = footStepsDefaultClip; }

                    if (audioClip != null)
                    {
                        // If minVolume is close to maxVolume, use maxVolume
                        footStepsAudio.volume = (minVolume > maxVolume - 0.001f ? maxVolume : audioclipRandom.Range(minVolume, maxVolume)) * footStepsVolume;
                        // If minPitch is close to maxPitch, use maxPitch
                        footStepsAudio.pitch = minPitch > maxPitch - 0.001f ? maxPitch : audioclipRandom.Range(minPitch, maxPitch);

                        footStepsAudio.PlayOneShot(audioClip);
                    }
                }
            }
        }

        #endregion

        #region Private and Internal Methods - Look General

        /// <summary>
        /// Calculate and update the firstPersonCameraFeetOffsetY from the
        /// camera local position OR the auto height of eyes.
        /// </summary>
        /// <param name="cameraTransform"></param>
        private void CalcFirstPersonFeetOffsetY(Transform cameraTransform)
        {
            if (isAutoFirstPersonCameraHeight) { firstPersonCameraFeetOffsetY = 0.942f; }
            else
            {
                // Offset from feet
                float _cameraOffsetY = cameraTransform.localPosition.y - pivotToCentreOffsetY + (currentScaledHeight * 0.5f);

                firstPersonCameraFeetOffsetY = currentScaledHeight == 0 ? 0f : _cameraOffsetY / currentScaledHeight;
            }
        }

        /// <summary>
        /// Enable or disable the gameobject for the camera(s).
        /// Updates isLookEnabled. Enables or disables the Audio Listener if there
        /// is one and it was enabled when this module was initialised.
        /// Enable or disable look camera movement.
        /// </summary>
        /// <param name="isEnabled"></param>
        private void EnableOrDisableLook(bool isEnabled)
        {
            if (lookCamera1 != null)
            {
                // When enabling look, if the gameobject is disabled, activate it first
                if (isEnabled && !lookCamera1.gameObject.activeSelf) { lookCamera1.gameObject.SetActive(true); }

                isLookEnabled = isEnabled;

                lookCamera1.enabled = isEnabled;

                if (isAudioListenerConfigured && audioListener != null) { audioListener.enabled = isEnabled; }

                // Attempt to enable or diable look movement
                EnableOrDisableLookMovement(isEnabled);

                isLookVREnabled = isLookVR && IsLookVRAvailable;

                // Currently LookVR requires Free Look.
                if (isLookVREnabled && !isNPC) { isFreeLook = true; }

                // When disabling look, also disable the gameobject
                if (!isEnabled && lookCamera1.gameObject.activeSelf) { lookCamera1.gameObject.SetActive(false); }
            }
            else
            {
                EnableOrDisableLookMovement(false);

                isLookVREnabled = false;
                isLookEnabled = false;
            }

            // Reset the last point we were looking at (assuming Look Interactive was enabled)
            lookingAtPoint = Vector3.zero;
        }

        /// <summary>
        /// Enable or disable camera movement.
        /// </summary>
        /// <param name="isEnabled"></param>
        private void EnableOrDisableLookMovement(bool isEnabled)
        {
            if (isEnabled)
            {
                isUpdateLookMovement = lookTransform != null;
            }
            else
            {
                isUpdateLookMovement = false;
            }
        }

        /// <summary>
        /// Return the adjusted (height) local position of the first person camera.
        /// </summary>
        /// <param name="currentLocalPos"></param>
        /// <returns></returns>
        private Vector3 GetFirstPersonCameraHeight(Vector3 currentLocalPos)
        {
            // Camera to be offset on the y-axis from the centre of the character
            currentLocalPos.y = (currentScaledHeight * 0.5f) - (currentScaledHeight * (1f - firstPersonCameraFeetOffsetY)) + (pivotToCentreOffsetY * currentScaledHeight / height);

            return currentLocalPos;

            //return new Vector3(currentLocalPos.x, (currentScaledHeight * 0.5f) - (currentScaledHeight * (1f - firstPersonCameraFeetOffsetY)) + (pivotToCentreOffsetY * currentScaledHeight / height), currentLocalPos.z);
        }

        /// <summary>
        /// Attempt to not fly through objects in the scene that are in the clipObjectMask layer(s)
        /// </summary>
        /// <param name="aimAtPosition"></param>
        /// <param name="targetRotWS"></param>
        /// <param name="cameraPosition"></param>
        /// <param name="cameraRotation"></param>
        /// <param name="prevClipHitDistance"></param>
        /// <returns></returns>
        private bool ObjectClipping(Vector3 aimAtPosition, Quaternion targetRotWS, ref Vector3 cameraPosition, ref Quaternion cameraRotation, ref float prevClipHitDistance)
        {
            // Convert things from local space to world space for use with Physics.BoxCast().
            Vector3 _cameraPosWS = GetWorldPosition(cameraPosition);
            Vector3 _aimAtPosWS = GetWorldPosition(aimAtPosition);

            // Get the WS direction looking from the target to the camera.
            Vector3 clipLookDirection = (_cameraPosWS - _aimAtPosWS).normalized;

            // BoxCast needs values in world space
            Vector3 clipStartPosWS = clipMinDistance > 0f ? _aimAtPosWS + (clipLookDirection * clipMinDistance) : _aimAtPosWS;

            // The distance between the character (or character + clipMinDistance) and the camera LESS the camera near clip plane (don't need
            // to check what camera does not render).
            float clipCheckDistance = Vector3.Distance(clipStartPosWS, _cameraPosWS) - lookCamera1.nearClipPlane;

            RaycastHit clipHit;
            float clipVelo = 0f;
            if (Physics.BoxCast(clipStartPosWS, viewHalfExtents, clipLookDirection, out clipHit,
                GetWorldRotation(cameraRotation), clipCheckDistance, clipObjectMask, QueryTriggerInteraction.Ignore))
            {
                if (clipResponsiveness < 1f)
                {
                    prevClipHitDistance = Mathf.SmoothDamp(prevClipHitDistance, clipHit.distance, ref clipVelo, 1f - clipResponsiveness);
                }
                else { prevClipHitDistance = clipHit.distance; }
            }
            else
            {
                if (clipResponsiveness < 1f)
                {
                    prevClipHitDistance = Mathf.SmoothDamp(prevClipHitDistance, 0f, ref clipVelo, 1f - clipResponsiveness);
                }
                else { prevClipHitDistance = 0f; }
            }

            if (prevClipHitDistance > 0.001f)
            {
                // The near clip plane should be placed in front of the obstacle. By not adding the nearClipPlane
                // onto the hit distance, it should cater for situations where the obstacle normal is not aligned with the clipLookDirection.
                _cameraPosWS = clipStartPosWS + (clipLookDirection * prevClipHitDistance);

                if (clipMinOffsetX > 0f || clipMinOffsetY > 0f)
                {
                    // Get local space offset
                    Vector3 currentOffset = Quaternion.Inverse(targetRotWS) * (_cameraPosWS - _aimAtPosWS);

                    if (currentOffset.y < clipMinOffsetY || currentOffset.x < clipMinOffsetX)
                    {
                        _cameraPosWS = _aimAtPosWS + (targetRotWS * new Vector3(currentOffset.x < clipMinOffsetX ? clipMinOffsetX : currentOffset.x, currentOffset.y < clipMinOffsetY ? clipMinOffsetY : currentOffset.y, currentOffset.z));
                    }
                }

                // Convert world space back into local space
                cameraPosition = Quaternion.Inverse(targetRotWS) * (_cameraPosWS - currentWorldPosition);

                return true;
            }
            else
            {
                prevClipHitDistance = 0f;

                return false;
            }
        }

        /// <summary>
        /// Return the current mouse pointer position as a clamped screen space.
        /// If look is not enabled or isRequireFreeLook is true but isFreeLook
        /// is not, this will return the centre of the screen.
        /// NOTE: Assumes mouse is over first screen / display monitor.
        /// </summary>
        /// <returns></returns>
        internal Vector2 MouseScreenPoint(bool isRequireFreeLook)
        {
            if (isLookEnabled && !isNPC && (!isRequireFreeLook || isFreeLook))
            {
                // If the mouse is outside the viewing area cap the values between 0.0 and Screen width/height

                // It is safe to switch between Vector3 and Vector2 as each has an expicit
                // operator which either adds z = 0 or drops the z component.
                return S3DMath.Clamp(currentMousePosition, 0f, Screen.width, 0f, Screen.height);
            }
            else { return new Vector2(Screen.width * 0.5f, Screen.height * 0.5f); }
        }

        /// <summary>
        /// Return the current mouse pointer position in viewport space.
        /// If look is not enabled will return 0.5, 0.5.
        /// </summary>
        /// <returns></returns>
        private Vector2 MouseViewportPoint()
        {
            if (isLookEnabled && !isNPC && lookCamera1 != null)
            {
                // If the mouse is outside the viewing area cap the values between 0.0 and 1.0

                // It is safe to switch between Vector3 and Vector2 as each has an expicit
                // operator which either adds z = 0 or drops the z component.
                return S3DMath.Clamp(lookCamera1.ScreenToViewportPoint(currentMousePosition));
            }
            else { return new Vector2(0.5f, 0.5f); }
        }

        private Vector3 SmoothFollowPosition(Vector3 currentPosition, Vector3 previousTargetPosition, Vector3 currentTargetPosition, float deltaTime, float speed)
        {
            float speedTimeProduct = deltaTime * speed;

            if (speedTimeProduct == 0f) { return currentPosition; }
            else
            {
                Vector3 v = (currentTargetPosition - previousTargetPosition) / speedTimeProduct;
                Vector3 f = currentPosition - previousTargetPosition + v;
                return currentTargetPosition - v + f * Mathf.Exp(-speedTimeProduct);
            }
        }

        #endregion

        #region Private and Internal Methods - Look Interactive

        /// <summary>
        /// Check if the character is looking at an interactive-enabled object.
        /// Also checks to see if the item hasn't been destroyed.
        /// </summary>
        /// <returns></returns>
        private bool CheckLookingAtInteractive()
        {
            bool isLookingAtSomething = false;

            // Are we currently looking at an interactive-enabled object?
            if (isInitialised && lookingAtInteractiveId != StickyInteractive.NoID)
            {
                // Check that it hasn't been destroyed
                if (lookingAtInteractive == null)
                {
                    // Remove it from the selected list if it has previously been selected
                    RemoveSelectedInteractiveID(lookingAtInteractiveId);

                    // Cannot find it so assume character is no longer looking at it
                    lookingAtInteractiveId = StickyInteractive.NoID;

                    lookingAtPoint = Vector3.zero;
                }
                else
                {
                    isLookingAtSomething = true;
                }
            }

            return isLookingAtSomething;
        }

        /// <summary>
        /// Enable or disable looking at interactive-enabled objects
        /// </summary>
        /// <param name="isEnabled"></param>
        private void EnableOrDisableLookInteractive(bool isEnabled)
        {
            isLookInteractiveEnabled = isEnabled;

            // Reset the interactive object being looked at
            lookingAtInteractive = null;
            lookingAtInteractiveId = StickyInteractive.NoID;

            if (isEnabled) { lookingAtPoint = Vector3.zero; }
        }

        /// <summary>
        /// Ok, not a great name for this method...
        /// When isLookInteractiveEnabled is true, check if the the player is looking at an interactable-enabled object.
        /// To be seen, interactive-enabled objects must have a non-trigger collider.
        /// To debug in play mode, turn on Debug Mode on the character and check the Looking At label in the Inspector.
        /// This is NOT used for Look VR. See Sticky XR Interactor instead.
        /// </summary>
        private void SeekInteractiveObjects(Vector2 screenPosition)
        {
            RaycastHit raycastHit = new RaycastHit();
            // Ignore trigger colliders except other S3D characters
            if (IsHitLookOther(lookMaxInteractiveDistance, screenPosition, ref raycastHit, false, lookInteractiveLayerMask, false))
            {
                if (isUpdateLookingAtPoint) { lookingAtPoint = raycastHit.point; }

                // Is what we're looking at an iteractive-enabled object?
                StickyInteractive stickyInteractive = null;

                // If the colliders are not on the parent, then maybe it has a rigidbody and we can find it that way.
                if (!raycastHit.collider.gameObject.TryGetComponent(out stickyInteractive))
                {
                    Rigidbody hitRbody = raycastHit.rigidbody;

                    if (hitRbody == null || !hitRbody.TryGetComponent(out stickyInteractive))
                    {
                        // No rigidbody on parent so check if there is a StickyInteractChild component on the collider
                        StickyInteractiveChild stickyInteractiveChild = null;
                        if (raycastHit.collider.gameObject.TryGetComponent(out stickyInteractiveChild))
                        {
                            stickyInteractive = stickyInteractiveChild.stickyInteractive;
                        }
                    }
                }

                if (stickyInteractive != null)
                {
                    // Is it a different object than the one we were looking at?
                    if (lookingAtInteractiveId != stickyInteractive.StickyInteractiveID)
                    {
                        StickyInteractive oldLookAt = lookingAtInteractive;
                        int oldLookAtInteractiveID = oldLookAt == null ? StickyInteractive.NoID : oldLookAt.StickyInteractiveID;

                        // Call all onHoverExit methods (or set properties etc) and pass in the previously set StickyInteractiveID and the ID of this character.
                        if (oldLookAt != null && oldLookAt.onHoverExit != null)
                        {
                            oldLookAt.onHoverExit.Invoke(oldLookAtInteractiveID, StickyID);
                        }

                        // Change to the new Look At object
                        lookingAtInteractiveId = stickyInteractive.StickyInteractiveID;
                        lookingAtInteractive = stickyInteractive;

                        // These are called BEFORE onHoverEnter events on the interactive object so that they don't overwrite actions on the interactive objects themselves
                        if (onInteractLookAtChanged != null)
                        {
                            onInteractLookAtChanged.Invoke(StickyID, oldLookAtInteractiveID, lookingAtInteractiveId, engageColour);
                        }

                        // Call all onHoverEnter methods (or set properties etc) and pass in the hitpoint, hitnormal, StickyInteractiveID and the ID of this character.
                        if (stickyInteractive.onHoverEnter != null) { stickyInteractive.onHoverEnter.Invoke(raycastHit.point, raycastHit.normal, lookingAtInteractiveId, StickyID); }

                        // The StickyInteractive being looked at has been changed, so call the callback if it has been set
                        if (callbackOnChangeLookAtInteractive != null)
                        {
                            callbackOnChangeLookAtInteractive(this, oldLookAt, lookingAtInteractive);
                        }
                    }
                }
                // We are no longer looking at an interactive-enabled object
                else
                {
                    StopLookAtInteractive();
                }
            }
            // The raycast failed to hit anything
            else
            {
                // The raycast failed to hit anything when previously was looking at an interactive-enabled object
                if (lookingAtInteractiveId != StickyInteractive.NoID)
                {
                    StopLookAtInteractive();
                }

                if (isUpdateLookingAtPoint && isLookEnabled)
                {
                    Ray ray = lookCamera1.ScreenPointToRay(screenPosition);
                    lookingAtPoint = ray.GetPoint(lookMaxInteractiveDistance);
                }
            }
        }

        #endregion

        #region Private and Internal Methods - Look Sockets

        /// <summary>
        /// Check if the character is looking at a StickySocket.
        /// Also checks to see if the socket hasn't been destroyed.
        /// </summary>
        /// <returns></returns>
        private bool CheckLookingAtSocket()
        {
            bool isLookingAtSomething = false;

            // Are we currently looking at a StickySocket?
            if (isInitialised && lookingAtSocketId != StickySocket.NoID)
            {
                // Check that it hasn't been destroyed
                if (lookingAtSocket == null)
                {
                    // Cannot find it so assume character is no longer looking at it
                    lookingAtSocketId = StickySocket.NoID;
                }
                else
                {
                    isLookingAtSomething = true;
                }
            }

            return isLookingAtSomething;
        }

        /// <summary>
        /// Enable or disable looking at sockets
        /// </summary>
        /// <param name="isEnabled"></param>
        private void EnableOrDisableLookSockets(bool isEnabled)
        {
            isLookSocketsEnabled = isEnabled;

            if (!isEnabled)
            {
                StopLookAtSocket();
            }

            // Reset the socket being looked at
            lookingAtSocket = null;
            lookingAtSocketId = StickySocket.NoID;

            if (isEnabled && socketActiveMaterial == null)
            {
                Material defaultMaterial = S3DUtils.GetDefaultMaterial();
                if (defaultMaterial != null)
                {
                    socketActiveMaterial = new Material(defaultMaterial);
                    S3DUtils.ConfigureFadeMaterial(socketActiveMaterial, new Color(0f, 0f, 1f, 0.1f));
                }
                #if UNITY_EDITOR
                else { Debug.LogWarning("ERROR: Could not create Socket Active Material. Try setting it in the editor on the Look tab for " + name); }
                #endif
            }

            //if (isEnabled) { lookingAtPoint = Vector3.zero; }
        }

        /// <summary>
        /// When isLookSocketsEnabled is true, check if the the player is looking at a StickySocket.
        /// To be seen, the StickySocket must have a trigger collider.
        /// </summary>
        /// <param name="screenPosition"></param>
        private void SeekSockets (Vector2 screenPosition)
        {
            bool _isHit = false;

            Vector3 lookFrom = isLookEnabled ? (isThirdPerson ? currentCameraPosWS : lookTransform.position) : GetWorldEyePosition();
            Vector3 lookDirection = isLookEnabled ? (isThirdPerson ? currentCameraRotWS : lookTransform.rotation) * Vector3.forward : currentCharacterFwd;

            // Temp re-useable hit array.
            if (raycastHitInfoArray == null) { raycastHitInfoArray = new RaycastHit[20]; }

            // the Vector3.z is automatically set to 0 when the vector2 is implicitly converted to a vector3.
            Ray ray = isLookEnabled ? lookCamera1.ScreenPointToRay(screenPosition) : new Ray(lookFrom, lookDirection);

            // Get all hits between lookFrom position and the distance away in the lookDirection given. Include triggers.
            // NOTE: RaycastNonAlloc, like other 3D multi-hit physics items, returns an UNSORTED array.
            int numHits = Physics.RaycastNonAlloc(ray, raycastHitInfoArray, lookMaxSocketDistance + 1f, lookSocketLayerMask, QueryTriggerInteraction.Collide);

            if (numHits > 1) { S3DUtils.SortHitsAsc(raycastHitInfoArray, numHits); }

            StickySocket hitSocket;

            for (int hIdx = 0; hIdx < numHits; hIdx++)
            {
                RaycastHit hitInfo = raycastHitInfoArray[hIdx];

                Collider hitCollider = hitInfo.collider;

                // Ignore colliders on this character
                if (IsColliderSelf(hitCollider.GetInstanceID())) { continue; }
                // Did we hit a regular collider?
                else if (!hitCollider.isTrigger)
                {
                    break;
                }
                // Did we hit a trigger collider attached to a StickySocket?
                else if (hitCollider.TryGetComponent(out hitSocket))
                {
                    _isHit = true;
                    int hitSocketID = hitSocket.SocketID;

                    // Is it different from the socket we were looking at?
                    if (hitSocketID != lookingAtSocketId)
                    {
                        StickySocket oldLookAt = lookingAtSocket;
                        int oldLookAtSocketID = oldLookAt == null ? StickySocket.NoID : oldLookAt.SocketID;

                        // Stop looking at the previous socket
                        if (oldLookAtSocketID != StickySocket.NoID)
                        {
                            if (isLookSocketAutoShow) { oldLookAt.HideSocket(); }

                            // Call all onHoverExit methods (or set properties etc) and pass in the previously set SocketID and the ID of this character.
                            if (oldLookAt.onHoverExit != null)
                            {
                                oldLookAt.onHoverExit.Invoke(oldLookAtSocketID, StickyID);
                            }
                        }

                        // Change to the new Look At object
                        lookingAtSocket = hitSocket;
                        lookingAtSocketId = hitSocket.SocketID;

                        if (isLookSocketAutoShow) { hitSocket.ShowSocket(socketActiveMaterial); }

                        // NOT YET IMPLEMENTED
                        // These are called BEFORE onHoverEnter events on the socket so that they don't overwrite actions on the sockets themselves
                        //if (onSocketLookAtChanged != null)
                        //{
                        //    onSocketLookAtChanged.Invoke(StickyID, oldLookAtSocketID, lookingAtSocketId, engageColour);
                        //}

                        // Call all onHoverEnter methods (or set properties etc) and pass in the SocketID and the ID of this character.
                        if (hitSocket.onHoverEnter != null) { hitSocket.onHoverEnter.Invoke(lookingAtSocketId, StickyID); }

                        // The StickySocket being looked at has been changed, so call the callback if it has been set
                        // NOT YET IMPLEMENTED
                        //if (callbackOnChangeLookAtSocket != null)
                        //{
                        //    callbackOnChangeLookAtSocket(this, oldLookAt, lookingAtSocket);
                        //}
                    }
                    break;
                }
            }

            // The raycast failed to hit anything when character was previously looking at a socket
            if (!_isHit && lookingAtSocketId != StickySocket.NoID)
            {
                StopLookAtSocket();
            }
        }

        #endregion

        #region Private and Internal Methods - Look VR

        /// <summary>
        /// Get the amount the head-mounted device has moved on the local x-z plane in the last frame.
        /// The returned vector is in the character local space.
        /// </summary>
        /// <returns></returns>
        private Vector3 GetHMDMoveDeltaLS()
        { 
            Vector3 _deltaMoved = Vector3.zero;

            if (isLookVREnabled && isHeightCalibratedVR)
            {
                // Get how far the head-mounted device (HMD) has moved on x and z axis
                // from the starting position in the local space of the character
                Vector3 _movedFromStartingPosLS = GetHMDMoveFromOriginLS();

                // Distance moved on the x-z plane since last processed
                _deltaMoved = _movedFromStartingPosLS - lastHMDPosXZProcessedVRLS;

                // Remember how much the HMD has moved on x-z plane and was synch'd
                // with character position.
                lastHMDPosXZProcessedVRLS = _movedFromStartingPosLS;
            }

            return _deltaMoved;
        }

        /// <summary>
        /// Get the amount the head-mounted device has moved on the local x-z plane in the last frame.
        /// The returned vector is in world-space.
        /// </summary>
        /// <returns></returns>
        private Vector3 GetHMDMoveDeltaWS()
        {
            Vector3 _deltaMoved = Vector3.zero;

            if (isLookVREnabled && isHeightCalibratedVR)
            {
                // Get how far the head-mounted device (HMD) has moved on x and z axis
                // from the starting position
                Vector3 _movedFromStartingPos = GetHMDMoveFromOriginWS();

                // Distance moved on the x-z plane since last processed
                _deltaMoved = _movedFromStartingPos - lastHMDPosXZProcessedVR;

                // Remember how much the HMD has moved on x-z plane and was synch'd
                // with character position.
                lastHMDPosXZProcessedVR = _movedFromStartingPos;
            }

            return _deltaMoved;
        }

        /// <summary>
        /// Get how far the head-mounted device (HMD) has moved on x and z axis
        /// in local space from the starting position which was set in
        /// RecalculateFloorOffsetVR().
        /// </summary>
        /// <returns></returns>
        private Vector3 GetHMDMoveFromOriginLS()
        {
            Vector3 _deltaMoved = Vector3.zero;

            if (isLookVREnabled && isHeightCalibratedVR)
            {
                // Get the head-mounted device and S3D camera positions without their y-axis components
                Vector3 lsHMDPosXZ = currentCharInputXR.hmdPosition;
                lsHMDPosXZ.y = 0f;

                Vector3 lsHMDStartPosXZ = initialHMDFloorOffset;
                lsHMDStartPosXZ.y = 0;

                // Convert them both into local space
                lsHMDPosXZ = GetLocalPosition(lsHMDPosXZ);
                lsHMDStartPosXZ = GetLocalPosition(lsHMDStartPosXZ);

                _deltaMoved = lsHMDPosXZ - lsHMDStartPosXZ;
            }

            return _deltaMoved;
        }

        /// <summary>
        /// Get how far the head-mounted device (HMD) has moved on x and z axis
        /// in world space from the starting position which was set in
        /// RecalculateFloorOffsetVR().
        /// </summary>
        /// <returns></returns>
        private Vector3 GetHMDMoveFromOriginWS()
        {
            Vector3 _deltaMoved = Vector3.zero;

            if (isLookVREnabled && isHeightCalibratedVR)
            {
                // Get the head-mounted device and S3D camera positions without their y-axis components
                Vector3 wsHMDPosXZ = currentCharInputXR.hmdPosition;
                wsHMDPosXZ.y = 0f;

                Vector3 initialHMDFloorOffsetXZ = initialHMDFloorOffset;
                initialHMDFloorOffsetXZ.y = 0;

                // Camera sync's to HMD height above floor
                if (isMatchHumanHeightVR)
                {
                    _deltaMoved = wsHMDPosXZ - initialHMDFloorOffsetXZ;
                }
                // Sitting or Standing posture
                else
                {
                    _deltaMoved = wsHMDPosXZ - initialHMDFloorOffsetXZ;
                }
            }

            return _deltaMoved;
        }

        /// <summary>
        /// Enable or disable the Snap Turn feature for VR
        /// </summary>
        /// <param name="isEnabled"></param>
        private void EnableOrDisableSnapTurnVR(bool isEnabled)
        {
            isSnapTurnVR = isEnabled;

            // Always reset the snap turn timer
            // If enabled, a snap turn is immediately available
            snapTurnTimer = 0;
        }

        #endregion

        #region Private or Internal Methods - Jet Pack

        /// <summary>
        /// Allow (or disallow) the Jet Pack to be enabled.
        /// If it is currently enabled, turn off any effects.
        /// </summary>
        /// <param name="isAvailable"></param>
        private void EnableOrDisableJetPackAvailability(bool isAvailable)
        {
            if (isInitialised)
            {
                // Are turning off the Jet Pack feature?
                if (isJetPackAvailable && !isAvailable)
                {
                    if (isJetPackEnabled)
                    {
                        // Stop all jet pack effects
                        SetJetPackEffect(jetPackEffectsFwd, 0f);
                        SetJetPackEffect(jetPackEffectsBack, 0f);
                        SetJetPackEffect(jetPackEffectsUp, 0f);
                        SetJetPackEffect(jetPackEffectsDown, 0f);
                        SetJetPackEffect(jetPackEffectsRight, 0f);
                        SetJetPackEffect(jetPackEffectsLeft, 0f);

                        isJetPackEnabled = false;
                    }
                }

                isJetPackAvailable = isAvailable;
            }
            else { isJetPackAvailable = isAvailable; }
        }

        /// <summary>
        /// Attempt to turn jet pack features on or off.
        /// </summary>
        /// <param name="isEnabled"></param>
        private void EnableOrDisableJetPack(bool isEnabled)
        {
            if (isEnabled)
            {
                if (isJetPackAvailable && !isJetPackEnabled)
                {
                    if (jetPackAudio != null && jetPackAudio.clip != null)
                    {
                        jetPackAudio.volume = 0f;
                        if (!jetPackAudio.isPlaying && jetPackAudio.isActiveAndEnabled) { jetPackAudio.Play(); }
                        jetPackAudio.mute = false;
                       

                        StartJetPackEffect(jetPackEffectsFwd, 0f);
                        StartJetPackEffect(jetPackEffectsBack, 0f);
                        StartJetPackEffect(jetPackEffectsUp, 0f);
                        StartJetPackEffect(jetPackEffectsDown, 0f);
                        StartJetPackEffect(jetPackEffectsRight, 0f);
                        StartJetPackEffect(jetPackEffectsLeft, 0f);
                    }

                    isJetPackEnabled = true;
                }
            }
            // If jet pack feature is currently on, turn it off
            else if (isJetPackEnabled)
            {
                if (jetPackAudio != null)
                {
                    if (jetPackAudio.isPlaying && jetPackAudio.isActiveAndEnabled) { jetPackAudio.Pause(); }
                    jetPackAudio.mute = true;
                }

                StopJetPackEffect(jetPackEffectsFwd);
                StopJetPackEffect(jetPackEffectsBack);
                StopJetPackEffect(jetPackEffectsUp);
                StopJetPackEffect(jetPackEffectsDown);
                StopJetPackEffect(jetPackEffectsRight);
                StopJetPackEffect(jetPackEffectsLeft);

                isJetPackEnabled = false;
            }
        }


        private void GetRampedJetPackInput()
        {
            if (isInitialised)
            {
                // We update the rampUp/Down Duration values in case they were changed either
                // in the editor at runtime or via code

                // Left/right movement
                jetPackRampInputX.currentInput = currentLocalSpaceMovementInput.x;
                jetPackRampInputX.rampUpDuration = jetPackRampUpDuration;
                jetPackRampInputX.rampDownDuration = jetPackRampDownDuration;
                jetPackRampInputX.SmoothInput(Time.deltaTime);
                currentLocalSpaceMovementInput.x = jetPackRampInputX.currentInput;

                // Up/down movement
                jetPackRampInputY.currentInput = currentLocalSpaceMovementInput.y;
                jetPackRampInputY.rampUpDuration = jetPackRampUpDuration;
                jetPackRampInputY.rampDownDuration = jetPackRampDownDuration;
                jetPackRampInputY.SmoothInput(Time.deltaTime);
                currentLocalSpaceMovementInput.y = jetPackRampInputY.currentInput;

                // Forward/backward movement
                jetPackRampInputZ.currentInput = currentLocalSpaceMovementInput.z;
                jetPackRampInputZ.rampUpDuration = jetPackRampUpDuration;
                jetPackRampInputZ.rampDownDuration = jetPackRampDownDuration;
                jetPackRampInputZ.SmoothInput(Time.deltaTime);
                currentLocalSpaceMovementInput.z = jetPackRampInputZ.currentInput;
            }
        }

        /// <summary>
        /// Set the sound and/or particle effects emission rate for the jet pack.
        /// </summary>
        private void SetJetPackEffects()
        {
            // Set the sound level
            if (jetPackAudio != null && jetPackAudio.clip != null)
            {
                float soundLevel = jetPackFuelLevel > 0 && jetPackHealth > 0f ? S3DMath.MaxAbs(currentLocalSpaceMovementInput) : 0f;

                if (soundLevel > 0f)
                {
                    jetPackAudio.volume = soundLevel * jetPackMaxVolume;
                    if (!jetPackAudio.isPlaying && jetPackAudio.isActiveAndEnabled) { jetPackAudio.Play(); }
                }
                else { jetPackAudio.volume = 0f; }
            }

            // Set the individual jet pack thrusters
            if (jetPackFuelLevel > 0 && jetPackHealth > 0f)
            {
                SetJetPackEffect(jetPackEffectsFwd, currentLocalSpaceMovementInput.z > 0f ? currentLocalSpaceMovementInput.z : 0f);
                SetJetPackEffect(jetPackEffectsBack, currentLocalSpaceMovementInput.z < 0f ? -currentLocalSpaceMovementInput.z : 0f);
                SetJetPackEffect(jetPackEffectsUp, currentLocalSpaceMovementInput.y > 0f ? currentLocalSpaceMovementInput.y : 0f);
                SetJetPackEffect(jetPackEffectsDown, currentLocalSpaceMovementInput.y < 0f ? -currentLocalSpaceMovementInput.y : 0f);
                SetJetPackEffect(jetPackEffectsRight, currentLocalSpaceMovementInput.x > 0f ? currentLocalSpaceMovementInput.x : 0f);
                SetJetPackEffect(jetPackEffectsLeft, currentLocalSpaceMovementInput.x < 0f ? -currentLocalSpaceMovementInput.x : 0f);
            }
            else
            {
                // No fuel and/or health left so stop all jet pack effects
                SetJetPackEffect(jetPackEffectsFwd, 0f);
                SetJetPackEffect(jetPackEffectsBack, 0f);
                SetJetPackEffect(jetPackEffectsUp, 0f);
                SetJetPackEffect(jetPackEffectsDown, 0f);
                SetJetPackEffect(jetPackEffectsRight, 0f);
                SetJetPackEffect(jetPackEffectsLeft, 0f);
            }
        }

        /// <summary>
        /// Set the effects amount for an individual jet pack thruster.
        /// Typically called from SetJetPackEffects().
        /// </summary>
        /// <param name="amount"></param>
        private void SetJetPackEffect(S3DEffects s3dEffects, float amount)
        {
            if (s3dEffects != null)
            {
                // Set the min effects rate in case it has been set at runtime in the editor
                // or in code.
                if (amount > 0f) { s3dEffects.minEffectsRate = jetPackMinEffectsRate; }
                s3dEffects.UpdateEffects(amount);
            }
        }

        /// <summary>
        /// Attempt to start a jet pack effect and set an initial value.
        /// </summary>
        /// <param name="s3DEffects"></param>
        /// <param name="amount"></param>
        private void StartJetPackEffect (S3DEffects s3dEffects, float amount)
        {
            if (s3dEffects != null)
            {
                s3dEffects.Play();
                SetJetPackEffect(s3dEffects, amount);
            }
        }

        /// <summary>
        /// Attempt to stop all particle effects for the given jet pack effect.
        /// </summary>
        /// <param name="s3dEffects"></param>
        private void StopJetPackEffect(S3DEffects s3dEffects)
        {
            if (s3dEffects != null) { s3dEffects.Stop(); }
        }

        /// <summary>
        /// Reset the jet pack thruster by getting all the particle systems connect to or are children
        /// of the gameobject.
        /// </summary>
        /// <param name="thrusterGameObject"></param>
        /// <param name="s3dEffects"></param>
        private void ResetJetPackThruster(GameObject thrusterGameObject, S3DEffects s3dEffects)
        {
            if (thrusterGameObject != null)
            {
                // Note: We cannot create a new s3dEffects here if the passed in class is null
                // as classes are always passed by reference. You cannot update a null reference.
                if (s3dEffects != null) { s3dEffects.Initialise(thrusterGameObject); }
            }
            else { s3dEffects = null; }
        }

        #endregion

        #region Private or Internal Methods - Engage and Interactive

        /// <summary>
        /// Attempt to add the StickyInteractive object to the selected list.
        /// Will return the StoreItemID if it is added, otherwise S3DStoreItem.NoStoreItem (0) if it fails.
        /// </summary>
        /// <param name="stickyInteractive"></param>
        /// <returns></returns>
        private int AddSelectedInteractive(StickyInteractive stickyInteractive)
        {
            int storeItemID = S3DStoreItem.NoStoreItem;

            // Ensure the interactive-enabled object is selectable
            if (stickyInteractive != null && stickyInteractive.IsSelectable)
            {
                int stickyInteractiveID = stickyInteractive.StickyInteractiveID;

                // Ensure it isn't already selected by this character
                if (!IsInteractiveIDSelected(stickyInteractiveID))
                {
                    S3DStoreItem s3dStoreItem = new S3DStoreItem()
                    {
                        stickyInteractive = stickyInteractive,
                        stickyInteractiveID = stickyInteractiveID
                    };

                    if (s3dStoreItem != null)
                    {
                        selectedInSceneStoreItemList.Add(s3dStoreItem);
                        numStoreSelectedInScene++;

                        storeItemID = s3dStoreItem.guidHash;
                    }
                }
            }

            return storeItemID;
        }

        /// <summary>
        /// Check if the hand is holding a suitable interactive object that can be placed in the socket.
        /// Check if the socket can accept the interavtive object.
        /// </summary>
        /// <param name="stickySocket"></param>
        /// <param name="isLeftHand"></param>
        /// <returns></returns>
        private bool CheckHandToSocket (StickySocket stickySocket, bool isLeftHand)
        {
            if (stickySocket == null)
            {
                #if UNITY_EDITOR
                Debug.LogWarning("[ERROR] " + (isLeftHand ? "left" : "right") + " hand of " + name + " cannot place held object in the socket because the socket is null");
                #endif
                return false;
            }
            else if (!CheckIsHolding(isLeftHand) || !stickySocket.CanAddItem(isLeftHand ? leftHandInteractive : rightHandInteractive))
            {
                return false;
            }
            else
            {
                return true;
            }
        }

        /// <summary>
        /// Check to see if the hand is holding something.
        /// Returns true if holding an interactive object, else returns false.
        /// </summary>
        /// <param name="isLeftHand"></param>
        /// <returns></returns>
        private bool CheckIsHolding (bool isLeftHand)
        {
            if (isLeftHand && leftHandInteractiveId == StickyInteractive.NoID)
            {
                #if UNITY_EDITOR
                Debug.LogWarning("The left hand of " + name + " is not holding an interactive object");
                #endif
                return false;
            }
            else if (!isLeftHand && rightHandInteractiveId == StickyInteractive.NoID)
            {
                #if UNITY_EDITOR
                Debug.LogWarning("The right hand of " + name + " is not holding an interactive object");
                #endif
                return false;
            }
            else { return true; }
        }

        /// <summary>
        /// Check to see if the hand is not already holding something.
        /// Returns true if not holding an interactive-enabled object, else return false.
        /// </summary>
        /// <param name="isLeftHand"></param>
        /// <returns></returns>
        private bool CheckNotHolding (bool isLeftHand)
        {
            // Check to see if the hand is already holding something
            if (isLeftHand && leftHandInteractiveId != StickyInteractive.NoID)
            {
                #if UNITY_EDITOR
                Debug.LogWarning("The left hand of " + name + " already holds an interactive object");
                #endif
                return false;
            }
            else if (!isLeftHand && rightHandInteractiveId != StickyInteractive.NoID)
            {
                #if UNITY_EDITOR
                Debug.LogWarning("The right hand of " + name + " already holds an interactive object");
                #endif
                return false;
            }
            else { return true; }
        }

        /// <summary>
        /// Inform the character the interactive object is no long being held.
        /// This is NOT the same as dropping a interactive object. It is used currently
        /// by this.DropInteractive(stickyInteractive, isLeftHand),
        /// EquipItemFromRightHand, EquipItemFromLeftHand,
        /// LeftHandToSocket, RightHandToSocket, and
        /// StickyXRInteractor.DropInteractive(stickyInteractive).
        /// See also SetHoldingInteractive(..).
        /// </summary>
        internal void ClearHoldingInteractive(bool isLeftHand)
        {
            int _interactiveID = isLeftHand ? leftHandInteractiveId : rightHandInteractiveId;
            bool _wasStickyWeaponHeld = isLeftHand ? isLeftHandHoldingWeapon : isRightHandHoldingWeapon;

            // Remove the item from the hand
            if (isLeftHand)
            {
                leftHandInteractiveId = StickyInteractive.NoID;
                leftHandInteractive = null;
                leftHandWeapon = null;
                isLeftHandHoldingWeapon = false;
                // Turn off if not holding a weapon in either hand
                if (!isRightHandHoldingWeapon)
                {
                    EnableOrDisableAimIK(false, false);
                }

                leftHandMagazine = null;
                isLeftHandHoldingMagazine = false;
            }
            else
            {
                rightHandInteractiveId = StickyInteractive.NoID;
                rightHandInteractive = null;
                rightHandWeapon = null;
                isRightHandHoldingWeapon = false;
                // Turn off if not holding a weapon in either hand
                if (!isLeftHandHoldingWeapon)
                {
                    EnableOrDisableAimIK(false, false);
                }
                rightHandMagazine = null;
                isRightHandHoldingMagazine = false;
            }

            // Check to see if we need to trigger anything
            if (_wasStickyWeaponHeld && onPostStopHoldWeapon != null)
            {
                onPostStopHoldWeapon.Invoke(StickyID, _interactiveID, false, Vector3.zero);
            }

            heldTransitionTimer = 0f;
        }

        /// <summary>
        /// Call the onInitialised events after a delayed period.
        /// See end of Initialise()
        /// </summary>
        private void DelayOnInitialiseEvents()
        {
            onInitialised.Invoke(capsuleColliderId);
        }

        /// <summary>
        /// Drop an interactive-enabled object
        /// </summary>
        /// <param name="stickyInteractive"></param>
        /// <param name="isLeftHand"></param>
        private void DropInteractive(StickyInteractive stickyInteractive, bool isLeftHand)
        {
            // Verify that the hand is holding something
            if (CheckIsHolding(isLeftHand))
            {
                // Unregister the active colliders BEFORE DropObject(..)
                DetachColliders(stickyInteractive.Colliders);

                // Perform any actions required when the interactive-enabled object is dropped.
                // This includes performing actions configured in the StickyInteractive editor.
                // If this is a weapon it will call stickyWeapon.DropObject(..).
                // If this is a magazine it will call stickyMagazine.DropObject(..).
                stickyInteractive.DropObject(StickyID);

                ClearHoldingInteractive(isLeftHand);
            }
        }

        /// <summary>
        /// Currenlty used for testing Lasso options.
        /// Get the world space position and rotation when the interactive object is held in a hand.
        /// </summary>
        /// <param name="stickyInteractive"></param>
        /// <param name="isLeftHand"></param>
        /// <param name="isSecondaryHandHold"></param>
        /// <param name="wsPosition"></param>
        /// <param name="wsRotation"></param>
        private void GetInteractiveHandSnapLocation(StickyInteractive stickyInteractive, bool isLeftHand, bool isSecondaryHandHold, ref Vector3 wsPosition, ref Quaternion wsRotation)
        {
            // Get the palm of the hand's relative position and rotation to the hand bone.
            wsPosition = isLeftHand ? GetLeftHandPalmPosition() : GetRightHandPalmPosition();
            wsRotation = isLeftHand ? GetLeftHandPalmRotation() : GetRightHandPalmRotation();

            // We want the object's hand hold rotation to point towards the palm.
            Quaternion handHoldLocalRot = Quaternion.Euler(isSecondaryHandHold ? stickyInteractive.handHold2Rotation : stickyInteractive.handHold1Rotation);

            // Consistent - but wrong (faces inward at top of cup if palm offset 180, 90, 270)
            // Cup correct angle but upside down in hand when palm offset 0, 45, 90 (palm looks correct in editor gizmos)
            wsRotation *= Quaternion.Inverse(handHoldLocalRot);

            // Subtract the hand hold offset
            wsPosition -= wsRotation * stickyInteractive.GetHandHoldLocalOffset(isSecondaryHandHold);
        }

        /// <summary>
        /// Grab the interactive-enabled object currently being looked at (if any).
        /// Use the primary or secondary hand hold position on the object.
        /// Grabbed objects become unselected if they were previously selected.
        /// </summary>
        private void GrabLookedAtInteractive(bool isLeftHand, bool isSecondaryHandHold)
        {
            // Can we select an interactive-enabled object, and are we currently looking at one?
            // v1.1.0 HandIK shouldn't be required to grab an non-touchable object unless you want to Parent it to a hand.
            if (isInitialised && isAnimateEnabled && lookingAtInteractiveId != StickyInteractive.NoID)
            {
                // Check that it hasn't been destroyed
                if (lookingAtInteractive == null)
                {
                    RemoveSelectedInteractiveID(lookingAtInteractiveId);

                    // Cannot find it so assume character is no longer looking at it
                    lookingAtInteractiveId = StickyInteractive.NoID;
                }
                else
                {
                    if (lookingAtInteractive.IsGrabbable)
                    {
                        // If the interactive-enable object is already selected, remove it from the list
                        RemoveSelectedInteractiveID(lookingAtInteractiveId);

                        HoldInteractive(lookingAtInteractive, isLeftHand, isSecondaryHandHold);
                    }
#if UNITY_EDITOR
                    else { Debug.LogWarning("StickyControlModule.GrabLookedAtInteractive " + name + " cannot grab " + lookingAtInteractive.name + " because it is not Grabbable"); }
#endif
                }
            }
        }

        /// <summary>
        /// Equip an interactive-enabled object to an equip point on the character.
        /// Assumes stickyInteractive and equipPoint are not null.
        /// </summary>
        /// <param name="stickyInteractive"></param>
        /// <param name="equipPoint"></param>
        private int EquipInteractiveInternal (StickyInteractive stickyInteractive, S3DEquipPoint equipPoint)
        {
            int storeItemID = S3DStoreItem.NoStoreItem;

            if (numEquipPoints == 0)
            {
                #if UNITY_EDITOR
                Debug.LogWarning("There are no equip points on " + name + " to equip the interactive object");
                #endif
            }
            else
            {
                // Get the unique ID of the interactive-enabled object we want to equip 
                int interactiveID = stickyInteractive.StickyInteractiveID;

                bool wasHeld = stickyInteractive.IsHeld;

                // If a hand is targeting this object, stop targeting it. We don't want to
                // be attempting to reach for or touch an object this is now equiped on the body.

                // Stop targeting with left hand
                if (leftHandTargetInteractive != null && leftHandTargetInteractive.StickyInteractiveID == interactiveID)
                {
                    SetLeftHandIKTargetInteractive(null, false, true);
                }

                // Stop targeting with right hand
                if (rightHandTargetInteractive != null && rightHandTargetInteractive.StickyInteractiveID == interactiveID)
                {
                    SetRightHandIKTargetInteractive(null, false, true);
                }

                // If the character is looking at this interactive-enabled object, stop looking at it
                if (lookingAtInteractiveId != StickyInteractive.NoID && lookingAtInteractiveId == interactiveID)
                {
                    StopLookAtInteractive();
                }

                // Perform any actions required when the interactive-enabled object is equipped.
                // This includes performing actions configured in the StickyInteractive editor.
                if (stickyInteractive.EquipObject(this, equipPoint))
                {

                }

                // Register the active colliders AFTER EquipObject(..)
                Collider[] attachedObjectColliders = stickyInteractive.Colliders;
                int numAttachedColliders = attachedObjectColliders == null ? 0 : attachedObjectColliders.Length;

                for (int colIdx = 0; colIdx < numAttachedColliders; colIdx++)
                {
                    Collider attachCollider = attachedObjectColliders[colIdx];
                    if (attachCollider.enabled) { AttachCollider(attachCollider); }
                }

                S3DStoreItem storeItem = new S3DStoreItem()
                {
                    stickyInteractive = stickyInteractive,
                    stickyInteractiveID = interactiveID
                };

                stickyInteractive.Sticky3DCharacter = this;
                stickyInteractive.IsEquipped = true;

                // Add it to the "inventory" of this equip point on the character
                equipPoint.storeItemList.Add(storeItem); 
                storeItemID = storeItem.StoreItemID;

                // Only delay the parenting onto the equip point, if it was previously held,
                // and the delay time is > 0 seconds.
                if (wasHeld && stickyInteractive.equipFromHeldDelay > 0f)
                {
                    StopDelayEquip(stickyInteractive);

                    // NOTE: One "could" potentially already be in progress and this equipInteractiveDelayed variable
                    // would be overwritten, preventing StopDelayEquip() from stopping the earlier one if the
                    // item is dropped etc. If this becomes a problem might need to create a hashset of them.
                    equipInteractiveDelayed = StartCoroutine(EquipInteractiveDelayed(stickyInteractive, equipPoint, stickyInteractive.equipFromHeldDelay));
                }
                else
                {
                    EquipInteractiveFinalise(stickyInteractive, equipPoint);
                }
            }

            return storeItemID;
        }

        /// <summary>
        /// Delay the final step of equipping an item onto an equip point. This includes parenting the stickyinteractive to
        /// the transform on the character.
        /// </summary>
        /// <param name="stickyInteractive"></param>
        /// <param name="equipPoint"></param>
        /// <param name="delay"></param>
        /// <returns></returns>
        private IEnumerator EquipInteractiveDelayed(StickyInteractive stickyInteractive, S3DEquipPoint equipPoint, float delay)
        {
            stickyInteractive.IsEquipFinaliseDelayed = true;
            yield return new WaitForSeconds(delay);

            EquipInteractiveFinalise(stickyInteractive, equipPoint);
            stickyInteractive.IsEquipFinaliseDelayed = false;
        }

        /// <summary>
        /// Complete the Equipping of an interactive object to a equipPoint. This includes
        /// parenting it and, if a weapon, CheckMagsInReserve().
        /// </summary>
        /// <param name="stickyInteractive"></param>
        /// <param name="equipPoint"></param>
        private void EquipInteractiveFinalise (StickyInteractive stickyInteractive, S3DEquipPoint equipPoint)
        {
            if (ParentInteractive(stickyInteractive, equipPoint))
            {
                // As EquipInteractiveFinalise maybe delayed, we start the lasso operation here rather
                // than in say EquipFromSocket(..) or EquipInteractiveInternal(..).
                if (stickyInteractive.IsLassoEnabled)
                {
                    StartCoroutine(LassoInteractiveFromSocket(stickyInteractive, stickyInteractive.LassoSocket, equipPoint));
                }
            }
            // If parenting fails, for whatever reason, but lasso was enabled, turn if off.
            else if (stickyInteractive.IsLassoEnabled)
            {
                stickyInteractive.ClearLasso();
            }

            if (stickyInteractive.IsStickyWeapon)
            {
                // This weapon could rely on Stashed Magazines on the character.
                // If so, the number of compatible non-empty mags will be updated.
                ((StickyWeapon)stickyInteractive).CheckMagsInReserve();
            }

            //stickyInteractive.PostGrabObject(StickyID, isSecondaryHandHold);
        }

        /// <summary>
        /// Attempt to grab the last interactive object that was added to the socket
        /// with the given hand.
        /// </summary>
        /// <param name="stickySocket"></param>
        /// <param name="isLeftHand"></param>
        private void GrabFromSocket(StickySocket stickySocket, bool isLeftHand)
        {
            if (stickySocket != null)
            {
                StickyInteractive lastAddedItem = stickySocket.GetLastInteractive();

                if (lastAddedItem != null)
                {
                    if (lastAddedItem.IsGrabbable)
                    {
                        if (CheckNotHolding(isLeftHand))
                        {
                            if (lassoSpeed > 0f)
                            {
                                lastAddedItem.IsLassoEnabled = true;
                                lastAddedItem.LassoSocket = stickySocket;
                                lastAddedItem.LassoCharacter = null;
                                lastAddedItem.LassoEquipPoint = null;
                            }

                            stickySocket.RemoveInteractive(lastAddedItem.StickyInteractiveID, true, false);
                            GrabInteractive(lastAddedItem, isLeftHand, false);

                            if (lassoSpeed > 0f)
                            {
                                StartCoroutine(LassoInteractiveFromSocket(lastAddedItem, stickySocket));
                            }
                        }
                    }
                    #if UNITY_EDITOR
                    else { Debug.LogWarning("StickyControlModule.GrabFromSocket " + name + " cannot grabbed " + lastAddedItem.name + " from " + stickySocket.name + " because it is not Grabbable"); }
                    #endif
                }
            }
        }

        /// <summary>
        /// This should be called when a hand has started or stopped touching
        /// an interactive-enabled object. This method will determine if a
        /// notification should be sent to the interactive object.
        /// </summary>
        /// <param name="isLeftHand"></param>
        private void HandTouchNotification(bool isLeftHand)
        {
            if (isLeftHand)
            {
                if (leftHandTargetInteractive != null && leftHandTargetInteractive.IsTouchable)
                {
                    if (leftHandData.isTouching)
                    {
                        // Assume the hit point is at the edge of the hand detection sphere.
                        // Use the hand (wrist) position as a starting point - although should probably be
                        // from the palm position.
                        Vector3 hitNormal = leftHandData.idleDirToTarget.normalized;
                        Vector3 hitPoint = leftHandData.currentHandIKPos + (leftHandRadius * hitNormal);
                        // Normal is the opposite of the direction from the hand to the target
                        hitNormal = -hitNormal;

                        leftHandTargetInteractive.TouchObject(hitPoint, hitNormal, StickyID);
                    }
                    else
                    {
                        leftHandTargetInteractive.StopTouchingObject(StickyID);
                    }
                }
            }
            else
            {
                if (rightHandTargetInteractive != null && rightHandTargetInteractive.IsTouchable)
                {
                    if (rightHandData.isTouching)
                    {
                        // Assume the hit point is at the edge of the hand detection sphere.
                        // Use the hand (wrist) position as a starting point - although should probably be
                        // from the palm position.
                        Vector3 hitNormal = rightHandData.idleDirToTarget.normalized;
                        Vector3 hitPoint = rightHandData.currentHandIKPos + (leftHandRadius * hitNormal);
                        // Normal is the opposite of the direction from the hand to the target
                        hitNormal = -hitNormal;

                        rightHandTargetInteractive.TouchObject(hitPoint, hitNormal, StickyID);
                    }
                    else
                    {
                        rightHandTargetInteractive.StopTouchingObject(StickyID);
                    }
                }
            }
        }

        /// <summary>
        /// Grab an interactive-enabled object and hold it in a hand
        /// </summary>
        /// <param name="stickyInteractive"></param>
        /// <param name="isLeftHand"></param>
        /// <param name="isSecondaryHandHold"></param>
        private void HoldInteractive(StickyInteractive stickyInteractive, bool isLeftHand, bool isSecondaryHandHold)
        {
            // Check to see if the hand is already holding something
            if (CheckNotHolding(isLeftHand))
            {
                // Get the unique ID of the interactive-enabled object we want to hold 
                int interactiveID = stickyInteractive.StickyInteractiveID;

                if (stickyInteractive.IsStickyWeapon && onPreStartHoldWeapon != null)
                {
                    onPreStartHoldWeapon.Invoke(StickyID, interactiveID, false, Vector3.zero);
                }

                // If the hand is targeting this object, stop targeting it. We don't want to
                // be attempting to reach for or touch an object this is now held in a hand.
                if (isLeftHand)
                {
                    // Stop targeting
                    if (leftHandTargetInteractive != null && leftHandTargetInteractive.StickyInteractiveID == interactiveID)
                    {
                        SetLeftHandIKTargetInteractive(null, isSecondaryHandHold, true);
                    }
                }
                else
                {
                    // Stop targeting
                    if (rightHandTargetInteractive != null && rightHandTargetInteractive.StickyInteractiveID == interactiveID)
                    {
                        SetRightHandIKTargetInteractive(null, isSecondaryHandHold, true);
                    }
                }

                // If the character is looking at this interactive-enabled object, stop looking at it
                if (lookingAtInteractiveId != StickyInteractive.NoID && lookingAtInteractiveId == interactiveID)
                {
                    StopLookAtInteractive();
                }

                // Perform any actions required when the interactive-enabled object is grabbed.
                // This includes performing actions configured in the StickyInteractive editor.
                stickyInteractive.GrabObject(StickyID, isSecondaryHandHold);

                // Register the active colliders AFTER GrabObject(..)
                Collider[] attachedObjectColliders = stickyInteractive.Colliders;
                int numAttachedColliders = attachedObjectColliders == null ? 0 : attachedObjectColliders.Length;

                for (int colIdx = 0; colIdx < numAttachedColliders; colIdx++)
                {
                    Collider attachCollider = attachedObjectColliders[colIdx];
                    if (attachCollider.enabled) { AttachCollider(attachCollider); }
                }

                if (isLeftHand)
                {
                    if (!stickyInteractive.isParentOnGrab || (isHandIK && ParentIteractive(stickyInteractive, leftHandTrfm, isLeftHand, isSecondaryHandHold)))
                    {
                        SetHoldingInteractive(stickyInteractive, true);
                    }
                }
                else
                {
                    if (!stickyInteractive.isParentOnGrab || (isHandIK && ParentIteractive(stickyInteractive, rightHandTrfm, isLeftHand, isSecondaryHandHold)))
                    {
                        SetHoldingInteractive(stickyInteractive, false);
                    }
                }

                if (stickyInteractive.IsStickyWeapon)
                {
                    StickyWeapon _weapon = (StickyWeapon)stickyInteractive;

                    // This weapon could rely on Stashed Magazines on the character.
                    // If so, the number of compatible non-empty mags will be updated.
                    _weapon.CheckMagsInReserve();

                    // prevent weapons firing while grabbing.
                    PauseWeaponsFiring();

                    if (!stickyInteractive.IsLassoEnabled)
                    {
                        UnpauseWeaponsFiring(0.1f);
                    }
                }

                stickyInteractive.PostGrabObject(StickyID, isSecondaryHandHold);
            }
        }
       
        /// <summary>
        /// Lasso (move) the interactive object from a socket to a hand.
        /// </summary>
        /// <param name="stickyInteractive"></param>
        /// <param name="stickySocket"></param>
        /// <returns></returns>
        private IEnumerator LassoInteractiveFromSocket (StickyInteractive stickyInteractive, StickySocket stickySocket)
        {
            float duration = 2f;
            float lassoTimer = 0f;

            // See also ParentIteractive(..)
            // See also GrabFromSocket(..)

            if (stickyInteractive.IsLassoEnabled)
            {
                // Start at the socketed position.
                stickySocket.SetSocketedLocation(stickyInteractive);

                // The speed needs to be adjusted for the local scale of the object.
                // For example, if a character model has scale of 100,100,100, then the interactive object
                // will have a scale of 0.001, 0.001, 0.001.
                float scaledLocalSpeed = lassoSpeed * stickyInteractive.transform.localScale.x;

                while (lassoTimer < duration)
                {
                    lassoTimer += Time.deltaTime;

                    // Move toward the character hand hold position, from the socket
                    Vector3 newPos = Vector3.MoveTowards(stickyInteractive.transform.localPosition, stickyInteractive.LassoTargetPositionLS, scaledLocalSpeed * Time.deltaTime);

                    Quaternion newRot = Quaternion.Slerp(stickyInteractive.transform.localRotation, stickyInteractive.LassoTargetRotationLS, lassoTimer / duration);

                    stickyInteractive.transform.localPosition = newPos;
                    stickyInteractive.transform.localRotation = newRot;

                    // Exit early if already reached destination
                    if (newPos == stickyInteractive.LassoTargetPositionLS)
                    {
                        break;
                    }

                    yield return null;
                }

                // Snap to final position and rotation
                stickyInteractive.transform.localPosition = stickyInteractive.LassoTargetPositionLS;
                stickyInteractive.transform.localRotation = stickyInteractive.LassoTargetRotationLS;

                // Disable lasso
                stickyInteractive.ClearLasso();
            }
            else
            {
                yield return null;
            }

            UnpauseWeaponsFiring(0.1f);
        }

        /// <summary>
        /// Lasso (move) the interactive object from a socket to an Equip Point on the character.
        /// Currently, this is different from the one for grab, as the equipPoint may be say
        /// on the back of the character and we might want to deal with that case differently.
        /// </summary>
        /// <param name="stickyInteractive"></param>
        /// <param name="stickySocket"></param>
        /// <param name="equipPoint"></param>
        /// <returns></returns>
        private IEnumerator LassoInteractiveFromSocket(StickyInteractive stickyInteractive, StickySocket stickySocket, S3DEquipPoint equipPoint)
        {
            float duration = 2f;
            float lassoTimer = 0f;

            // See also EquipFromSocket(..) and EquipInteractiveFinalise(..)

            if (stickyInteractive.IsLassoEnabled)
            {
                // Start at the socketed position.
                stickySocket.SetSocketedLocation(stickyInteractive);

                // The speed needs to be adjusted for the local scale of the object.
                // For example, if a character model has scale of 100,100,100, then the interactive object
                // will have a scale of 0.001, 0.001, 0.001.
                float scaledLocalSpeed = lassoSpeed * stickyInteractive.transform.localScale.x;

                while (lassoTimer < duration)
                {
                    lassoTimer += Time.deltaTime;

                    // Move toward the character Equip Point position, from the socket
                    Vector3 newPos = Vector3.MoveTowards(stickyInteractive.transform.localPosition, stickyInteractive.LassoTargetPositionLS, scaledLocalSpeed * Time.deltaTime);

                    Quaternion newRot = Quaternion.Slerp(stickyInteractive.transform.localRotation, stickyInteractive.LassoTargetRotationLS, lassoTimer / duration);

                    stickyInteractive.transform.localPosition = newPos;
                    stickyInteractive.transform.localRotation = newRot;

                    // Exit early if already reached destination
                    if (newPos == stickyInteractive.LassoTargetPositionLS)
                    {
                        break;
                    }

                    /// TODO - what happens when object is inside the character - like when equip point is on the back?
                    

                    yield return null;
                }

                // Snap to final position and rotation
                stickyInteractive.transform.localPosition = stickyInteractive.LassoTargetPositionLS;
                stickyInteractive.transform.localRotation = stickyInteractive.LassoTargetRotationLS;

                // Disable lasso
                stickyInteractive.ClearLasso();
            }
            else
            {
                yield return null;
            }
        }

        /// <summary>
        /// Lasso (move) the interactive object from a hand to a socket.
        /// </summary>
        /// <param name="stickyInteractive"></param>
        /// <param name="stickySocket"></param>
        /// <returns></returns>
        internal IEnumerator LassoInteractiveToSocket (StickyInteractive stickyInteractive, StickySocket stickySocket)
        {
            float duration = 2f;
            float lassoTimer = 0f;

            // See also stickySocket.ParentIteractive(..)
            // See also SocketFromLeftHand(..) and SocketFromRightHand(..)

            if (stickyInteractive.IsLassoEnabled)
            {
                // Start at the hand position.
                stickyInteractive.transform.localPosition = stickyInteractive.LassoSourcePositionLS;
                stickyInteractive.transform.localRotation = stickyInteractive.LassoSourceRotationLS;

                Vector3 wsPosition = Vector3.zero;
                Quaternion wsRotation = Quaternion.identity;

                float scaledLocalSpeed = lassoSpeed * stickyInteractive.transform.localScale.x;

                while (lassoTimer < duration)
                {
                    lassoTimer += Time.deltaTime;

                    stickySocket.GetSocketedLocation(stickyInteractive, ref wsPosition, ref wsRotation);

                    // Move toward the character hand hold position, from the socket
                    Vector3 newPos = Vector3.MoveTowards(stickyInteractive.transform.position, wsPosition, scaledLocalSpeed * Time.deltaTime);

                    Quaternion newRot = Quaternion.Slerp(stickyInteractive.transform.rotation, wsRotation, lassoTimer / duration);

                    stickyInteractive.transform.position = newPos;
                    stickyInteractive.transform.rotation = newRot;

                    // Exit early if already reached destination
                    if (newPos == wsPosition)
                    {
                        break;
                    }

                    yield return null;
                }

                // Snap to final position and rotation
                stickySocket.SetSocketedLocation(stickyInteractive);

                // Now that the interactive object has reached the socket position,
                // detach the interactive colliders from the character it came from.
                DetachColliders(stickyInteractive.Colliders);

                // Disable lasso
                stickyInteractive.ClearLasso();
            }
            else
            {
                yield return null;
            }
        }

        /// <summary>
        /// Lasso (move) the interactive object from an Equip Point to a socket.
        /// Currently, this is different from the one hand to socket, as the equipPoint may be say
        /// on the back of the character and we might want to deal with that case differently.
        /// </summary>
        /// <param name="stickyInteractive"></param>
        /// <param name="stickySocket"></param>
        /// <param name="equipPoint"></param>
        /// <returns></returns>
        internal IEnumerator LassoInteractiveToSocket (StickyInteractive stickyInteractive, StickySocket stickySocket, S3DEquipPoint equipPoint)
        {
            float duration = 2f;
            float lassoTimer = 0f;

            // See also stickySocket.ParentIteractive(..)
            // See also SocketFromEquip(..)

            if (stickyInteractive.IsLassoEnabled)
            {
                // Start at the equip position.
                stickyInteractive.transform.localPosition = stickyInteractive.LassoSourcePositionLS;
                stickyInteractive.transform.localRotation = stickyInteractive.LassoSourceRotationLS;

                Vector3 wsPosition = Vector3.zero;
                Quaternion wsRotation = Quaternion.identity;

                float scaledLocalSpeed = lassoSpeed * stickyInteractive.transform.localScale.x;

                while (lassoTimer < duration)
                {
                    lassoTimer += Time.deltaTime;

                    stickySocket.GetSocketedLocation(stickyInteractive, ref wsPosition, ref wsRotation);

                    // Move toward the character hand hold position, from the socket
                    Vector3 newPos = Vector3.MoveTowards(stickyInteractive.transform.position, wsPosition, scaledLocalSpeed * Time.deltaTime);

                    Quaternion newRot = Quaternion.Slerp(stickyInteractive.transform.rotation, wsRotation, lassoTimer / duration);

                    stickyInteractive.transform.position = newPos;
                    stickyInteractive.transform.rotation = newRot;

                    // Exit early if already reached destination
                    if (newPos == wsPosition)
                    {
                        break;
                    }

                    yield return null;
                }

                // Snap to final position and rotation
                stickySocket.SetSocketedLocation(stickyInteractive);

                // Disable lasso
                DetachColliders(stickyInteractive.Colliders);

                stickyInteractive.ClearLasso();
            }
            else
            {
                yield return null;
            }
        }

        /// <summary>
        /// Attempt to parent an interactive-enabled object to a character Equip Point.
        /// </summary>
        /// <param name="stickyInteractive"></param>
        /// <param name="equipPoint"></param>
        /// <returns></returns>
        private bool ParentInteractive(StickyInteractive stickyInteractive, S3DEquipPoint equipPoint)
        {
            bool isParented = false;

            if (equipPoint != null && equipPoint.parentTransform != null)
            {
                // Set the world space position and rotation before parenting to avoid issues with character rig scaling.
                Vector3 wsPosition = GetEquipPointPosition(equipPoint);
                Quaternion wsRotation = GetEquipPointRotation(equipPoint);

                // We want the object's equip point rotation to point towards the character equip point.
                Quaternion equipLocalRot = Quaternion.Euler(stickyInteractive.equipRotation);

                wsRotation *= Quaternion.Inverse(equipLocalRot);

                // Subtract the equip offset
                wsPosition -= wsRotation * stickyInteractive.equipOffset;

                stickyInteractive.transform.position = wsPosition;
                stickyInteractive.transform.rotation = wsRotation;

                // Is the object already held by the character?
                if (stickyInteractive.isReparentOnDrop && stickyInteractive.PreGrabParentTfrm != null)
                {
                    stickyInteractive.PreEquippedParentTfrm = stickyInteractive.PreGrabParentTfrm;
                    stickyInteractive.PreGrabParentTfrm = null;
                }
                // Is the object already stashed by the character?
                else if (stickyInteractive.isReparentOnDrop && stickyInteractive.PreStashParentTfrm != null)
                {
                    stickyInteractive.PreEquippedParentTfrm = stickyInteractive.PreStashParentTfrm;
                    stickyInteractive.PreStashParentTfrm = null;
                }
                else
                {
                    // Always remember the previous parent transform
                    stickyInteractive.PreEquippedParentTfrm = stickyInteractive.transform.parent;
                    stickyInteractive.PreGrabParentTfrm = null;
                }

                // Always parent it to the character equip point transform
                stickyInteractive.transform.SetParent(equipPoint.parentTransform);

                // If lasso is enabled, immediately record the local position and rotation
                if (stickyInteractive.IsLassoEnabled)
                {
                    stickyInteractive.LassoTargetPositionLS = stickyInteractive.transform.localPosition;
                    stickyInteractive.LassoTargetRotationLS = stickyInteractive.transform.localRotation;
                }

                isParented = true;
            }

            return isParented;
        }

        /// <summary>
        /// Attempt to parent an interactive-enabled object to a hand.
        /// This requires Hand IK as it gets the last position and rotation of the hand.
        /// </summary>
        /// <param name="stickyInteractive"></param>
        /// <param name="handTrfm"></param>
        /// <param name="isLeftHand"></param>
        /// <param name="isSecondaryHandHold"></param>
        /// <returns></returns>
        private bool ParentIteractive(StickyInteractive stickyInteractive, Transform handTrfm, bool isLeftHand, bool isSecondaryHandHold)
        {
            bool isParented = false;

            if (handTrfm != null)
            {
                // Set the world space position and rotation before parenting to avoid issues with character rig scaling.

                // Get the palm of the hand's relative position and rotation to the hand bone.
                Vector3 wsPosition = isLeftHand ? GetLeftHandPalmPosition() : GetRightHandPalmPosition();
                Quaternion wsRotation = isLeftHand ? GetLeftHandPalmRotation() : GetRightHandPalmRotation();

                // We want the object's hand hold rotation to point towards the palm.
                Quaternion handHoldLocalRot = Quaternion.Euler(isSecondaryHandHold ? stickyInteractive.handHold2Rotation : stickyInteractive.handHold1Rotation);

                // Consistent - but wrong (faces inward at top of cup if palm offset 180, 90, 270)
                // Cup correct angle but upside down in hand when palm offset 0, 45, 90 (palm looks correct in editor gizmos)
                wsRotation *= Quaternion.Inverse(handHoldLocalRot);

                // Subtract the hand hold offset
                wsPosition -= wsRotation * stickyInteractive.GetHandHoldLocalOffset(isSecondaryHandHold);

                stickyInteractive.transform.position = wsPosition;
                stickyInteractive.transform.rotation = wsRotation;

                // Use instead of transform.SetParent() as we may need to remember the original
                // transform for when the object is dropped.
                stickyInteractive.SetObjectParent(handTrfm);

                // If lasso is enabled, immediately record the local position and rotation
                if (stickyInteractive.IsLassoEnabled)
                {
                    stickyInteractive.LassoTargetPositionLS = stickyInteractive.transform.localPosition;
                    stickyInteractive.LassoTargetRotationLS = stickyInteractive.transform.localRotation;
                }

                isParented = true;
            }

            return isParented;
        }

        /// <summary>
        /// Attempt to reparent the weapon back to the hand that is holding it, after coming out of aim mode.
        /// NOTE: This should retain the original parent that is set in ParentIteractive(..).
        /// </summary>
        /// <param name="stickyWeapon"></param>
        internal void ReparentToHand(StickyWeapon stickyWeapon)
        {
            int interactiveID = stickyWeapon.StickyInteractiveID;

            bool isLeftHand = isLeftHandHoldingWeapon && leftHandInteractiveId == interactiveID;

            Vector3 wsPosition = Vector3.zero;
            Quaternion wsRotation = Quaternion.identity;
            GetInteractiveHandSnapLocation(stickyWeapon, isLeftHand, false, ref wsPosition, ref wsRotation);

            stickyWeapon.transform.position = wsPosition;
            stickyWeapon.transform.rotation = wsRotation;

            stickyWeapon.transform.SetParent(isLeftHand ? leftHandTrfm : rightHandTrfm);
        }

        /// <summary>
        /// Is the interactive-enabled object already selected by this character?
        /// </summary>
        /// <param name="stickyInteractiveID"></param>
        /// <returns></returns>
        internal bool IsInteractiveIDSelected(int stickyInteractiveID)
        {
            bool isSelected = false;

            // Use a slower for-loop to avoid GC
            for (int sIdx = 0; sIdx < numStoreSelectedInScene; sIdx++)
            {
                S3DStoreItem s3dStoreItem = selectedInSceneStoreItemList[sIdx];

                if (s3dStoreItem != null && s3dStoreItem.stickyInteractiveID == stickyInteractiveID)
                {
                    isSelected = true;
                    break;
                }
            }

            return isSelected;
        }

        /// <summary>
        /// Attempt to remove a S3DStoreItem from the selected list using the stickyInteractiveID.
        /// </summary>
        /// <param name="stickyInteractiveID"></param>
        internal void RemoveSelectedInteractiveID(int stickyInteractiveID)
        {
            // Use a slower for-loop to avoid GC
            for (int sIdx = 0; sIdx < numStoreSelectedInScene; sIdx++)
            {
                S3DStoreItem s3dStoreItem = selectedInSceneStoreItemList[sIdx];

                if (s3dStoreItem != null && s3dStoreItem.stickyInteractiveID == stickyInteractiveID)
                {
                    selectedInSceneStoreItemList.RemoveAt(sIdx);
                    numStoreSelectedInScene--;
                    break;
                }
            }
        }

        /// <summary>
        /// Attempt to remove a S3DStoreItem from the selected list using the zero-based index in the list
        /// </summary>
        /// <param name="index"></param>
        private void RemoveSelectedInteractiveIndex(int selectedIndex)
        {
            if (isInitialised && numStoreSelectedInScene > 0 && selectedIndex >= 0 && selectedIndex < numStoreSelectedInScene)
            {
                selectedInSceneStoreItemList.RemoveAt(selectedIndex);
                numStoreSelectedInScene--;
            }
        }

        /// <summary>
        /// Attempt to remove a S3DStoreItem from the selected list using the StoreItemID.
        /// </summary>
        /// <param name="selectedStoreItemID"></param>
        private void RemoveSelectedInteractiveByStoreItemID(int selectedStoreItemID)
        {
            if (isInitialised && numStoreSelectedInScene > 0)
            {
                // Use a slower for-loop to avoid GC
                for (int sIdx = 0; sIdx < numStoreSelectedInScene; sIdx++)
                {
                    S3DStoreItem s3dStoreItem = selectedInSceneStoreItemList[sIdx];

                    if (s3dStoreItem != null && s3dStoreItem.StoreItemID == selectedStoreItemID)
                    {
                        selectedInSceneStoreItemList.RemoveAt(sIdx);
                        numStoreSelectedInScene--;
                        break;
                    }
                }
            }
        }

        /// <summary>
        /// Set this character to be holding this interactive-enabled object.
        /// Typically called from this.HoldInteractive(stickyInteractive, isLeftHand, isSecondaryHandHold)
        /// or StickyXRInteractor.HoldInteractive(stickyInteractive, handTrfm, isSecondaryHandHold).
        /// See also ClearHoldingInteractive(..).
        /// </summary>
        /// <param name="stickyInteractive"></param>
        /// <param name="isLeftHand"></param>
        internal void SetHoldingInteractive (StickyInteractive stickyInteractive, bool isLeftHand)
        {
            if (isLeftHand)
            {
                leftHandInteractive = stickyInteractive;
                leftHandInteractiveId = stickyInteractive.StickyInteractiveID;

                // This character is hold the object
                stickyInteractive.Sticky3DCharacter = this;
                stickyInteractive.IsHeld = true;

                // Check if this is a weapon being held
                if (stickyInteractive.IsStickyWeapon)
                {
                    leftHandWeapon = (StickyWeapon)stickyInteractive;
                    isLeftHandHoldingWeapon = true;

                    // Anim Sets may override isAimIKWhenNotAiming
                    leftHandWeapon.ApplyWeaponAnimSets();

                    // By default, turn off Free Look when weapon is held
                    // By default, turn on Look Follow Head
                    if (!isFreeLookWhenWeaponHeld || isNPC)
                    {
                        // Attempt to cater for when other hand has already grabbed a weapon
                        savedFreeLook = savedFreeLook || isFreeLook;
                        SetFreeLook(false);

                        if (!isNPC)
                        {
                            savedFollowHeadPosition = savedFollowHeadPosition || isLookCameraFollowHead;
                            if (!isLookCameraFollowHead)
                            {
                                SetLookFollowHead(true);
                            }

                            savedFollowHeadPositionTP = savedFollowHeadPositionTP || isLookCameraFollowHead;
                            if (!isLookCameraFollowHeadTP)
                            {
                                SetLookFollowHeadTP(true);
                            }
                        }

                        heldTransitionTimer = heldTransitionDuration;
                    }

                    leftHandWeapon.SaveReticleSettings();

                    // Currently not smooth enable for First Person (needs fixing)
                    if (isAimIKWhenNotAiming) { EnableOrDisableAimIK(true, isThirdPerson); }
                    currentAimTargetPos = Vector3.zero;

                    // Try constraining Hand IK using weight
                    currentMaxHandIKWeight = 0f;

                    leftHandMagazine = null;
                    isLeftHandHoldingMagazine = false;

                    leftHandWeapon.EnableLaserSightIfRequired();
                    leftHandWeapon.EnableScopeIfRequired();                   
                    leftHandWeapon.CheckReticle();
                }
                // Check if this is a magazine being held
                else if (stickyInteractive.IsStickyMagazine)
                {
                    leftHandMagazine = (StickyMagazine)stickyInteractive;
                    isLeftHandHoldingMagazine = true;

                    leftHandWeapon = null;
                    isLeftHandHoldingWeapon = false;
                    // Turn off if not holding a weapon in either hand
                    EnableOrDisableAimIK(isRightHandHoldingWeapon, false);
                }
                else
                {
                    leftHandWeapon = null;
                    isLeftHandHoldingWeapon = false;
                    // Turn off if not holding a weapon in either hand
                    EnableOrDisableAimIK(isRightHandHoldingWeapon, false);

                    leftHandMagazine = null;
                    isLeftHandHoldingMagazine = false;
                }
            }
            else
            {
                rightHandInteractive = stickyInteractive;
                rightHandInteractiveId = stickyInteractive.StickyInteractiveID;

                stickyInteractive.Sticky3DCharacter = this;
                stickyInteractive.IsHeld = true;

                // Check if this is a weapon being held
                if (stickyInteractive.IsStickyWeapon)
                {
                    rightHandWeapon = (StickyWeapon)stickyInteractive;
                    isRightHandHoldingWeapon = true;

                    // Anim Sets may override isAimIKWhenNotAiming
                    rightHandWeapon.ApplyWeaponAnimSets();

                    // By default, turn off Free Look when weapon is held
                    // By default, turn on Look Follow Head
                    if (!isFreeLookWhenWeaponHeld || isNPC)
                    {
                        // Attempt to cater for when other hand has already grabbed a weapon
                        savedFreeLook = savedFreeLook || isFreeLook;
                        SetFreeLook(false);

                        if (!isNPC)
                        {
                            savedFollowHeadPosition = savedFollowHeadPosition || isLookCameraFollowHead;
                            if (!isLookCameraFollowHead)
                            {
                                SetLookFollowHead(true);
                            }

                            savedFollowHeadPositionTP = savedFollowHeadPositionTP || isLookCameraFollowHead;
                            if (!isLookCameraFollowHeadTP)
                            {
                                SetLookFollowHeadTP(true);
                            }
                        }

                        heldTransitionTimer = heldTransitionDuration;
                    }

                    rightHandWeapon.SaveReticleSettings();

                    // Currently not smooth enable for First Person (needs fixing)
                    if (isAimIKWhenNotAiming) { EnableOrDisableAimIK(true, isThirdPerson); }
                    currentAimTargetPos = Vector3.zero;

                    // Try constraining Hand IK using weight
                    currentMaxHandIKWeight = 0f;

                    rightHandMagazine = null;
                    isRightHandHoldingMagazine = false;

                    rightHandWeapon.EnableLaserSightIfRequired();
                    rightHandWeapon.EnableScopeIfRequired();                    
                    rightHandWeapon.CheckReticle();
                }
                // Check if this is a magazine being held
                else if (stickyInteractive.IsStickyMagazine)
                {
                    rightHandMagazine = (StickyMagazine)stickyInteractive;
                    isRightHandHoldingMagazine = true;

                    rightHandWeapon = null;
                    isRightHandHoldingWeapon = false;
                    // Turn off if not holding a weapon in either hand
                    EnableOrDisableAimIK(isLeftHandHoldingWeapon, false);
                }
                else
                {
                    rightHandWeapon = null;
                    isRightHandHoldingWeapon = false;
                    // Turn off if not holding a weapon in either hand
                    EnableOrDisableAimIK(isLeftHandHoldingWeapon, false);

                    rightHandMagazine = null;
                    isRightHandHoldingMagazine = false;
                }
            }
        }

        /// <summary>
        /// If a delayed equip operation is pending, stop or cancel it.
        /// </summary>
        private void StopDelayEquip (StickyInteractive equippedItem)
        {
            if (equippedItem.IsEquipFinaliseDelayed)
            {
                // Was the equipped item held before it started being placed on an equip point?
                // As it didn't get parented to the Equip Point before it ws interrupted,
                // we need to try and update the original parent.
                if (equippedItem.isReparentOnDrop && equippedItem.PreGrabParentTfrm != null)
                {
                    equippedItem.PreEquippedParentTfrm = equippedItem.PreGrabParentTfrm;
                    equippedItem.PreGrabParentTfrm = null;
                }

                if (equipInteractiveDelayed != null)
                {
                    StopCoroutine(equipInteractiveDelayed);
                    equipInteractiveDelayed = null;
                }
                equippedItem.IsEquipFinaliseDelayed = false;
            }
        }

        #endregion

        #region Private or Internal Methods - Engage Damage Regions

        /// <summary>
        /// [INCOMPLETE]
        /// Applies a specified amount of damage to the character damage region at a specified position.
        /// When there are mulitple damage regions for the character, always pass in the non-main damage region ID that was hit.
        /// Main Damage Region Only
        /// - Damage multipliers always apply.
        /// - Residual from main shield hit, is applied to main damage region.
        /// Non-main Damage Region
        /// - Damage multipliers of main damage region apply to main DR shield
        /// - Residual damage from Main DR shield is applied to other DR shield
        ///   Shield damage for the other DR uses the other DR multipliers
        /// - Residual damage from the other DR, is applied to main DR and other DR.
        /// </summary>
        /// <param name="damageRegionId"></param>
        /// <param name="damageAmount"></param>
        /// <param name="damageType"></param>
        /// <param name="damagePosition"></param>
        /// <param name="adjustForCollisionResistance"></param>
        private void ApplyDamage(int damageRegionId, float damageAmount, S3DDamageRegion.DamageType damageType, Vector3 damagePosition, bool adjustForCollisionResistance)
        {
            // Loop through all damage regions
            S3DDamageRegion thisDamageRegion = null;
            float actualDamage = 0f;
            bool regionDamaged = false;
            bool isCharacterInvincible = mainDamageRegion.isInvincible;

            // The main damage region should only be hit if there are not multiple damage regions.
            bool isHitMainDamageRegion = damageRegionId == GetMainDamageRegionID();

            //Debug.Log("[DEBUG] ApplyDamage to " + name + " damageRegionId: " + damageRegionId + " isMain: " + isHitMainDamageRegion + " T:" + Time.time);

            if (!isCharacterInvincible)
            {
                for (int drIdx = 0; drIdx < (isHitMainDamageRegion ? 1 : 2); drIdx++)
                {
                    regionDamaged = false;

                    // Always process the main damage region
                    if (drIdx == 0)
                    {
                        // Main damage region
                        thisDamageRegion = mainDamageRegion;
                        // Main damage region is always hit unless it is invincible (which would make the whole character invincible)
                        regionDamaged = !isCharacterInvincible;
                    }
                    else if (!isHitMainDamageRegion)
                    {
                        // Localised damage region
                        thisDamageRegion = GetDamageRegion(damageRegionId);

                        if (thisDamageRegion == null)
                        {
                            #if UNITY_EDITOR
                            Debug.LogWarning("Could not apply damage to " + name + " as the damageRegionId supplied was invalid (" + damageRegionId + "). PLEASE REPORT.");
                            #endif

                            regionDamaged = false;
                        }
                        // If the main damage region is invincible, so are all the damage regions
                        else if (isCharacterInvincible || thisDamageRegion.isInvincible) { regionDamaged = false; }
                        else { regionDamaged = true; }
                    }

                    // Don't do any further calculations if the region wasn't hit
                    if (regionDamaged)
                    {
                        // Adjust for collision resistance - value passed in is just an impulse magnitude
                        if (adjustForCollisionResistance)
                        {
                            if (thisDamageRegion.collisionDamageResistance < 0.01f) { actualDamage = Mathf.Infinity; }
                            else { actualDamage = damageAmount / thisDamageRegion.collisionDamageResistance * 4f / rBody.mass; }
                        }
                        else { actualDamage = damageAmount; }

                        // Modify damage dealt based on relevant damage multipliers of the region hit on the character
                        actualDamage *= thisDamageRegion.GetDamageMultiplier(damageType);

                        //Debug.Log("[DEBUG] " + name + " hit with ActualDamage: " + actualDamage);

                        // Determine whether shielding is active for this damage region
                        if (thisDamageRegion.useShielding && thisDamageRegion.ShieldHealth > 0f)
                        {
                            // Set the shielding to active
                            regionDamaged = false;
                            // Only do damage to the shield if the damage amount is above the shielding threshold
                            if (actualDamage >= thisDamageRegion.shieldingDamageThreshold)
                            {
                                thisDamageRegion.ShieldHealth -= actualDamage;
                                thisDamageRegion.shieldRechargeDelayTimer = 0f;
                                // If this damage destroys the shielding entirely...
                                if (thisDamageRegion.ShieldHealth <= 0f)
                                {
                                    // Get the residual damage value
                                    actualDamage = -thisDamageRegion.ShieldHealth;
                                    // Set the shielding to inactive
                                    regionDamaged = true;
                                    thisDamageRegion.ShieldHealth = -0.01f;
                                }
                            }
                        }

                        if (regionDamaged)
                        {
                            // Don't apply damage to main DR just yet as a shield on a bone-based damage region
                            // may obsorb all the damage.
                            if (drIdx > 0)
                            {
                                // Reduce health of non-main damage region itself
                                thisDamageRegion.Health -= actualDamage;

                                //Debug.Log("[DEBUG] " + name + " is hit + " + thisDamageRegion + " and received ActualDamage: " + actualDamage + " T:" + Time.time);
                            }
                        }
                    }
                    // Regions not damaged should have 0 damage
                    else { actualDamage = 0f; }
                }

                if (actualDamage > 0f)
                {
                    // For the main damage region, set the overall health of the character
                    SetHealth(mainDamageRegion.Health - actualDamage);
                }

            }
        }

        /// <summary>
        /// Add a default (main) damage region to the character.
        /// </summary>
        private void AddMainDamageRegion()
        {
            S3DDamageRegion damageRegion = new S3DDamageRegion()
            {
                name = "Main"
            };

            if (damageRegion != null)
            {
                damageRegionList.Add(damageRegion);

                numDamageRegions = damageRegionList == null ? 0 : damageRegionList.Count;
            }
        }

        /// <summary>
        /// Enable or disable damage systems to operate
        /// </summary>
        /// <param name="isEnabled"></param>
        private void EnableOrDisableDamage(bool isEnabled)
        {
            isDamageEnabled = isEnabled;
        }

        /// <summary>
        /// Validate the damage regions. If there are none, add a main damage region.
        /// </summary>
        /// <returns></returns>
        internal bool ValidateDamageRegions()
        {
            if (damageRegionList == null)
            {
                damageRegionList = new List<S3DDamageRegion>(5);
            }

            numDamageRegions = damageRegionList == null ? 0 : damageRegionList.Count;

            if (numDamageRegions < 1) { AddMainDamageRegion(); }

            if (mainDamageRegion == null) { mainDamageRegion = damageRegionList[0]; }

            return numDamageRegions > 0;
        }

        #endregion

        #region Private or Internal Methods - Engage Respawning

        /// <summary>
        /// Respawn the character
        /// </summary>
        private void Respawn()
        {
            // Instead of respawning, should the character be immediately destroyed?
            // See also DestroyCharacter(..)
            if (isRagdollOnDestroy && isRagdollEnabled && respawnMode == RespawningMode.DontRespawn)
            {
                #if UNITY_EDITOR
                DestroyImmediate(gameObject);
                #else
                Destroy(gameObject);
                #endif
            }
            else
            {
                // Call any event methods before respawing begins.
                if (onRespawning != null) { onRespawning.Invoke(capsuleColliderId, (int)respawnMode); }

                // Check if IsRespawning was set to false in onRespawning methods in case
                // the dev wanted to cancel this respawning instance for any reason
                if (isRespawning)
                {
                    // We are now not in the process of respawning
                    isRespawning = false;

                    // Reset the health of the character
                    ResetHealth();

                    // Set character position and rotation
                    TelePort(GetRespawnPosition(), GetRespawnRotation(), true);

                    if (isRagdollOnDestroy && isRagdollEnabled)
                    {
                        EnableOrDisableRagdoll(false);
                    }
                    else
                    {
                        // Re-enable the character and make it visible again
                        EnableOrDisableCharacter(true, true);

                        ShowCharacter();
                    }

                    if (callbackAfterRespawn != null) { callbackAfterRespawn.Invoke(this); }

                    // Call any post-respawing event methods
                    if (onRespawned != null) { onRespawned.Invoke(capsuleColliderId, (int)respawnMode); }
                }
            }
        }

        #endregion

        #region Private or Internal Methods - Engage Weapons

        private void RegisterMagazineColliders()
        {

        }

        /// <summary>
        /// Allow weapons that are held to fire.
        /// See UnpauseWeaponsFiring(delay)
        /// </summary>
        private void UnPauseWeaponsFiring()
        {
            if (!IsActivePopups())
            {
                if (isLeftHandHoldingWeapon)
                {
                    leftHandWeapon.SetIsFiringPaused(false);
                }

                if (isRightHandHoldingWeapon)
                {
                    rightHandWeapon.SetIsFiringPaused(false);
                }
            }
        }

        /// <summary>
        /// Check if the weapons need to fire based on character input.
        /// </summary>
        private void UpdateWeapons()
        {
            if (isLeftHandHoldingWeapon && leftHandInteractiveId != StickyInteractive.NoID)
            {
                leftHandWeapon.SendInput(leftHandWeaponInput);
            }

            if (isRightHandHoldingWeapon && rightHandInteractiveId != StickyInteractive.NoID)
            {
                rightHandWeapon.SendInput(rightHandWeaponInput);
            }
        }

        /// <summary>
        /// [INTERNAL USE]
        /// Be advised by a weapon that aim smooth disable has completed.
        /// Typically only required for first person player.
        /// Made public, rather than internal, so can be called by custom weapon.
        /// </summary>
        /// <param name="stickyInteractiveID"></param>
        public void WeaponAimSmoothDisabled (int stickyInteractiveID)
        {
            // Currently third person also moves the camera so we use MoveThirdPersonCamera(..)
            // to determine if aiming has completed.
            if (!isThirdPerson && isAimIKSmoothDisable)
            {
                isAimIKSmoothDisable = false;

                if (onPostStopAim != null) { onPostStopAim.Invoke(StickyID, stickyInteractiveID, false, Vector3.zero); }
            }
        }

        #endregion

        #region Interface Methods

        /// <summary>
        /// [CURRENTLY NOT IN USE - FUTURE]
        /// Shifts all the world space vectors by the delta amount
        /// </summary>
        /// <param name="positionDelta"></param>
        public void FloatingTransformShift(Vector3 positionDelta)
        {
            currentReferenceFramePosition += positionDelta;
            TelePort(positionDelta);
        }

        #endregion

        #region Public API Methods - General

        /// <summary>
        /// Turn off all audio on the character
        /// </summary>
        public void AudioMute()
        {
            MuteOrUnmuteAudio(true);
        }

        /// <summary>
        /// Enable audio on the character
        /// </summary>
        public void AudioUnMute()
        {
            MuteOrUnmuteAudio(false);
        }

        /// <summary>
        /// Toggle audio on/off for the character
        /// </summary>
        public void AudioToggle()
        {
            MuteOrUnmuteAudio(!isAudioMuted);
        }

        /// <summary>
        /// Calculate or estimate the shoulder offset from the feet.
        /// See also GetCurrentShoulderCentre().
        /// </summary>
        /// <returns></returns>
        public float CalculateShoulderHeight()
        {
            return height < 0.1f ? height : height * 0.82f;
        }

        /// <summary>
        /// You should call this rather than Destroy(gameObject) as it
        /// will safely cleanup before destroying the character.
        /// If instantDestroy is false, it will honour Respawn settings.
        /// </summary>
        /// <param name="instantDestroy">Ignore respawn setttings</param>
        public void DestroyCharacter(bool instantDestroy)
        {
            bool destroyGameObject = instantDestroy;

            if (isInitialised)
            {
                /// TODO - DestroyCharacter - check respawn options
                /// TODO - implement optional ragdoll or death sequence

                // Return any decals back to the pool
                // Do this before potentially disabling character so that we
                // don't disable any decal renderers.
                StickyManager stickyManager = StickyManager.GetOrCreateManager(sceneHandle);
                stickyManager.DestroyDecals(gameObject);

                // Do we need to drop an item in the left hand?
                if (isDropHeldOnDestroy && leftHandInteractiveId != StickyInteractive.NoID)
                {
                    if (leftHandInteractive != null)
                    {
                        DropInteractive(leftHandInteractive, true);
                    }
                }

                // Do we need to drop an item in the right hand?
                if (isDropHeldOnDestroy && rightHandInteractiveId != StickyInteractive.NoID)
                {
                    if (rightHandInteractive != null)
                    {
                        DropInteractive(rightHandInteractive, false);
                    }
                }

                if (isDropEquipOnDestroy)
                {
                    DropEquipAll();
                }

                // Do we need to drop stashed items?
                if (isDropStashOnDestroy && numStashedItems > 0)
                {
                    DropStashAll();
                }

                if (instantDestroy)
                {
                    destroyGameObject = true;
                }
                else if (respawnMode == RespawningMode.DontRespawn)
                {
                    // Might wish to have a ragdoll when dontrespawn is set.
                    if (isRagdollOnDestroy)
                    {
                        EnableOrDisableRagdoll(true);

                        // See Respawn()
                        if (isRagdollEnabled)
                        {
                            respawnTimer = respawnTime;
                            isRespawning = true;
                        }
                    }

                    destroyGameObject = !isRagdollEnabled;
                }
                else
                {
                    // Check if there are unlimited lives, or there is at least 1 remaining.
                    if (startLives < 0 || currentLives > 0)
                    {
                        if (currentLives > 0) { --currentLives; }

                        if (isRagdollOnDestroy)
                        {
                            EnableOrDisableRagdoll(true);
                        }

                        if (!isRagdollOnDestroy || !isRagdollEnabled)
                        {
                            HideCharacter();
                            EnableOrDisableCharacter(false, false);
                        }

                        respawnTimer = respawnTime;
                        isRespawning = true;
                    }
                    else
                    {
                        // Check if need to create a ragdoll one last time
                        if (isRagdollOnDestroy)
                        {
                            EnableOrDisableRagdoll(true);

                            // See Respawn()
                            if (isRagdollEnabled)
                            {
                                // Switch to DontRespawn so that Respawn() can destroy the character
                                // after the ragdoll has been active for the respawnTime duration.
                                respawnMode = RespawningMode.DontRespawn;
                                respawnTimer = respawnTime;
                                isRespawning = true;
                            }
                        }

                        destroyGameObject = !isRagdollEnabled;
                    }
                }

                if (callbackOnDestroy != null) { callbackOnDestroy.Invoke(this); }
                if (onDestroyed != null) { onDestroyed.Invoke(capsuleColliderId, (int)respawnMode); }
            }

            if (destroyGameObject)
            {
#if UNITY_EDITOR
                DestroyImmediate(gameObject);
#else
                Destroy(gameObject);
#endif
            }
        }

        /// <summary>
        /// Disables character movement, look, collision detection, jetpack and animation.
        /// See also StickyInputModule.DisableInput(..) and EnableInput().
        /// </summary>
        public void DisableCharacter(bool resetVelocity = true)
        {
            if (isInitialised) { EnableOrDisableCharacter(false, resetVelocity); }
        }

        /// <summary>
        /// Enables character movement, look (except NPCs), collision detection, jetpack and animation.
        /// See also StickyInputModule.DisableInput(..) and EnableInput().
        /// </summary>
        public void EnableCharacter(bool resetVelocity = true)
        {
            if (isInitialised) { EnableOrDisableCharacter(true, resetVelocity); }
        }

        /// <summary>
        /// Returns the current world-space centre point of the character
        /// </summary>
        /// <returns></returns>
        public Vector3 GetCurrentCentre()
        {
            if (isInitialised) { return GetCentre(currentWorldPosition, currentCharacterUp); }
            else { return GetCentre(transform.position, transform.up); }
        }

        /// <summary>
        /// Returns the current world-space centre bottom position of the character
        /// </summary>
        /// <returns></returns>
        public Vector3 GetCurrentBottom()
        {
            if (isInitialised) { return GetBottom(currentWorldPosition, currentCharacterUp); }
            else { return GetBottom(transform.position, transform.up); }
        }

        /// <summary>
        /// Returns the current world-space centre bottom position of the character with a local space offset
        /// </summary>
        /// <param name="localOffset"></param>
        /// <returns></returns>
        public Vector3 GetCurrentOffsetFromBottom(Vector3 localOffset)
        {
            if (isInitialised) { return GetBottomWithOffset(currentWorldPosition, currentCharacterUp, localOffset); }
            else { return GetBottomWithOffset(transform.position, transform.up, localOffset); }
        }

        /// <summary>
        /// Returns the current world-space centre of the shoulders of the character
        /// </summary>
        /// <returns></returns>
        public Vector3 GetCurrentShoulderCentre()
        {
            if (isInitialised) { return GetShoulderCentre(currentWorldPosition, currentCharacterUp); }
            else { return GetShoulderCentre(transform.position, transform.up); }
        }

        /// <summary>
        /// Returns the current world-space centre top position of the character
        /// </summary>
        /// <returns></returns>
        public Vector3 GetCurrentTop()
        {
            if (isInitialised) { return GetTop(currentWorldPosition, currentCharacterUp); }
            else { return GetTop(transform.position, transform.up); }
        }

        /// <summary>
        /// Returns the current position relative to the current reference frame.
        /// </summary>
        /// <returns></returns>
        public Vector3 GetCurrentRelativePosition() { return currentRelativePosition; }

        /// <summary>
        /// Returns the current rotation relative to the current reference frame.
        /// </summary>
        /// <returns></returns>
        public Quaternion GetCurrentRelativeRotation() { return currentRelativeRotation; }

        /// <summary>
        /// Returns the current velocity relative to the current reference frame.
        /// </summary>
        /// <returns></returns>
        public Vector3 GetCurrentRelativeVelocity() { return currentRelativeVelocity; }

        /// <summary>
        /// Returns the current angular velocity relative to the current reference frame.
        /// </summary>
        /// <returns></returns>
        public Vector3 GetCurrentRelativeAngularVelocity() { return currentRelativeAngularVelocity; }

        /// <summary>
        /// Get a local space direction relative to the character forward direction.
        /// </summary>
        /// <param name="wsDirection"></param>
        /// <returns></returns>
        public Vector3 GetLocalDirection(Vector3 wsDirection)
        {
            if (isInitialised) { return Quaternion.Inverse(currentWorldRotation) * wsDirection; }
            else { return Quaternion.Inverse(transform.rotation) * wsDirection; }
        }

        /// <summary>
        /// Get a local space position on the character, given a world space position
        /// (converts a world space position to a local space position on the character)
        /// </summary>
        /// <param name="wsPosition"></param>
        /// <returns></returns>
        public Vector3 GetLocalPosition(Vector3 wsPosition)
        {
            if (isInitialised) { return Quaternion.Inverse(currentWorldRotation) * (wsPosition - currentWorldPosition); }
            else { return Quaternion.Inverse(transform.rotation) * (wsPosition - transform.position); }
        }

        /// <summary>
        /// Get a local space rotation of a rotated object relative to the character.
        /// (Converts a world space rotation to a local space rotation on the character)
        /// </summary>
        /// <param name="wsRotation"></param>
        /// <returns></returns>
        public Quaternion GetLocalRotation(Quaternion wsRotation)
        {
            if (isInitialised) { return Quaternion.Inverse(currentWorldRotation) * wsRotation; }
            else { return Quaternion.Inverse(transform.rotation) * wsRotation; }
        }

        /// <summary>
        /// Get a world space position of a local space position on the character
        /// (converts a 3D position from local space to world space).
        /// </summary>
        /// <param name="localSpacePosition"></param>
        /// <returns></returns>
        public Vector3 GetWorldPosition (Vector3 localSpacePosition)
        {
            if (isInitialised) { return currentWorldPosition + (currentWorldRotation * localSpacePosition); }
            else { return transform.position + (transform.rotation * localSpacePosition); }
        }

        /// <summary>
        /// Get a world space rotation of a local space rotation on the character
        /// (converts a 3D rotation from local space to world space).
        /// </summary>
        /// <param name="localRotation"></param>
        /// <returns></returns>
        public Quaternion GetWorldRotation (Quaternion localRotation)
        {
            if (isInitialised) { return currentWorldRotation * localRotation; }
            else { return transform.rotation * localRotation; }
        }

        /// <summary>
        /// When initialised, hide the character by turning off the renderers
        /// </summary>
        public void HideCharacter()
        {
            EnableOrDisableVisibility(false);
        }

        /// <summary>
        /// Initialise the Sticky Control Module. Has no effect if called multiple times.
        /// </summary>
        public void Initialise()
        {
            if (!isInitialised)
            {
                // Get a reference to the rigidbody
                rBody = GetComponent<Rigidbody>();

                // Kinematic does not support ContinuousDynamic.
                if (rBody.collisionDetectionMode == CollisionDetectionMode.ContinuousDynamic || rBody.collisionDetectionMode == CollisionDetectionMode.Continuous)
                {
                    //rBody.collisionDetectionMode = CollisionDetectionMode.ContinuousSpeculative;
                    rBody.collisionDetectionMode = CollisionDetectionMode.Discrete;
                }

                // If user hasn't selected an interpolation mode, select Interpolate.
                // NOTE: Other rigidbodies around the character will also need to use the same to avoid jitter.
                if (rBody.interpolation == RigidbodyInterpolation.None)
                {
                    rBody.interpolation = RigidbodyInterpolation.Interpolate;
                }

                // Set up the rigidbody
                rBody.isKinematic = true;

                // Set collision detection on the rigidbody. This may get overridden
                // in ReinitialiseDamage() if there are multiple damage regions.
                rBody.detectCollisions = isTriggerColliderEnabled;

                sceneHandle = gameObject.scene.handle;

                // This also calls SetLookUpdateType(..) as there is a dependency
                SetMoveUpdateType(moveUpdateType);

                // Get a reference to the capsule collider
                capsuleCollider = GetComponent<CapsuleCollider>();
                // Set up the capsule collider
                capsuleCollider.height = height;
                capsuleCollider.radius = radius;
                capsuleCollider.center = new Vector3(0f, pivotToCentreOffsetY, 0f);
                capsuleCollider.direction = 1;
                // Disable the capsule collider - we will do our own collision detection/handling,
                // we just need a capsule collider reference for calculations (specifically ComputePenetration).
                // It can also be converted to a Trigger Collider of use with Raycasts.
                capsuleCollider.isTrigger = isTriggerColliderEnabled;
                capsuleCollider.enabled = isTriggerColliderEnabled;
                capsuleColliderId = capsuleCollider.GetInstanceID();

                // Create a new HashSet to store trigger colliders that the character may
                // enter or exit. The comparer is used to quickly compare one collider with
                // another using the InstanceId.
                S3DColliderComparer colliderComparer = new S3DColliderComparer();
                inTriggerColliders = new HashSet<Collider>(colliderComparer);

                inCollisionColliders = new HashSet<Collider>(colliderComparer);

                if (miscS3DRandom == null)
                {
                    miscS3DRandom = new S3DRandom();
                    miscS3DRandom.SetSeed(capsuleColliderId);
                }

                // Auto-active the gameobject on initialise
                if (!gameObject.activeSelf) { gameObject.SetActive(true); }

                ResetWeaponNonHitColliders();

                InitialiseScaledValues();

                audioListener = GetComponentInChildren<AudioListener>();
                isAudioListenerConfigured = audioListener == null ? false : audioListener.enabled;

                RefreshFootStepSettings();

                initialRotationY = transform.rotation.eulerAngles.y;

                EnableOrDisableSnapTurnVR(isSnapTurnVR);

                // Should be called before anything that uses the collider
                // or the pivotToCentreOffsetY
                RefreshAnimateSettings(true);

                // Keep compiler happy with editor-only settings (should fail fairly quickly)
                if (isFootIKExpanded && isHeadIKExpanded && isHandIKExpanded && isRagdollExpanded && isRootMotionExpanded && isMoveGeneralExpanded &&
                    isClimbingExpanded && isIdenficationExpanded && isLookVRExpanded && isLookGeneralExpanded && isLookClipObjectsExpanded &&
                    isLookInteractiveExpanded && isLookSocketsExpanded && isS3DAnimActionListExpanded && isAnimActionsExpanded &&
                    isAimBonesExpanded && isAimIKExpanded &&
                    isEngageGeneralExpanded && isEngageEventsExpanded && isEngageEquipExpanded && isEngageEquipPointListExpanded && isEngageRespawnExpanded &&
                    isEngageStashExpanded && isEngageDamageRegionsExpanded && isEngageDamageRegionListExpanded && 
                    showLHGizmosInSceneView && showRHGizmosInSceneView &&
                    showLookCamOffsetGizmosInSceneView && showLookFocusOffsetGizmosInSceneView &&
                    isLeftHandIKExpanded && isRightHandIKExpanded && isHandVRExpanded) { }

                // The start value is set to Nothing (0) intentially. We then set it to something sensible
                if (clipObjectMask == 0) { ResetClipObjectMask(); }

                // Remember the current setting
                lookAutoHideCursorToRestore = lookAutoHideCursor;

                ShowOrHideCursor(lookShowCursor);

                if (isThirdPerson) { SetLookThirdPerson(lookThirdPersonCamera1, false); }
                else { SetLookFirstPerson(lookFirstPersonCamera1, lookFirstPersonTransform1, false); }

                EnableOrDisableLook(lookOnInitialise);

                EnableOrDisableLookSockets(isLookSocketsEnabled);

                // Attempt to enable look movement
                //EnableOrDisableLookMovement(true);

                if (jetPackAudio != null)
                {
                    // Remember the initial volume
                    jetPackMaxVolume = jetPackAudio.volume;
                }

                ResetJetPackSettings();

                // Enabling or disabling the Animate and Hand VR Animate features, determines
                // if these are potentially available to other things like character animations,
                // Head IK, Hand IK, Foot IK, and Hand VR.
                EnableOrDisableAnimate(defaultAnimator != null);
                EnableOrDisableHandVRAnimate(leftHandAnimator != null, true);
                EnableOrDisableHandVRAnimate(rightHandAnimator != null, false);

                ReinitialiseStoreSettings();
                ReinitialiseWeapons();
                ReinitialiseDamage();
                ReinitialiseRenderVariables();

                isInputProcessed = true;

                #region Initialising ReferenceFrame
                // A mask of nothing makes no sense
                if (referenceFrameLayerMask == 0) { ResetReferenceFrameLayerMask(); }

                refUpdateTypeInt = (int)referenceUpdateType;

                // If in auto or autofirst mod, and the user hasn't set a reference frame, attempt to get one ourselves
                if ((refUpdateTypeInt == RefUpdateTypeAutoInt || refUpdateTypeInt == RefUpdateTypeAutoFirstInt) && initialReferenceFrame == null) { FindInitialReferenceFrame(); }

                if (initialReferenceFrame != null)
                {
                    SetCurrentReferenceFrame(initialReferenceFrame);

                    /// TODO - test floating point solution with Sticky3D.
                    // register IFloatingTransform with the FloatingOrigin
                    #if UNITY_2022_2_OR_NEWER
                    FloatingOriginManager floatingOriginManager = FindFirstObjectByType<FloatingOriginManager>();
                    #else
                    FloatingOriginManager floatingOriginManager = FindObjectOfType<FloatingOriginManager>();
                    #endif

                    if (floatingOriginManager != null)
                    {
                        floatingOriginManager.RegisterFloatingTransform(this);
                    }

                    isInitialised = true;

                    // Current WS pos & rot are required for SetLookFollowHead()
                    currentWorldPosition = transform.position;
                    currentWorldRotation = transform.rotation;

                    if (isLookCameraFollowHead)
                    {
                        isLookCameraFollowHead = false;
                        SetLookFollowHead(true);
                    }

                    if (onInitialised != null)
                    {
                        if (onInitialisedEvtDelay > 0f) { Invoke("DelayOnInitialiseEvents", onInitialisedEvtDelay); }
                        else { onInitialised.Invoke(capsuleColliderId); }
                    }
                }
                #if UNITY_EDITOR
                else { Debug.LogWarning("StickyControlModule - initialReferenceFrame cannot be null. Did you forget to configure it on " + gameObject.name + "?"); }
                #endif
                #endregion

                if (isInitialised)
                {
                    ReinitialiseRespawnVariables();
                }
            }
        }

        /// <summary>
        /// Pause the character but keep the look camera enabled if one is available.
        /// This is useful when pausing a game or scene.
        /// See also: DisableCharacter(), LockPosition(), UnPauseCharacter().
        /// </summary>
        public void PauseCharacter()
        {
            PauseOrUnPauseCharacter(true);
        }

        /// <summary>
        /// Reset the damping of input values.
        /// </summary>
        public void ResetInputDamping()
        {
            currentHorizontalLookInput = 0f;
            currentVerticalLookInput = 0f;
            currentOrbitLookInput = 0f;

            previousHorizontalLookInput = 0f;
            previousVerticalLookInput = 0f;
            previousOrbitLookInput = 0f;
        }

        /// <summary>
        /// Initialise lists and variables used to make the character visible or invisible. 
        /// </summary>
        public void ReinitialiseRenderVariables()
        {
            // Initialise required lists
            // Pre-size the list of renderers that is used when characters
            // are disable/enabled during respawing. If the list is too small,
            // it be expanded the first time it is used (and affect GC).
            if (activeRenderersList == null) { activeRenderersList = new List<Renderer>(8); }
        }

        /// <summary>
        /// Sets the value of gravitational acceleration for this character in metres per second per second.
        /// </summary>
        /// <param name="newGravitationalAcceleration"></param>
        public void SetGravitationalAcceleration(float newGravitationalAcceleration)
        {
            gravitationalAcceleration = newGravitationalAcceleration;
        }

        /// <summary>
        /// Set the update loop used to move the character. Automatically calls SetLookUpdateType(..)
        /// as it depends on the moveUpdateType.
        /// </summary>
        /// <param name="newMoveUpdateType"></param>
        public void SetMoveUpdateType(MoveUpdateType newMoveUpdateType)
        {
            moveUpdateType = newMoveUpdateType;

            isMoveFixedUpdate = moveUpdateType == MoveUpdateType.FixedUpdate;

            // Look Update Type has a dependency on the value of moveUpdateType.
            SetLookUpdateType(lookUpdateType);
        }

        /// <summary>
        /// Sends input (from a player or AI) to the character for movement, look and weapon control.
        /// </summary>
        /// <param name="characterInput"></param>
        public void SendInput (CharacterInput characterInput)
        {
            if (characterInput != null)
            {
                currentLocalSpaceMovementInput.x = characterInput.horizontalMove;
                // Set y when in Jet Pack mode, and user is pressing the jump or crouch buttons.
                currentLocalSpaceMovementInput.y = isJetPackAvailable && isJetPackEnabled ? (characterInput.jump ? 1f : (characterInput.crouch ? -1f : 0f)) : 0f;
                currentLocalSpaceMovementInput.z = characterInput.verticalMove;

                // Only update bool inputs once the previous ones have been processed in FixedUpdate() or Update().
                // This avoids the issue where the next SendInput is called from StickyInputModule or other
                // again before the bool value can be detected and proceessed in UpdateController(..).
                // This should only affect when FixedUpdate() is used for UpdateController(..)

                // If button input has been processed, get the new value. Else if was true before, return true, otherwise return input received

                // Jump and crouch are used for y-axis when in Jet Pack mode
                currentJumpInput = isJetPackAvailable && isJetPackEnabled ? false : (isInputProcessed ? characterInput.jump : (currentJumpInput ? true : characterInput.jump));
                currentCrouchInput = isJetPackAvailable && isJetPackEnabled ? false : (characterInput.crouchIsToggled ? (isInputProcessed && characterInput.crouch ? !currentCrouchInput : currentCrouchInput) : (isInputProcessed ? characterInput.crouch : (currentCrouchInput ? true : characterInput.crouch)));

                currentSprintInput = isInputProcessed ? characterInput.sprint : (currentSprintInput ? true : characterInput.sprint);

                if (currentCrouchInput) { currentSprintInput = false; }

                // If we don't allow sprinting backward, turn it off if not idle or moving forward
                if (currentSprintInput && !allowSprintBackward && currentLocalSpaceMovementInput.z < 0f) { currentSprintInput = false; }

                currentJetPackInput = isInputProcessed ? characterInput.jetpack : (currentJetPackInput ? true : characterInput.jetpack);
                currentSwitchLookInput = isInputProcessed ? characterInput.switchLook : (currentSwitchLookInput ? true : characterInput.switchLook);

                // When Snap Turn is enabled for VR, don't damp horizontalLook
                currentHorizontalLookInput = isLookVREnabled && isSnapTurnVR ? characterInput.horizontalLook : S3DMath.DampValue(previousHorizontalLookInput, characterInput.horizontalLook, Time.deltaTime, lookHorizontalDamping);
                previousHorizontalLookInput = currentHorizontalLookInput;

                currentVerticalLookInput = S3DMath.DampValue(previousVerticalLookInput, characterInput.verticalLook, Time.deltaTime, lookVerticalDamping);
                previousVerticalLookInput = currentVerticalLookInput;

                if (isLookVR) { currentXRLookInput = characterInput.xrLook; }

                currentZoomLookInput = characterInput.zoomLook;
                currentOrbitLookInput = S3DMath.DampValue(previousOrbitLookInput, characterInput.orbitLook, Time.deltaTime, lookOrbitDamping);
                previousOrbitLookInput = currentOrbitLookInput;

                leftHandWeaponInput.fire1 = isInputProcessed ? characterInput.leftFire1 : (leftHandWeaponInput.fire1 ? true : characterInput.leftFire1);
                leftHandWeaponInput.fire2 = isInputProcessed ? characterInput.leftFire2 : (leftHandWeaponInput.fire2 ? true : characterInput.leftFire2);
                rightHandWeaponInput.fire1 = isInputProcessed ? characterInput.rightFire1 : (rightHandWeaponInput.fire1 ? true : characterInput.rightFire1);
                rightHandWeaponInput.fire2 = isInputProcessed ? characterInput.rightFire2 : (rightHandWeaponInput.fire2 ? true : characterInput.rightFire2);

                if (isInputProcessed) { isInputProcessed = false; }
            }
        }

        /// <summary>
        /// Sends input (typically from StickyInputModule) to the character for XR control or animation.
        /// </summary>
        /// <param name="characterInputXR"></param>
        public void SendInputXR(CharacterInputXR characterInputXR)
        {
            if (characterInputXR != null && currentCharInputXR != null && previousCharInputXR != null)
            {
                previousCharInputXR.hmdPosition = currentCharInputXR.hmdPosition;
                previousCharInputXR.leftHandGrip = currentCharInputXR.leftHandGrip;
                previousCharInputXR.leftHandTrigger = currentCharInputXR.leftHandTrigger;
                previousCharInputXR.rightHandGrip = currentCharInputXR.rightHandGrip;
                previousCharInputXR.rightHandTrigger = currentCharInputXR.rightHandTrigger;

                currentCharInputXR.hmdPosition = characterInputXR.hmdPosition;
                currentCharInputXR.leftHandGrip = characterInputXR.leftHandGrip;
                currentCharInputXR.leftHandTrigger = characterInputXR.leftHandTrigger;
                currentCharInputXR.rightHandGrip = characterInputXR.rightHandGrip;
                currentCharInputXR.rightHandTrigger = characterInputXR.rightHandTrigger;
            }
        }

        /// <summary>
        /// When initialised, show the character by re-enabling renderers
        /// after the character has been hidden.
        /// </summary>
        public void ShowCharacter()
        {
            EnableOrDisableVisibility(true);
        }

        /// <summary>
        /// Unpause the character. This is useful when unpausing a game or scene.
        /// See also: EnableCharacter(), UnlockPosition(), PauseCharacter()
        /// </summary>
        public void UnpauseCharacter()
        {
            PauseOrUnPauseCharacter(false);
        }

        #endregion

        #region Public API Methods - Move

        /// <summary>
        /// Apply a force to the character which will dissipate over the duration. 
        /// </summary>
        /// <param name="forceDirection"></param>
        /// <param name="forceAmount"></param>
        /// <param name="duration"></param>
        public void AddForce(Vector3 forceDirection, float forceAmount, float duration)
        {
            ApplyForceAtPoint(forceDirection, forceAmount, duration, currentWorldPosition);
        }

        /// <summary>
        /// Apply a force to a point on the character which will dissipate over the duration. 
        /// NOTE: Currently always assumes the position is the current position of the character.
        /// THIS IS FOR FUTURE USE.
        /// </summary>
        /// <param name="forceDirection"></param>
        /// <param name="forceAmount"></param>
        /// <param name="duration"></param>
        /// <param name="position"></param>
        public void AddForceAtPosition(Vector3 forceDirection, float forceAmount, float duration, Vector3 position)
        {
            ApplyForceAtPoint(forceDirection, forceAmount, duration, currentWorldPosition);
        }

        /// <summary>
        /// Stop the character from being able to climb
        /// </summary>
        public void DisableClimbing()
        {
            EnableOrDisableClimbing(false);
        }

        /// <summary>
        /// Disable character movement without resetting velocity
        /// </summary>
        public void DisableMovement()
        {
            EnableOrDisableMovement(false, false);
        }

        /// <summary>
        /// Disable character movement and reset velocity if you wish
        /// </summary>
        /// <param name="resetVelocity"></param>
        public void DisableMovement(bool resetVelocity)
        {
            EnableOrDisableMovement(false, resetVelocity);
        }

        /// <summary>
        /// Allow the character to climb
        /// </summary>
        public void EnableClimbing()
        {
            EnableOrDisableClimbing(true);
        }

        /// <summary>
        /// Enable character movement
        /// </summary>
        public void EnableMovement()
        {
            EnableOrDisableMovement(true, false);
        }

        /// <summary>
        /// Enable character movement and reset velocity if you wish
        /// </summary>
        public void EnableMovement(bool resetVelocity)
        {
            EnableOrDisableMovement(true, false);
        }

        /// <summary>
        /// Is this a Non-Player Character?
        /// </summary>
        /// <returns></returns>
        public bool IsNPC()
        {
            return isNPC;
        }

        /// <summary>
        /// Stop the NPC or Player character from moving but keep its position, and
        /// rotation in sync with the reference frame. This can be useful when a
        /// character is sitting. To stop all movement, use DisableMovement(..). 
        /// </summary>
        public void LockPosition()
        {
            EnableOrDisableLockPosition(true);
        }

        /// <summary>
        /// Refresh and validate foot step settings. Call this after changing the audio source or
        /// the clips at runtime.
        /// </summary>
        public void RefreshFootStepSettings()
        {
            isFootStepsAvailable = false;

            numFootSteps = s3dFootstepList == null ? 0 : s3dFootstepList.Count;

            // Initialise a random generator for selecting random audio clips
            if (audioclipRandom == null)
            {
                audioclipRandom = new S3DRandom();
                if (audioclipRandom != null) { audioclipRandom.SetSeed(capsuleColliderId); }
            }

            if (footStepsAudio != null && audioclipRandom != null)
            {
                isFootStepsAvailable = true;
            }

            // Initialise the footsteps
            for (int fsIdx = 0; fsIdx < numFootSteps; fsIdx++)
            {
                S3DFootstep s3dFootstep = s3dFootstepList[fsIdx];
                if (s3dFootstep != null)
                {
                    s3dFootstep.numSurfaceTypes = s3dFootstep.surfaceTypeIntList == null ? 0 : s3dFootstep.surfaceTypeIntList.Count;

                    s3dFootstep.numTerrainTextures = s3dFootstep.s3dTerrainTextureList == null ? 0 : s3dFootstep.s3dTerrainTextureList.Count;

                    // Create an optimised integer array of the hashed terrain texture names and float array of weights
                    // Currently we only use the arrays where there 2 or more terrain textures associated with this Footstep surface action.
                    if (s3dFootstep.numTerrainTextures < 2)
                    {
                        s3dFootstep.terrainTextureIDArray = null;
                        s3dFootstep.terrainTextureWeightArray = null;
                    }
                    else
                    {
                        s3dFootstep.terrainTextureIDArray = new int[s3dFootstep.numTerrainTextures];
                        s3dFootstep.terrainTextureWeightArray = new float[s3dFootstep.numTerrainTextures];

                        for (int fsTerrainTexIdx = 0; fsTerrainTexIdx < s3dFootstep.numTerrainTextures; fsTerrainTexIdx++)
                        {
                            s3dFootstep.terrainTextureIDArray[fsTerrainTexIdx] = s3dFootstep.s3dTerrainTextureList[fsTerrainTexIdx].ID;
                            s3dFootstep.terrainTextureWeightArray[fsTerrainTexIdx] = s3dFootstep.s3dTerrainTextureList[fsTerrainTexIdx].MinWeight;
                        }
                    }

                    // Cache the number of audio clips in each footstep
                    s3dFootstep.numAudioClips = s3dFootstep.audioclipList == null ? 0 : s3dFootstep.audioclipList.Count;
                }
            }

            // Check left foot collider
            if (leftFoot != null)
            {
                Collider _footCollider = leftFoot.GetComponent<Collider>();
                if (_footCollider != null)
                {
                    leftFootColliderId = _footCollider.GetInstanceID();

                    // Prevent foot hitting main capsule collider
                    Physics.IgnoreCollision(capsuleCollider, _footCollider);

                    RegisterWeaponNonHitCollider(_footCollider);

                    if (footStepsUseMoveSpeed) { _footCollider.enabled = false; }
                }
            }
            else { leftFootColliderId = 0; }

            // Check right foot collider
            if (rightFoot != null)
            {
                Collider _footCollider = rightFoot.GetComponent<Collider>();
                if (_footCollider != null)
                {
                    rightFootColliderId = _footCollider.GetInstanceID();

                    // Prevent foot hitting main capsule collider
                    Physics.IgnoreCollision(capsuleCollider, _footCollider);

                    RegisterWeaponNonHitCollider(_footCollider);

                    if (footStepsUseMoveSpeed) { _footCollider.enabled = false; }
                }
            }
            else { rightFootColliderId = 0; }

            // Used with GetComponents(<List>) to retrieve StickySurface component from a collider without incurring GC
            if (stickySurfaceList == null) { stickySurfaceList = new List<StickySurface>(1); }
        }

        /// <summary>
        /// Set whether or not this an Non-Player Character?
        /// </summary>
        /// <param name="isCharacterNPC"></param>
        public void SetIsNPC(bool isCharacterNPC)
        {
            isNPC = isCharacterNPC;
        }

        /// <summary>
        /// Stop the character climbing. If they are on a wall they will fall off.
        /// </summary>
        public void StopClimbing()
        {
            isClimbing = false;
            isClimbingAtTop = false;
        }

        /// <summary>
        /// Stop the character moving in a single frame.
        /// This does not disable movement.
        /// </summary>
        public void StopMoving()
        {
            // Reset velocity to zero
            // Commented out in v1.1.0 Beta 12o as this is not supported with kinematic
            // rbody and raises warning in U2022.1+ 
            //rBody.velocity = Vector3.zero;
            //rBody.angularVelocity = Vector3.zero;

            currentRelativeVelocity = Vector3.zero;
            currentLocalVelocity = Vector3.zero;

            // Stop any force currently being applied
            applyForceTimer = 0f;
            applyForceAmount = 0f;

            ResetInputDamping();
        }

        /// <summary>
        /// Teleport or move the character by a given offset delta.
        /// If applicable, also teleports the third-person camera.
        /// </summary>
        /// <param name="deltaPosition"></param>
        public void TelePort (Vector3 deltaPosition)
        {
            TelePort(currentWorldPosition + deltaPosition, currentWorldRotation, false);
        }

        /// <summary>
        /// Teleport or move the character to a new place.
        /// If applicable, also teleports the third-person camera.
        /// </summary>
        /// <param name="newPosition"></param>
        /// <param name="newRotation"></param>
        /// <param name="resetVelocity"></param>
        public void TelePort (Vector3 newPosition, Quaternion newRotation, bool resetVelocity)
        {
            currentWorldPosition = newPosition;
            currentWorldRotation = newRotation;

            // Character is not stuck if it has just been teleported
            stuckTimer = 0f;
            isStuck = false;

            if (resetVelocity)
            {
                StopMoving();
            }

            // Assign our new position and rotation
            if (isMoveFixedUpdate)
            {
                rBody.MovePosition(currentWorldPosition);
                rBody.MoveRotation(currentWorldRotation);
            }
            else
            {
                transform.SetPositionAndRotation(currentWorldPosition, currentWorldRotation);
            }

            // Convert newRotation into a reference frame relative rotation by subtracting the reference frame rotation
            //currentRelativeRotation = newRotation * Quaternion.Inverse(currentReferenceFrameRotation); // OLD pre-1.0.6
            currentRelativeRotation = Quaternion.Inverse(currentReferenceFrameRotation) * newRotation;

            // Convert current position into the provided reference frame
            currentRelativePosition = Quaternion.Inverse(currentReferenceFrameRotation) * (currentWorldPosition - currentReferenceFramePosition);

            if (isThirdPerson && isLookEnabled && !isLookVR && !isNPC)
            {
                // Snap 3rd person camera immediately to teleported character offset.
                MoveThirdPersonCamera(isLookFixedUpdate, false);
            }
        }

        /// <summary>
        /// If movement is enabled, disable it.
        /// If movement is disabled, attempt to enable it.
        /// </summary>
        public void ToggleEnableMovement()
        {
            EnableOrDisableMovement(!isMovementEnabled, false);
        }

        /// <summary>
        /// Enable the NPC or Player character to move again assuming movement has not been disabled
        /// with DisableMovement().
        /// </summary>
        public void UnlockPosition()
        {
            EnableOrDisableLockPosition(false);
        }

        #endregion

        #region Public API Methods - Look

        /// <summary>
        /// Restore isLookCameraFollowHead (first person) to the state before it was saved.
        /// WARNING: Be careful not to call it multiple times in a row.
        /// </summary>
        public void CheckRestoreFollowHead()
        {
            // Restore the previous FollowHeadPosition setup
            if (savedFollowHeadPosition != isLookCameraFollowHead)
            {
                SetLookFollowHead(savedFollowHeadPosition);
            }

            savedFollowHeadPosition = false;
        }

        /// <summary>
        /// Restore isLookCameraFollowHeadTP (third person) to the state before it was saved.
        /// WARNING: Be careful not to call it multiple times in a row.
        /// </summary>
        public void CheckRestoreFollowHeadTP()
        {
            // Restore the previous FollowHeadPositionTP setup
            if (savedFollowHeadPositionTP != isLookCameraFollowHeadTP)
            {
                SetLookFollowHeadTP(savedFollowHeadPositionTP);
            }

            savedFollowHeadPositionTP = false;
        }

        /// <summary>
        /// If Free Look is off, but should be on, turn it on.
        /// Always set savedFreeLook back to false.
        /// NOTE: This never turns Free Look off.
        /// </summary>
        public void CheckRestoreFreeLook()
        {
            // If saved state is true, but Free Look is currently off,
            // turn it on.
            if (savedFreeLook && !isFreeLook)
            {
                SetFreeLook(true);
            }

            // Clear savedFreeLook after it is used
            savedFreeLook = false;
        }

        /// <summary>
        /// Re-enable reticle to locked cursor if required
        /// </summary>
        public void CheckRestoreLockedReticleToCursor()
        {
            // Restore Locked Reticle to Cursor if required
            if (savedLockedReticleToCursor && StickyDisplayModule.GetActiveDisplayModule() != null)
            {
                StickyDisplayModule.GetActiveDisplayModule().lockDisplayReticleToCursor = true;
            }

            // Clear savedLockedReticleToCursor after use
            savedLockedReticleToCursor = false;
        }

        /// <summary>
        /// Disable the Look camera(s) and camera movement.
        /// </summary>
        public void DisableLook()
        {
            EnableOrDisableLook(false);
        }

        /// <summary>
        /// The character will no longer be able to see or detect objects with a StickyInteractive component
        /// </summary>
        public void DisableLookInteractive()
        {
            EnableOrDisableLookInteractive(false);
        }

        /// <summary>
        /// Disable the movement of the character camera
        /// </summary>
        public void DisableLookMovement()
        {
            EnableOrDisableLookMovement(false);
        }

        /// <summary>
        /// The character will no longer be able to see or detect objects with a StickySocket component
        /// </summary>
        public void DisableLookSockets()
        {
            EnableOrDisableLookSockets(false);
        }

        /// <summary>
        /// Disable Snap Turn for VR
        /// </summary>
        public void DisableSnapTurnVR()
        {
            EnableOrDisableSnapTurnVR(false);
        }

        /// <summary>
        /// Enable the Look camera(s) and attempt to enable camera movement
        /// </summary>
        public void EnableLook()
        {
            EnableOrDisableLook(true);
        }

        /// <summary>
        /// The character will be able to see or detect objects with a StickyInteractive component
        /// </summary>
        public void EnableLookInteractive()
        {
            EnableOrDisableLookInteractive(true);
        }

        /// <summary>
        /// Attempt to enable character camera movement. This may be
        /// unsuccessful if an appropriate first or third person camera
        /// hasn't been setup.
        /// </summary>
        public bool EnableLookMovement()
        {
            EnableOrDisableLookMovement(true);

            return isUpdateLookMovement;
        }

        /// <summary>
        /// The character will be able to see or detect objects with a StickySocket component
        /// </summary>
        public void EnableLookSockets()
        {
            EnableOrDisableLookSockets(true);
        }

        /// <summary>
        /// Enable Snap Turn for VR
        /// </summary>
        public void EnableSnapTurnVR()
        {
            EnableOrDisableSnapTurnVR(true);
        }

        /// <summary>
        /// Get the non-zoomed distance between the third person camera and the character
        /// If possible, cache this value to avoid the sqrt.
        /// Call after changing lookCameraOffset at runtime.
        /// </summary>
        /// <returns></returns>
        public void GetCameraOffsetDistance()
        {
            lookCameraOffsetDistance = lookCameraOffset.magnitude;
        }

        /// <summary>
        /// Get the posture or starting position of the human player when wearing a VR head-mounted device.
        /// </summary>
        /// <returns></returns>
        public HumanPostureVR GetHumanPostureVR()
        {
            return humanPostureVR;
        }

        /// <summary>
        /// Get the interactive-enabled object that the character is currently looking toward
        /// </summary>
        /// <returns></returns>
        public StickyInteractive GetLookingAtInteractive()
        {
            return lookingAtInteractive;
        }

        /// <summary>
        /// Get the unique ID of the interactive-enabled object that the character is currently looking toward.
        /// If none, StickyInteractive.NoID (0) will be returned.
        /// </summary>
        /// <returns></returns>
        public int GetLookingAtInteractiveId()
        {
            return lookingAtInteractiveId;
        }

        /// <summary>
        /// If look is enabled and not an NPC, return a ray from the camera to the screen position.
        /// Otherwise, return a character forward ray from the eye position. The ray is in world space.
        /// See also GetAimingRay().
        /// </summary>
        /// <param name="screenPosition"></param>
        /// <returns></returns>
        public Ray GetLookingAtRay (Vector3 screenPosition)
        {
            if (isLookEnabled && !isNPC)
            {
                Ray ray = lookCamera1.ScreenPointToRay(screenPosition);

                // Start from the camera near clip plane
                ray.origin += ray.direction * lookCamera1.nearClipPlane;

                return ray;
            }
            else
            {
                return new Ray(GetWorldEyePosition(), currentCharacterFwd);
            }
        }

        /// <summary>
        /// Get the StickySocket that the character is currently looking toward
        /// </summary>
        /// <returns></returns>
        public StickySocket GetLookingAtSocket()
        {
            return lookingAtSocket;
        }

        /// <summary>
        /// Get the unique ID of the sticky socket that the character is currently looking toward.
        /// If none, StickySocket.NoID (0) will be returned.
        /// </summary>
        /// <returns></returns>
        public int GetLookingAtSocketId()
        {
            return lookingAtSocketId;
        }

        /// <summary>
        /// Get the current eye-level position for this character
        /// </summary>
        /// <returns></returns>
        public Vector3 GetWorldEyePosition()
        {
            // Is third person camera OR first person without a camera setup
            if (isThirdPerson || !isLookEnabled || lookTransform == null)
            {
                float eyeFeetOffsetY = (currentScaledHeight * 0.5f) - (currentScaledHeight * (1f - 0.942f)) + (pivotToCentreOffsetY * currentScaledHeight / height);
                return GetBottom(currentWorldPosition, currentCharacterUp, false, eyeFeetOffsetY) + (currentWorldRotation * (Vector3.forward * (radius * 0.5f)));
            }
            else
            {
                return lookTransform.position;
            }
        }

        /// <summary>
        /// Get the direction the character is looking
        /// </summary>
        /// <returns></returns>
        public Vector3 GetWorldLookDirection()
        {
            // Third Person camera
            if (isThirdPerson)
            {
                if (lookThirdPersonCamera1 != null)
                {
                    return lookThirdPersonCamera1.transform.forward;
                }
                else { return GetCurrentForward; }
            }
            // First Person Camera
            else if (lookTransform != null)
            {
                return lookTransform.forward;
            }
            else { return GetCurrentForward; }
        }

        /// <summary>
        /// Check if this character can see the lookTo 3D position with a clear line of sight AND they are
        /// within the Max LoS Field of View (See Look tab).
        /// If useEyePosition is false, it uses the centre of the character.
        /// Other S3D characters can be detected if they have "Trigger Collider" is enabled on the Collide tab.
        /// This will return false when the character is respawning.
        /// </summary>
        /// <param name="lookTo"></param>
        /// <param name="useEyePosition"></param>
        /// <param name="debugInSceneView">Has no effect in a build</param>
        /// <returns></returns>
        public bool IsInLineOfSight(Vector3 lookTo, bool useEyePosition = true, bool debugInSceneView = false)
        {
            if (isRespawning) { return false; }

            // Assume Line of Sight unless we hit something
            bool isLoS = true;

            Vector3 lookFrom = useEyePosition ? GetWorldEyePosition() : GetCentre(currentWorldPosition, currentCharacterUp);
            Vector3 lookVector = lookTo - lookFrom;

            // Check the field of view
            float lookAngle = Vector3.Angle(lookVector, currentWorldRotation * Vector3.forward) * 2f;

            if (lookAngle > lookMaxLoSFoV || lookAngle < -lookMaxLoSFoV)
            {
                isLoS = false;

#if UNITY_EDITOR
                if (debugInSceneView) { Debug.DrawRay(lookFrom, lookVector, Color.blue); }
#endif
            }
            else
            {
                // Temp reusable hit array
                if (raycastHitInfoArray == null) { raycastHitInfoArray = new RaycastHit[20]; }

                Ray ray = new Ray(lookFrom, lookVector);

#if UNITY_EDITOR
                if (debugInSceneView) { Debug.DrawRay(lookFrom, lookVector, Color.blue); }
#endif

                // Get all hits between lookFrom position and this character. Include triggers.
                int numHits = Physics.RaycastNonAlloc(ray, raycastHitInfoArray, lookVector.magnitude - radius - 0.001f, ~0, QueryTriggerInteraction.Collide);

                if (numHits > 1) { S3DUtils.SortHitsAsc(raycastHitInfoArray, numHits); }

                for (int hitIdx = 0; hitIdx < numHits; hitIdx++)
                {
                    RaycastHit hitInfo = raycastHitInfoArray[hitIdx];
                    Collider collider = hitInfo.collider;

                    // Make sure this isn't a item attached to this character
                    if (!IsColliderSelf(collider.GetInstanceID()))
                    {
                        if (!collider.isTrigger)
                        {
                            isLoS = false;
                            break;
                        }
                        // Check to see if there is a S3D script attached to a trigger collider
                        // This requires that "Trigger Collider" is enabled on the Collide tab
                        // of the other S3D character.
                        else
                        {
                            Rigidbody hitRigidbody = hitInfo.rigidbody;
                            StickyControlModule hitSticky3D = null;

                            // Did we hit another character?
                            if (hitRigidbody != null && hitRigidbody.TryGetComponent(out hitSticky3D))
                            {
                                isLoS = false;
                                break;
                            }
                        }
                    }
                }
            }
            return isLoS;
        }

        /// <summary>
        /// Attempt to lock the third-person camera to the current world space position, relative to the reference frame.
        /// Doesn't work if an NPC, or Aim IK is enabled.
        /// </summary>
        public void LockThirdPersonCameraPosition()
        {
            if (isThirdPerson && isThirdPersonValid && !isNPC && !isLookVR && !isAimAtTargetEnabled && lookTransform != null)
            {
                LockThirdPersonCameraPosition(lookTransform.position);
            }
        }

        /// <summary>
        /// Attempt to lock the third-person camera to the given world space position, relative to the reference frame.
        /// Doesn't work if an NPC, Aim IK or LookVR is enabled.
        /// </summary>
        public void LockThirdPersonCameraPosition (Vector3 newWorldCameraPosition)
        {
            if (isThirdPerson && isThirdPersonValid && !isNPC && !isLookVR && !isAimAtTargetEnabled)
            {
                currentCameraRefFrameOffset = Quaternion.Inverse(currentReferenceFrameRotation) * (newWorldCameraPosition - currentReferenceFramePosition);

                GetCameraOffsetDistance();

                isLockCamToWorldPos = true;
            }
        }

        /// <summary>
        /// Attempt to lock the third-person camera to the current world space rotation, relative to the reference frame.
        /// Doesn't work if an NPC, or Aim IK is enabled.
        /// </summary>
        public void LockThirdPersonCameraRotation()
        {
            if (isThirdPerson && isThirdPersonValid && !isNPC && !isLookVR && !isAimAtTargetEnabled && lookTransform != null)
            {
                LockThirdPersonCameraRotation(lookTransform.rotation);
            }
        }

        /// <summary>
        /// Attempt to lock the third-person camera to the given world space rotation, relative to the reference frame.
        /// Doesn't work if an NPC, Aim IK or LookVR is enabled.
        /// </summary>
        public void LockThirdPersonCameraRotation (Quaternion newWorldCameraRotation)
        {
            if (isThirdPerson && isThirdPersonValid && !isNPC && !isLookVR && !isAimAtTargetEnabled)
            {
                currentCameraRefFrameRot = Quaternion.Inverse(currentReferenceFrameRotation) * newWorldCameraRotation;

                isLockCamToWorldRot = true;
            }
        }

        /// <summary>
        /// Use the current head-mounted device distance from the floor to recalcute the height
        /// of the human player. Has no effect for NPCs or non-VR players.
        /// This is automatically called on start from StickyInputModule.
        /// </summary>
        public void RecalculateFloorOffsetVR()
        {
            if (!isNPC && currentCharInputXR != null)
            {
                initialHMDFloorOffset = currentCharInputXR.hmdPosition;

                Vector3 _currentEyePos = GetWorldEyePosition();

                float deltaHeight = initialHMDFloorOffset.y - _currentEyePos.y;

                if (lookFirstPersonTransform1 == null)
                {
                    initialHMDCameraDelta = Vector3.zero;
                    initialFirstPersonCameraOffsetVR = Vector3.zero;
                }
                // Should we modify the character height to match the estimated height of the human player?
                else if (isMatchHumanHeightVR)
                {
                    if (pivotToCentreOffsetY > deltaHeight)
                    {
                        pivotToCentreOffsetY += deltaHeight;
                    }

                    initialHMDCameraDelta = Vector3.zero;

                    height = initialHMDFloorOffset.y / 0.942f;
                    shoulderHeight = CalculateShoulderHeight();

                    // Move collider position
                    capsuleCollider.center = new Vector3(0f, pivotToCentreOffsetY, 0f);

                    // Resize the main character collider
                    capsuleCollider.height = height;

                    InitialiseScaledValues();

                    SetLookCameraHeight();

                    ReinitialiseCameraSettings();

                    initialFirstPersonCameraOffsetVR = lookFirstPersonTransform1.localPosition;
                }
                else if (humanPostureVR == HumanPostureVR.Sitting)
                {
                    // We assume the first person camera height has already been set.
                    // The first person height remains the same but we need to record the initial
                    // difference between the camera and the HMD. When the HMD moves, we can determine
                    // what the height of the camera should be (assuming we want to move in sync)

                    initialFirstPersonCameraOffsetVR = lookFirstPersonTransform1.localPosition;
                    initialHMDCameraDelta = initialHMDFloorOffset - initialFirstPersonCameraOffsetVR;
                }
                // Assume HumanPostureVR.Standing
                else
                {
                    // We assume the first person camera height has already been set.
                    // The first person height remains the same but we need to record the initial
                    // difference between the camera and the HMD. When the HMD moves, we can determine
                    // what the height of the camera should be (assuming we want to move in sync)

                    initialFirstPersonCameraOffsetVR = lookFirstPersonTransform1.localPosition;
                    initialHMDCameraDelta = initialHMDFloorOffset - initialFirstPersonCameraOffsetVR;

                    //Debug.Log("[DEBUG] initialHMDCameraDelta: " + initialHMDCameraDelta.y);
                }

                isHeightCalibratedVR = true;

                //Debug.Log("[DEBUG] hmd: " + initialHMDFloorOffset + " original avatar eye: " + _currentEyePos.y + " new avatar eye: " + GetWorldEyePosition().y + " initialHMDCameraDelta: " + initialHMDCameraDelta);
            }
        }

        /// <summary>
        /// Call this after changing camera properties OR changing the camera with SetLookCamera1(..)
        /// </summary>
        public void ReinitialiseCameraSettings()
        {
            if (isThirdPerson && lookThirdPersonCamera1 != null)
            {
                // Calculate the half width, height and depth of the camera view. This can be used with
                // Physics.Boxcast to "see" objects in front of the camera.
                viewHalfExtents = Vector3.zero;
                // fieldOfView is in degrees. Convert to radians.
                viewHalfExtents.y = lookThirdPersonCamera1.nearClipPlane * Mathf.Tan(0.5f * Mathf.Deg2Rad * lookThirdPersonCamera1.fieldOfView);
                viewHalfExtents.x = viewHalfExtents.y * lookThirdPersonCamera1.aspect;

                rBodyCamera = lookThirdPersonCamera1.GetComponent<Rigidbody>();

                // Caters for the situation when script was already attached, but without a rigidbody
                if (rBodyCamera == null)
                {
                    rBodyCamera = lookThirdPersonCamera1.gameObject.AddComponent<Rigidbody>();
#if UNITY_EDITOR
                    Debug.Log("StickyControlModule - Adding missing Rigidbody to third person camera (" + lookThirdPersonCamera1.name + ")");
#endif
                }

                if (lookCameraOffset == Vector3.zero)
                {
#if UNITY_EDITOR
                    Debug.LogWarning("StickyControlModule - Did you forget to set the third person Camera Offset on the Look tab? (0,0,0 will produce Look rotation issues on " + gameObject.name + ")");
#endif
                }

                // Default third-person aiming offset to the current TP offset.
                if (aimIKCameraOffsetTPS == Vector3.zero)
                {
                    aimIKCameraOffsetTPS = lookCameraOffset;
                }

                // Set up the third person camera rigidbody
                rBodyCamera.mass = 1f;
                rBodyCamera.isKinematic = true;
                // Set 3rd person camera rigidbody interpolation to the same as character
                rBodyCamera.interpolation = rBody.interpolation;
            }

            StopCameraShake();

            if (isThirdPerson)
            {
                GetCameraOffsetDistance();
                SetLookUnorbitDelay(lookUnorbitDelay);
            }

            SetLookUnzoomDelay(lookUnzoomDelay);
            SetFreeLook(isFreeLook);
            SetLookVR(isLookVR);

            // Used for input damping
            ResetInputDamping();

            // The start value is set to Nothing (0) intentially. We then set it to something sensible
            if (clipObjectMask == 0) { ResetClipObjectMask(); }
        }

        /// <summary>
        /// This is currently used with room scale VR to determine where the
        /// camera (or character) was facing and the character was standing.
        /// It gets called from stickyInputModule.CalibrateXR()
        /// </summary>
        public void ReinitiliseCameraVR()
        {
            initialCameraRotationVR = transform.rotation;
            initialCameraPositionVR = transform.position;
        }

        /// <summary>
        /// Reset the clip object mask to their default values
        /// </summary>
        public void ResetClipObjectMask()
        {
            // Everything, except TransparentFX (1), IgnoreRaycast (2),  UI (5)
            clipObjectMask = ~((1 << 1) | (1 << 2) | (1 << 5));
        }

        /// <summary>
        /// Attempt to reset FreeLook to default position
        /// </summary>
        public void ResetFreeLook()
        {
            if (isFreeLook)
            {
                if (isThirdPerson)
                {
                    currentLookRotation = Quaternion.identity;
                    localTurnedY = 0f;
                }
                else
                {
                    // First person free look
                    localTurnedY = 0f;
                    currentLookRotEulerAngles.y = 0f;

                }
                StopCameraShake();

                // no zoom or orbit
                zoomFactor = 0f;
                orbitHorizontalAngle = 0f;
                orbitVerticalAngle = 0f;

                GetCameraOffsetDistance();

                if (isThirdPerson && !isNPC && !isLookVR && lookTransform != null)
                {
                    // Cut directly to the offset, force the camera to snap there.
                    MoveThirdPersonCamera(isLookFixedUpdate, false);
                }
            }
        }

        /// <summary>
        /// Save if reticle is locked to cursor on Sticky Display Module (HUD).
        /// Only is saved if it hasn't already been saved. Also sets Lock Reticle to Cursor.
        /// </summary>
        public void SaveAndSetLockedReticleToCursor (bool isLockReticleToCursor)
        {
            // Save HUD Locked Reticle to Cursor if required
            // Don't overwrite an existing true value in case called multiple times before being
            // restored with CheckRestoreLockedCursor().

            StickyDisplayModule stickyDisplayModule = StickyDisplayModule.GetActiveDisplayModule();

            if (stickyDisplayModule != null)
            {
                if (!savedLockedReticleToCursor)
                {
                    savedLockedReticleToCursor = stickyDisplayModule.lockDisplayReticleToCursor;
                }

                stickyDisplayModule.lockDisplayReticleToCursor = isLockReticleToCursor;
            }
        }

        /// <summary>
        /// Set the posture or starting position of the human player when wearing a VR head-mounted device.
        /// </summary>
        /// <returns></returns>
        public void SetHumanPostureVR (HumanPostureVR newPosture)
        {
            humanPostureVR = newPosture;
        }

        /// <summary>
        /// Set the local space point on the character where the third person camera focuses
        /// relative to the origin or pivot point of the character prefab.
        /// </summary>
        /// <param name="focusOffset"></param>
        public void SetLookCamerFocusOffsetTP (Vector3 focusOffset)
        {
            lookFocusOffset = focusOffset;
        }

        /// <summary>
        /// Set the camera offset or distance from the character when in third person mode.
        /// </summary>
        /// <param name="cameraOffset"></param>
        public void SetLookCameraOffsetTP (Vector3 cameraOffset)
        {
            if (cameraOffset != Vector3.zero)
            {
                lookCameraOffset = cameraOffset;
                GetCameraOffsetDistance();
            }
        }

        /// <summary>
        /// Set if StickySockets will be highlighted when looked at and Look Sockets is enabled.
        /// </summary>
        /// <param name="isAutoShow"></param>
        public void SetLookSocketAutoShow (bool isAutoShow)
        {
            if (!isAutoShow && isLookSocketsEnabled)
            {
                StopLookAtSocket();
            }

            isLookSocketAutoShow = isAutoShow;
        }

        /// <summary>
        /// Call this when setting or changing the camera transform that will be rotated when the player
        /// looks in a particular direction. For First Person, it must be a child of the player character gameobject
        /// </summary>
        /// <param name="newLookTransform"></param>
        public void SetLookTransform (Transform newLookTransform)
        {
            if (newLookTransform == null)
            {
                lookTransform = null;
            }
            else if (isThirdPerson)
            {
                if (!newLookTransform.IsChildOf(transform))
                {
                    lookTransform = newLookTransform;
                }
#if UNITY_EDITOR
                else
                {
                    Debug.LogWarning("The Look Transform must not be a child of the parent Sticky3D Controller gameobject (" + transform.name + ") or part of the prefab.");
                }
#endif
            }
            else
            {
                if (newLookTransform.IsChildOf(transform))
                {
                    lookFirstPersonTransform1 = newLookTransform;
                    lookTransform = newLookTransform;
                }
#if UNITY_EDITOR
                else
                {
                    Debug.LogWarning("The Look Transform must be a child of the parent Sticky3D Controller gameobject (" + transform.name + ") or part of the prefab.");
                }
#endif
            }

            isUpdateLookMovement = lookTransform != null;
        }

        /// <summary>
        /// Call this when setting or changing the child camera that will be used to look around with the player.
        /// Will return false if the camera is null or it is not changed.
        /// </summary>
        /// <param name="newLookCamera1"></param>
        /// <param name="isAutoEnableLook">Will automatically enable or disable look</param>
        public bool SetLookCamera1(Camera newLookCamera1, bool isAutoEnableLook)
        {
            bool isCameraSet = false;

            // Remember the current camera for the callback
            Camera oldCamera = lookCamera1;

            if (newLookCamera1 == null)
            {
                lookCamera1 = null;
                if (isAutoEnableLook) { isLookEnabled = false; }
            }
            else if (!isThirdPerson)
            {
                if (newLookCamera1.transform.IsChildOf(transform))
                {
                    lookCamera1 = newLookCamera1;
                    if (isAutoEnableLook) { EnableOrDisableLook(true); }
                    isThirdPersonValid = false;

                    CalcFirstPersonFeetOffsetY(newLookCamera1.transform);

                    isCameraSet = true;
                }
#if UNITY_EDITOR
                else
                {
                    Debug.LogWarning("The first person camera must be a child of the parent Sticky3D Controller gameobject (" + transform.name + ") or part of the prefab.");
                }
#endif
            }
            else
            {
                if (!newLookCamera1.transform.IsChildOf(transform))
                {
                    lookCamera1 = newLookCamera1;
                    lookThirdPersonCamera1 = newLookCamera1;
                    if (isAutoEnableLook) { EnableOrDisableLook(true); }
                    isCameraSet = true;
                }
#if UNITY_EDITOR
                else
                {
                    Debug.LogWarning("The third person camera must not be a child of the parent Sticky3D Controller gameobject (" + transform.name + ") or part of the prefab.");
                }
#endif
            }

            // If the camera has been changed:
            // a) notify weapon(s) if any are being held
            // b) call the callback if it has been set
            if (isCameraSet)
            {
                if (isLeftHandHoldingWeapon) { leftHandWeapon.CharacterChangedCamera(capsuleColliderId, oldCamera, lookCamera1, isThirdPerson); }
                if (isRightHandHoldingWeapon) { rightHandWeapon.CharacterChangedCamera(capsuleColliderId, oldCamera, lookCamera1, isThirdPerson); }

                if (callbackOnCameraChange != null)
                {
                    callbackOnCameraChange(capsuleColliderId, oldCamera, lookCamera1, isThirdPerson);
                }

                // VR currently does not support the StickyDisplayModule
                if (!isLookVREnabled)
                {
                    // Automatically change the StickyDisplay camera if required
                    StickyDisplayModule displayModule = StickyDisplayModule.GetActiveDisplayModule();
                    if (displayModule != null && displayModule.mainCamera != null && (oldCamera == null || displayModule.mainCamera.GetInstanceID() == oldCamera.GetInstanceID()))
                    {
                        displayModule.SetCamera(lookCamera1);
                    }
                }
            }

            return isCameraSet;
        }

        /// <summary>
        /// Set (first person) camera height offset position 
        /// </summary>
        public void SetLookCameraHeight()
        {
            if (!isThirdPerson && lookCamera1 != null)
            {
                if (!isInitialised) { InitialiseScaledValues(); }

                lookCamera1.transform.localPosition = GetFirstPersonCameraHeight(lookCamera1.transform.localPosition);
            }
        }

        /// <summary>
        /// Configure the controller for First Person.
        /// Note, this can automatically set look movement to true.
        /// </summary>
        /// <param name="firstPersonCamera"></param>
        /// <param name="firstPersonTransform"></param>
        /// <param name="isAutoEnableLook"></param>
        public void SetLookFirstPerson(Camera firstPersonCamera, Transform firstPersonTransform, bool isAutoEnableLook)
        {
            // Turn off the third person camera if it was on
            if (lookThirdPersonCamera1 != null && lookThirdPersonCamera1.isActiveAndEnabled)
            {
                // If currently aiming and currently in third person, disable aiming.
                if (isAimAtTargetEnabled && isThirdPerson)
                {
                    // Turn off aiming immediately so we reset the third-person camera settings.
                    // NOTE: This will also go immediately to the non-aiming animation.
                    // Currently can only aim with one hand/weapon at a time
                    if (isLeftHandHoldingWeapon && leftHandWeapon.IsAiming)
                    {
                        leftHandWeapon.StopAiming(false);
                    }
                    else if (isRightHandHoldingWeapon && rightHandWeapon.IsAiming)
                    {
                        rightHandWeapon.StopAiming(false);
                    }
                }

                lookThirdPersonCamera1.enabled = false;
                lookThirdPersonCamera1.gameObject.SetActive(false);
            }

            StopCameraShake();
            isThirdPerson = false;

            if (SetLookCamera1(firstPersonCamera, isAutoEnableLook))
            {
                SetLookTransform(firstPersonTransform);

                SetLookCameraHeight();

                ReinitialiseCameraSettings();
            }

            isThirdPersonValid = false;

            // Doesn't seem to work here
            //CentreCursor();
        }

        /// <summary>
        /// Set the first-person camera position to react to changes in the
        /// head bone position of a humanoid character.
        /// Has no effect if character is not initialised.
        /// </summary>
        /// <param name="isEnabled"></param>
        public void SetLookFollowHead(bool isEnabled)
        {
            // Only set if it has changed and character is already initialised.
            if (isInitialised && isLookCameraFollowHead != isEnabled)
            {
                if (isEnabled)
                {
                    // Remember the first person camera position
                    if (lookFirstPersonTransform1 != null)
                    {
                        initialLookCamOffset = lookFirstPersonTransform1.localPosition;

                        // If in 3rd person, we may not have set the 1st person
                        // camera position yet.
                        if (initialLookCamOffset.y == 0f && isThirdPerson)
                        {
                            // Recalculate camera offset
                            CalcFirstPersonFeetOffsetY(lookFirstPersonTransform1);

                            // Set the first person camera position while still in 3rd person.
                            initialLookCamOffset = GetFirstPersonCameraHeight(lookFirstPersonTransform1.localPosition);
                            lookFirstPersonTransform1.localPosition = initialLookCamOffset;
                        }

                        // If we can't find the head bone of a humanoid rig, set the position to
                        // be the same as the first person camera.
                        if (!GetBoneBottomOffset(HumanBodyBones.Head, ref initialLookHeadOffset))
                        {
                            initialLookHeadOffset = initialLookCamOffset;
                        }
                    }
                }
                else
                {
                    // Restore the original first person camera position
                    if (lookFirstPersonTransform1 != null)
                    {
                        lookFirstPersonTransform1.localPosition = initialLookCamOffset;
                    }
                }

                isLookCameraFollowHead = isEnabled;
            }
        }

        /// <summary>
        /// Set the third person camera to follow the local offset of the head on a humanoid character.
        /// Currently Follow Head in third-person has no effect when Head IK is enabled.
        /// </summary>
        /// <param name="isEnabled"></param>
        public void SetLookFollowHeadTP (bool isEnabled)
        {
            // Only set if it has changed and character is already initialised.
            if (isInitialised && isLookCameraFollowHeadTP != isEnabled)
            {
                if (isEnabled)
                {
                    // We don't need to remember the third person camera position as this
                    // defaults to lookCameraOffset.

                    // If we can't find the head bone of a humanoid rig, do not enable isLookCameraFollowHeadTP.
                    if (GetBoneBottomOffset(HumanBodyBones.Head, ref initialLookHeadOffsetTP))
                    {
                        isLookCameraFollowHeadTP = true;
                    }
                    #if UNITY_EDITOR
                    else
                    {
                        Debug.LogWarning("[ERROR] StickyControlModule.SetLookFollowHeadTP - SetLookFollowHeadTP failed for " + transform.name);
                    }
                    #endif
                }
                else
                {
                    // We don't need to restore the original third person camera position
                    // as it defaults to lookCameraOffset.
                    isLookCameraFollowHeadTP = false;
                }
            }
        }

        /// <summary>
        /// Attempt to enable or disable the Free Look mode.
        /// </summary>
        /// <param name="isEnabled"></param>
        public void SetFreeLook(bool isEnabled)
        {
            isFreeLook = isEnabled;

            if (isThirdPerson)
            {
                currentLookRotation = Quaternion.identity;
                localTurnedY = 0f;
            }
            else
            {
                // First person free look
                localTurnedY = 0f;
                currentLookRotEulerAngles.y = 0f;

            }
            StopCameraShake();
        }

        /// <summary>
        /// Configure the controller for Third Person.
        /// Optionally start at current camera position and don't cut directly to the offset position.
        /// </summary>
        /// <param name="thirdPersonCamera"></param>
        /// <param name="isAutoEnableLook"></param>
        /// <param name="cutToCamera"></param>
        public void SetLookThirdPerson(Camera thirdPersonCamera, bool isAutoEnableLook, bool cutToCamera = true)
        {
            // If currently aiming and currently in first person, disable aiming.
            if (isAimAtTargetEnabled && !isThirdPerson)
            {
                // Turn off aiming immediately so we reset the first-person camera settings.
                // NOTE: This will also go immediately to the non-aiming animation.
                // Currently can only aim with one hand/weapon at a time
                if (isLeftHandHoldingWeapon && leftHandWeapon.IsAiming)
                {
                    leftHandWeapon.StopAiming(false);
                }
                else if (isRightHandHoldingWeapon && rightHandWeapon.IsAiming)
                {
                    rightHandWeapon.StopAiming(false);
                }
            }

            // Turn off the first person camera if it was on
            if (lookFirstPersonCamera1 != null && lookFirstPersonCamera1.isActiveAndEnabled)
            {
                lookFirstPersonCamera1.enabled = false;
                lookFirstPersonCamera1.gameObject.SetActive(false);
            }

            isThirdPerson = true;

            if (SetLookCamera1(thirdPersonCamera, isAutoEnableLook))
            {
                SetLookTransform(thirdPersonCamera.transform);

                // This is in local space (changed in v1.0.1)
                currentFocusPosition = lookFocusOffset;

                // Should we use the current camera position or immediately cut to the offset location?
                currentCameraPosition = lookTransform == null ? Vector3.zero : cutToCamera ? lookCameraOffset : GetLocalPosition(lookTransform.position);
                previousOptimalCameraPosition = currentCameraPosition;

                ReinitialiseCameraSettings();

                // no zoom or orbit
                zoomFactor = 0f;
                orbitHorizontalAngle = 0f;
                orbitVerticalAngle = 0f;

                // When switching from first person (while lookHorizontalInput is non-zero) and
                // isFreeLook is enabled, the character can continue to rotate.
                currentLocalAngularVelocity.y = 0f;

                isThirdPersonValid = true;

                // If we are cutting directly to the offset, force the camera to snap there.
                if (cutToCamera && lookTransform != null) { MoveThirdPersonCamera(isLookFixedUpdate, false); }
            }

            // Doesn't seem to work here
            //CentreCursor();
        }

        /// <summary>
        /// Set the amount of normalised orbit rotation for the third person camera.
        /// The range of values is between -1 and 1.0. A value of 0 applies no orbital rotation.
        /// Calling SetLookOrbitAmount() will reset the orbit to the Look Camera Offset
        /// with no rotation.
        /// </summary>
        /// <param name="orbitAmount">Range between -1.0 and 1.0</param>
        public void SetLookOrbitAmount(float orbitAmount = 0f)
        {
            if (orbitAmount < -1f || orbitAmount > 1f) { orbitHorizontalAngle = 0f; }
            else { orbitHorizontalAngle = orbitAmount * 360f; }
        }

        /// <summary>
        /// Set the update loop used to move or rotate the camera
        /// </summary>
        /// <param name="newLookUpdateType"></param>
        public void SetLookUpdateType(LookUpdateType newLookUpdateType)
        {
            lookUpdateType = newLookUpdateType;

            // Move camera in FixedUpdate if either:
            // - Look is in FixedUpdate mode
            // - Look is in Automatic mode and the character rigidbody has interpolation "None"

            // Move camera in LateUpdate if any of the following:
            // - Look is in LateUpdate mode
            // - Look is in Automatic mode and move is in not in FixedUpdate
            // - Look is in Automatic mode and move is in FixedUpdate and the character rigidbody has interpolation enabled

            // v1.0.3 modified to only use FixedUpdate for camera when move is fixed update AND interpolation is none. 
            isLookFixedUpdate = lookUpdateType == LookUpdateType.FixedUpdate ||
                                (lookUpdateType == LookUpdateType.Automatic &&
                                isMoveFixedUpdate && rBody.interpolation == RigidbodyInterpolation.None);

            // v1.0.0 - 1.0.2
            //isLookFixedUpdate = lookUpdateType == LookUpdateType.FixedUpdate ||
            //        (lookUpdateType == LookUpdateType.Automatic &&
            //        (isMoveFixedUpdate || rBody.interpolation == RigidbodyInterpolation.None));

        }

        /// <summary>
        /// Set the unorbit delay for the third person camera.
        /// </summary>
        /// <param name="newValue"></param>
        public void SetLookUnorbitDelay(float newValue)
        {
            if (newValue < 0f) { newValue = 0f; }

            lookUnorbitDelay = newValue;
            if (newValue < unorbitTimer) { unorbitTimer = newValue; }
        }

        /// <summary>
        /// Set the unzoom delay for the first or third person camera.
        /// </summary>
        /// <param name="newValue"></param>
        public void SetLookUnzoomDelay(float newValue)
        {
            if (newValue < 0f) { newValue = 0f; }

            lookUnzoomDelay = newValue;
            if (newValue < unzoomTimer) { unzoomTimer = newValue; }
        }

        /// <summary>
        /// Should the LookingAtPoint data be updated every frame? This is useful, if you
        /// want to know where in world space the user is looking. Currently it is only
        /// updated if Look Interactive is also enabled.
        /// </summary>
        /// <param name="isUpdated"></param>
        public void SetUpdateLookingAtPoint(bool isUpdated)
        {
            isUpdateLookingAtPoint = isUpdated;
        }

        /// <summary>
        /// Attempt to enable or disable Look VR. When enabling, you
        /// should set this before calling EnableLook()
        /// </summary>
        /// <param name="isEnabled"></param>
        public void SetLookVR(bool isEnabled)
        {
            if (isEnabled)
            {
                // LookVR currently requires FreeLook
                if (!isFreeLook && IsLookVRAvailable) { SetFreeLook(true); }

                isLookVR = true;
            }
            else
            {
                isLookVR = false;
                isLookVREnabled = false;
            }
        }

        /// <summary>
        /// Set the level of zoom.
        /// -1.0 if fully zoomed out. 1.0 is fully zoomed in.
        /// 0 is no zoom. Also resets the unzoom timer.
        /// </summary>
        /// <param name="zoomAmount"></param>
        public void SetLookZoom (float zoomAmount)
        {
            if (zoomAmount < -1f) { zoomFactor = -1f; }
            else if (zoomAmount > 1f) { zoomFactor = 1f; }
            else { zoomFactor = zoomAmount; }

            unzoomTimer = lookUnzoomDelay;
        }

        /// <summary>
        /// Shake the camera for specified seconds which the given relative strength or force.
        /// If the camera is not enabled or the duration and/or strength are 0 or less,
        /// StopCameraShake() will be automatically called and the inputs ignored.
        /// Strength should be between 0 and 1.
        /// </summary>
        /// <param name="duration"></param>
        /// <param name="strength"></param>
        public void ShakeCamera(float duration, float strength)
        {
            if (isThirdPerson && isThirdPersonValid && duration > 0f && strength > 0f)
            {
                isShaking = true;
                shakeStrength = strength * 0.1f;
                shakeTimer = duration;
            }
            else
            {
                StopCameraShake();
            }
        }

        /// <summary>
        /// Stop the camera from shaking
        /// </summary>
        public void StopCameraShake()
        {
            isShaking = false;
            shakeTimer = 0f;
        }

        /// <summary>
        /// Stop looking at an interactive-enabled object. It does not prevent the
        /// character from looking at it again.
        /// If you want to stop the character looking at interactive-enabled objects,
        /// use DisableLookInteractive() instead.
        /// </summary>
        public void StopLookAtInteractive()
        {
            // Was a previous StickyInteractive component being observed?
            if (lookingAtInteractiveId != StickyInteractive.NoID)
            {
                // These are called BEFORE onHoverExit events on the interactive object so that they don't overwrite actions on the interactive objects themselves
                if (onInteractLookAtChanged != null)
                {
                    onInteractLookAtChanged.Invoke(StickyID, lookingAtInteractiveId, StickyInteractive.NoID, nonengageColour);
                }

                // Call all onHoverExit methods (or set properties etc) and pass in the previously set StickyInteractiveID and the ID of this character.
                if (lookingAtInteractive != null && lookingAtInteractive.onHoverExit != null)
                {
                    lookingAtInteractive.onHoverExit.Invoke(lookingAtInteractiveId, StickyID);
                }

                // The character has stopped looking at a StickyInteractive so call the callback if it has been set
                if (callbackOnChangeLookAtInteractive != null)
                {
                    callbackOnChangeLookAtInteractive(this, lookingAtInteractive, null);
                }
            }

            lookingAtInteractive = null;
            lookingAtInteractiveId = StickyInteractive.NoID;
        }

        /// <summary>
        /// Stop looking at a StickySocket. It does not prevent the character from looking at it again.
        /// If you want to stop the character looking at Sockets, use DisableLookSockets() instead.
        /// </summary>
        public void StopLookAtSocket()
        {
            // Was a previous StickySocket component being observed?
            if (lookingAtSocketId != StickySocket.NoID)
            {
                if (lookingAtSocket != null)
                {
                    if (isLookSocketAutoShow) { lookingAtSocket.HideSocket(); }
                }

                // These are called BEFORE onHoverExit events on the socket so that they don't overwrite actions on the sockets themselves
                // NOT YET IMPLEMENTED
                //if (onSocketLookAtChanged != null)
                //{
                //    onSocketLookAtChanged.Invoke(StickyID, lookingAtSocketId, StickySocket.NoID, nonengageColour);
                //}

                // Call all onHoverExit methods (or set properties etc) and pass in the previously set StickySocketID and the ID of this character.
                if (lookingAtSocket != null && lookingAtSocket.onHoverExit != null)
                {
                    lookingAtSocket.onHoverExit.Invoke(lookingAtSocketId, StickyID);
                }

                // The character has stopped looking at a StickySocket so call the callback if it has been set
                // NOT YET IMPLEMENTED
                //if (callbackOnChangeLookAtSocket != null)
                //{
                //    callbackOnChangeLookAtSocket(this, lookingAtSocket, null);
                //}
            }

            lookingAtSocket = null;
            lookingAtSocketId = StickySocket.NoID;
        }

        /// <summary>
        /// Show the hardware (mouse) cursor.
        /// This also restarts the countdown auto-hide timer if that is enabled.
        /// </summary>
        public void ShowCursor()
        {
            ShowOrHideCursor(true);
        }

        /// <summary>
        /// Hide the hardware (mouse) cursor.
        /// NOTE: This will sometimes fail to turn off the cursor in the editor
        /// Game View when it doesn't have focus, but will work fine in a build.
        /// </summary>
        public void HideCursor()
        {
            ShowOrHideCursor(false);
        }

        /// <summary>
        /// Toggle the hardware (mouse) cursor on or off.
        /// NOTE: This will sometimes fail to turn off the cursor in the editor
        /// Game View when it doesn't have focus, but will work fine in a build.
        /// </summary>
        public void ToggleCursor()
        {
            ShowOrHideCursor(!Cursor.visible);
        }

        /// <summary>
        /// Centre the hardware (mouse) cursor in the centre of the screen.
        /// WARNING: This will wait until the next frame before it returns.
        /// </summary>
        public void CentreCursor()
        {
            Cursor.lockState = CursorLockMode.Locked;
            StartCoroutine(UnlockCursor());
        }

        /// <summary>
        /// If in third person, attempt to cut the camera directly to the target
        /// position and rotation.
        /// </summary>
        public void CutToThirdPersonCameraTarget()
        {
            if (isThirdPerson && isThirdPersonValid && !isNPC && !isLookVREnabled)
            {
                MoveThirdPersonCamera(false, false);
            }
        }

        /// <summary>
        /// If look movement is enabled, disable it.
        /// If look movement is disabled, attempt to enable it.
        /// </summary>
        public void ToggleEnableLookMovement()
        {
            EnableOrDisableLookMovement(!isUpdateLookMovement);
        }

        /// <summary>
        /// Toggle if the character will be able to see or detect objects with a StickyInteractive component
        /// </summary>
        public void ToggleLookInteractive()
        {
            EnableOrDisableLookInteractive(!isLookInteractiveEnabled);
        }

        /// <summary>
        /// Toggle if the character will be able to see or detect objects with a StickySocket component
        /// </summary>
        public void ToggleLookSockets()
        {
            EnableOrDisableLookSockets(!isLookSocketsEnabled);
        }

        /// <summary>
        /// Attempt to toggle between first and third person modes.
        /// When switching to first-person, it can automatically enable look movement.
        /// </summary>
        public void ToggleFirstThirdPerson()
        {
            if (isThirdPerson) { SetLookFirstPerson(lookFirstPersonCamera1, lookFirstPersonTransform1, true); }
            else { SetLookThirdPerson(lookThirdPersonCamera1, true); }
        }

        /// <summary>
        /// Toggles or inverts the third person camera Z position and cuts directly to that camera
        /// position if in Third Person mode.
        /// </summary>
        public void ToggleThirdPersonLookZ()
        {
            lookCameraOffset.z = -lookCameraOffset.z;
            GetCameraOffsetDistance();

            // If currently in Third Person mode, cut the camera directly to the new position
            if (isThirdPerson && isThirdPersonValid)
            {
                MoveThirdPersonCamera(isLookFixedUpdate, false);
            }
        }

        /// <summary>
        /// Allow the third person camera to move freely again.
        /// </summary>
        public void UnLockThirdPersonCameraPosition()
        {
            isLockCamToWorldPos = false;
        }

        /// <summary>
        /// Allow the third person camera to rotating freely again.
        /// </summary>
        public void UnLockThirdPersonCameraRotation()
        {
            isLockCamToWorldRot = false;
        }

        #endregion

        #region Public API Methods - Collide

        /// <summary>
        /// When attaching an object to the character, like when grabbing an object in VR,
        /// call this method for each non-trigger collider. This helps with collision
        /// detection on the character.
        /// When grabbing interactive-enabled objects, this is automatically called by S3D.
        /// </summary>
        /// <param name="colliderToAttach"></param>
        public void AttachCollider(Collider colliderToAttach)
        {
            if (colliderToAttach != null && !colliderToAttach.isTrigger)
            {
                attachedCollisionColliders.Add(colliderToAttach.GetInstanceID());
            }
        }

        /// <summary>
        /// When attaching objects to the character, like when grabbing an object,
        /// call this method with an array of the active non-trigger colliders.
        /// See also AttachCollider(..).
        /// </summary>
        /// <param name="collidersToAttach"></param>
        public void AttachColliders(Collider[] collidersToAttach)
        {
            int numAttachedColliders = collidersToAttach == null ? 0 : collidersToAttach.Length;

            for (int colIdx = 0; colIdx < numAttachedColliders; colIdx++)
            {
                Collider attachCollider = collidersToAttach[colIdx];
                if (attachCollider.enabled && !attachCollider.isTrigger) { AttachCollider(attachCollider); }
            }
        }

        /// <summary>
        /// When detaching or removing an object from the character, like when dropping an
        /// object in VR, call this method for each non-trigger collider. This is only required
        /// if it was first registered with AttachCollider(..).
        /// When dropping interactive-enabled objects, this is automatically called by S3D.
        /// USAGE: DetachCollider (collider.GetInstanceID())
        /// </summary>
        /// <param name="colliderID"></param>
        public void DetachCollider(int colliderID)
        {
            attachedCollisionColliders.Remove(colliderID);
        }

        /// <summary>
        /// When detaching or removing an object from the character, call this method with an array
        /// of non-trigger colliders. This is only required if they were first attached.
        /// When dropping interactive-enabled objects, this is automatically called by S3D.
        /// </summary>
        /// <param name="collidersToDetach"></param>
        public void DetachColliders(Collider[] collidersToDetach)
        {
            int numAttachedColliders = collidersToDetach == null ? 0 : collidersToDetach.Length;

            for (int colIdx = 0; colIdx < numAttachedColliders; colIdx++)
            {
                Collider attachCollider = collidersToDetach[colIdx];
                if (attachCollider != null && attachCollider.enabled) { DetachCollider(attachCollider.GetInstanceID()); }
            }
        }

        /// <summary>
        /// Is the collider part of this character and hittable by a weapon?
        /// </summary>
        /// <param name="collider"></param>
        /// <returns></returns>
        public bool IsColliderHittableByWeapon(Collider collider)
        {
            return IsColliderHittableByWeapon(collider.GetInstanceID());
        }

        /// <summary>
        /// Is the collider part of this character and hittable by a weapon?
        /// USAGE: bool isHit = IsColliderHittableByWeapon(collider.GetInstanceID());
        /// </summary>
        /// <param name="colliderInstanceID"></param>
        /// <returns></returns>
        public bool IsColliderHittableByWeapon(int colliderInstanceID)
        {
            return !weaponNonHitColliders.Contains(colliderInstanceID) && IsColliderSelf(colliderInstanceID);
        }

        /// <summary>
        /// Is the collider part of this character?
        /// Takes into consideration the capsule collider, any feet or damage region colliders, and any attached or held objects.
        /// It will NOT automatically ignore all trigger colliders associated with this character
        /// </summary>
        /// <param name="collider"></param>
        /// <returns></returns>
        public bool IsColliderSelf(Collider collider)
        {
            return IsColliderSelf(collider.GetInstanceID());
        }

        /// <summary>
        /// Is the collider part of this character?
        /// Takes into consideration the capsule collider, any feet or damage region colliders, any attached or held objects.
        /// It will NOT automatically ignore all trigger colliders associated with this character.
        /// USAGE: bool isSelf = IsColliderSelf(collider.GetInstanceID());
        /// </summary>
        /// <param name="colliderInstanceID"></param>
        /// <returns></returns>
        public bool IsColliderSelf(int colliderInstanceID)
        {
            return colliderInstanceID == capsuleColliderId || colliderInstanceID == leftFootColliderId || colliderInstanceID == rightFootColliderId || attachedCollisionColliders.Contains(colliderInstanceID) || damageRegionColliders.Contains(colliderInstanceID);
        }

        /// <summary>
        /// Fire a ray from the lookFrom position in the lookDirection (which should be normalised) the
        /// distance specified. Will return true if the character was hit and the passed in raycastHit
        /// structure will be populated with the hit information.
        /// The optional objectLayerMask enables you to only detect objects in certain Unity Layers.
        /// Trigger Collider MUST BE enabled on the Collider tab for this to work.
        /// </summary>
        /// <param name="lookFrom"></param>
        /// <param name="lookDirection"></param>
        /// <param name="distance"></param>
        /// <param name="raycastHit"></param>
        /// <param name="debugInSceneView">Has no effect in a build</param>
        /// <param name="objectLayerMask">Defaults to all layers</param>
        /// <returns></returns>
        public bool IsHit(Vector3 lookFrom, Vector3 lookDirection, float distance, ref RaycastHit raycastHit, bool debugInSceneView = false, int objectLayerMask = ~0)
        {
            bool _isHit = false;

            // Temp reusable hit array
            if (raycastHitInfoArray == null) { raycastHitInfoArray = new RaycastHit[20]; }

            Ray ray = new Ray(lookFrom, lookDirection);

#if UNITY_EDITOR
            if (debugInSceneView) { Debug.DrawRay(lookFrom, lookDirection.normalized * distance, Color.blue); }
#endif

            // Get all hits between lookFrom position and the distance away in the lookDirection given. Include triggers.
            // NOTE: RaycastNonAlloc, like other 3D multi-hit physics items, returns an UNSORTED array.
            int numHits = Physics.RaycastNonAlloc(ray, raycastHitInfoArray, distance, objectLayerMask, QueryTriggerInteraction.Collide);

            for (int hitIdx = 0; hitIdx < numHits; hitIdx++)
            {
                RaycastHit hitInfo = raycastHitInfoArray[hitIdx];
                Collider collider = hitInfo.collider;

                if (collider.GetInstanceID() == capsuleColliderId)
                {
                    _isHit = true;
                    raycastHit = hitInfo;
                    break;
                }
                else if (collider.transform.IsChildOf(transform))
                {
                    _isHit = true;
                    raycastHit = hitInfo;
                    break;
                }
            }

            return _isHit;
        }

        /// <summary>
        /// Fire a ray from the camera to the screen coordinates, for a maximum of distance metres.
        /// If look is disabled, like with an NPC, the eye position is used instead.
        /// The optional objectLayerMask enables you to only detect objects in certain Unity Layers.
        /// To detect other S3D characters, they MUST have Trigger Collider enabled on the Collide tab.
        /// If includeTriggers is false, we will still detect S3D characters if the above is true but
        /// will disregard all other trigger colliders.
        /// </summary>
        /// <param name="distance"></param>
        /// <param name="screenCoordinates"></param>
        /// <param name="raycastHit"></param>
        /// <param name="debugInSceneView">When true: show a red ray when something is hit, otherwise show a blue ray</param>
        /// <param name="objectLayerMask"></param>
        /// <param name="includeTriggers"></param>
        /// <returns></returns>
        public bool IsHitLookOther(float distance, Vector2 screenCoordinates, ref RaycastHit raycastHit, bool debugInSceneView = false, int objectLayerMask = ~0, bool includeTriggers = true)
        {
            bool _isHit = false;
            float minDistance = distance + 1f;
            int closestHitIdx = -1;

            Vector3 lookFrom = isLookEnabled ? (isThirdPerson ? currentCameraPosWS : lookTransform.position) : GetWorldEyePosition();
            Vector3 lookDirection = isLookEnabled ? (isThirdPerson ? currentCameraRotWS : lookTransform.rotation) * Vector3.forward : currentCharacterFwd;

            // Temp re-useable hit array.
            if (raycastHitInfoArray == null) { raycastHitInfoArray = new RaycastHit[20]; }

            // the Vector3.z is automatically set to 0 when the vector2 is implicitly converted to a vector3.
            Ray ray = isLookEnabled ? lookCamera1.ScreenPointToRay(screenCoordinates) : new Ray(lookFrom, lookDirection);
            //Ray ray = isLookEnabled ? lookCamera1.ViewportPointToRay(MouseViewportPoint()) : new Ray(lookFrom, lookDirection);

            // Get all hits between lookFrom position and the distance away in the lookDirection given. Include triggers.
            // Always include trigger colliders so that we can detect other Sticky characters.
            // NOTE: RaycastNonAlloc, like other 3D multi-hit physics items, returns an UNSORTED array.
            int numHits = Physics.RaycastNonAlloc(ray, raycastHitInfoArray, distance, objectLayerMask, QueryTriggerInteraction.Collide);

            for (int hitIdx = 0; hitIdx < numHits; hitIdx++)
            {
                RaycastHit hitInfo = raycastHitInfoArray[hitIdx];
                Collider collider = hitInfo.collider;

                // Ignore colliders associated with this character
                if (collider.GetInstanceID() == capsuleColliderId || collider.transform.IsChildOf(transform))
                {
                    continue;
                }
                // Check to see if there is a S3D script attached to a trigger collider
                // This requires that "Trigger Collider" is enabled on the Collide tab
                // of the other S3D character.
                // It will also return true if includeTriggers is true.
                else if (collider.isTrigger)
                {
                    if (includeTriggers || collider.GetComponent<StickyControlModule>())
                    {
                        _isHit = true;
                        if (hitInfo.distance < minDistance)
                        {
                            minDistance = hitInfo.distance;
                            closestHitIdx = hitIdx;
                        }
                    }
                }
                else
                {
                    // We hit a "regular" object with a collider
                    _isHit = true;
                    if (hitInfo.distance < minDistance)
                    {
                        minDistance = hitInfo.distance;
                        closestHitIdx = hitIdx;
                    }
                }
            }

            // Return info on the closest object
            if (_isHit && closestHitIdx >= 0)
            {
                raycastHit = raycastHitInfoArray[closestHitIdx];

#if UNITY_EDITOR
                if (debugInSceneView) { Debug.DrawRay(ray.origin, ray.direction.normalized * raycastHit.distance, Color.red); }
#endif
            }
#if UNITY_EDITOR
            else if (debugInSceneView) { Debug.DrawRay(ray.origin, ray.direction.normalized * distance, Color.blue); }
#endif

            return _isHit;
        }

        /// <summary>
        /// Fire a ray from a position (lookFrom) typically from some point on this character, in a lookDirection, a maximum of distance metres.
        /// The optional objectLayerMask enables you to only detect objects in certain Unity Layers.
        /// To detect other S3D characters, they MUST have Trigger Collider enabled on the Collide tab.
        /// </summary>
        /// <param name="lookFrom"></param>
        /// <param name="lookDirection"></param>
        /// <param name="distance"></param>
        /// <param name="raycastHit"></param>
        /// <param name="debugInSceneView">When true: show a red ray when something is hit, otherwise show a blue ray</param>
        /// <param name="objectLayerMask"></param>
        /// <returns></returns>
        public bool IsHitOther(Vector3 lookFrom, Vector3 lookDirection, float distance, ref RaycastHit raycastHit, bool debugInSceneView = false, int objectLayerMask = ~0)
        {
            bool _isHit = false;
            float minDistance = distance + 1f;
            int closestHitIdx = -1;

            // Temp re-useable hit array.
            if (raycastHitInfoArray == null) { raycastHitInfoArray = new RaycastHit[20]; }

            Ray ray = new Ray(lookFrom, lookDirection);

            // Get all hits between lookFrom position and the distance away in the lookDirection given. Include triggers.
            // NOTE: RaycastNonAlloc, like other 3D multi-hit physics item, returns an UNSORTED array.
            int numHits = Physics.RaycastNonAlloc(ray, raycastHitInfoArray, distance, objectLayerMask, QueryTriggerInteraction.Collide);

            for (int hitIdx = 0; hitIdx < numHits; hitIdx++)
            {
                RaycastHit hitInfo = raycastHitInfoArray[hitIdx];
                Collider collider = hitInfo.collider;

                // Ignore colliders associated with this character
                if (collider.GetInstanceID() == capsuleColliderId || collider.transform.IsChildOf(transform))
                {
                    continue;
                }
                // Check to see if there is a S3D script attached to a trigger collider
                // This requires that "Trigger Collider" is enabled on the Collide tab
                // of the other S3D character.
                else if (collider.isTrigger)
                {
                    if (collider.GetComponent<StickyControlModule>())
                    {
                        _isHit = true;
                        if (hitInfo.distance < minDistance)
                        {
                            minDistance = hitInfo.distance;
                            closestHitIdx = hitIdx;
                        }
                    }
                }
                else
                {
                    // We hit a "regular" object with a collider
                    _isHit = true;
                    if (hitInfo.distance < minDistance)
                    {
                        minDistance = hitInfo.distance;
                        closestHitIdx = hitIdx;
                    }
                }
            }

            // Return info on the closest object
            if (_isHit && closestHitIdx >= 0)
            {
                raycastHit = raycastHitInfoArray[closestHitIdx];

#if UNITY_EDITOR
                if (debugInSceneView) { Debug.DrawRay(lookFrom, lookDirection.normalized * raycastHit.distance, Color.red); }
#endif
            }
#if UNITY_EDITOR
            else if (debugInSceneView) { Debug.DrawRay(lookFrom, lookDirection.normalized * distance, Color.blue); }
#endif

            return _isHit;
        }

        /// <summary>
        /// Is there an object preventing the character moving into the position indicated?
        /// NOTE: Currently does not check for S3D characters.
        /// </summary>
        /// <param name="feetPosition"></param>
        /// <param name="characterUpDirection"></param>
        /// <returns></returns>
        public bool IsObstacle(Vector3 feetPosition, Vector3 characterUpDirection)
        {
            return CheckCapsule(feetPosition, characterUpDirection, currentScaledHeight);
        }

        /// <summary>
        /// Is there an obstacle in the given direction from the character? The obstacle could be a
        /// collider that is in the collisionLayerMask or another S3D character that has "Trigger Collider"
        /// enabled on the Collide tab.
        /// </summary>
        /// <param name="offsetBottomY"></param>
        /// <param name="offsetTopY"></param>
        /// <param name="direction"></param>
        /// <param name="distance"></param>
        /// <returns></returns>
        public bool IsObstacle(float offsetBottomY, float offsetTopY, Vector3 direction, float distance)
        {
            bool isObstacle = false;

            Vector3 _bottom = GetBottom(currentWorldPosition, currentCharacterUp, true, offsetBottomY);
            Vector3 _top = GetTop(currentWorldPosition, currentCharacterUp, true, offsetTopY);

            // Temp re-useable hit array.
            if (raycastHitInfoArray == null) { raycastHitInfoArray = new RaycastHit[20]; }

            // Physics.CapsuleCastNonAlloc will raise an error if IsNormalized(direction) fails.
            if (direction.sqrMagnitude < Mathf.Epsilon)
            {
#if UNITY_EDITOR
                Debug.LogWarning("[ERROR] stickyControlModule.IsObstacle - direction " + direction + " could not be normalised. Converting to character forward on " + name);
#endif
                direction = GetCurrentForward;
            }

            int numHits = Physics.CapsuleCastNonAlloc(_bottom, _top, radius, direction, raycastHitInfoArray, distance, collisionLayerMask, QueryTriggerInteraction.Collide);

            for (int hitIdx = 0; hitIdx < numHits; hitIdx++)
            {
                RaycastHit hitInfo = raycastHitInfoArray[hitIdx];
                Collider collider = hitInfo.collider;

                // Ignore colliders associated with this character
                if (collider.GetInstanceID() == capsuleColliderId || collider.transform.IsChildOf(transform))
                {
                    continue;
                }
                // Check to see if there is a S3D script attached to a trigger collider
                // This requires that "Trigger Collider" is enabled on the Collide tab
                // of the other S3D character.
                else if (collider.isTrigger)
                {
                    // Is there another S3D character in the way?
                    if (collider.GetComponent<StickyControlModule>())
                    {
                        isObstacle = true;
                        break;
                    }
                }
                else
                {
                    // We hit a "regular" object with a collider
                    //Debug.Log("[DEBUG] Obstacle is " + collider.name);
                    isObstacle = true;
                    break;
                }
            }

            return isObstacle;
        }

        /// <summary>
        /// Register this (child) collider as one weapons will ignore when firing
        /// at with beams, projectiles etc.
        /// Currently only works with trigger colliders due to StickyManager hit optimisations.
        /// </summary>
        /// <param name="collider"></param>
        public void RegisterWeaponNonHitCollider(Collider collider)
        {
            if (collider != null && collider.transform.IsChildOf(transform))
            {
                weaponNonHitColliders.Add(collider.GetInstanceID());
            }
#if UNITY_EDITOR
            else { Debug.LogWarning("ERROR RegisterWeaponNonHitCollider the (" + (collider == null ? "null" : collider.name) + " collider is not a child of " + name); }
#endif
        }

        /// <summary>
        /// Call this before you destroy a collider that the character may be near or inside, or
        /// when you no longer wish to receive Stay or Exit events for.
        /// NOTE: When the character next enters the trigger collider, new events may be created.
        /// </summary>
        /// <param name="collider"></param>
        public void RemoveCollider(Collider collider)
        {
            if (isInitialised) { inTriggerColliders.Remove(collider); }
        }

        /// <summary>
        /// Clear the list of colliders that weapons cannot fire at and hit on this character.
        /// </summary>
        public void ResetWeaponNonHitColliders()
        {
            weaponNonHitColliders.Clear();
        }

        /// <summary>
        /// Reset the reference frame mask to their default values
        /// </summary>
        public void ResetReferenceFrameLayerMask()
        {
            // Everything, except TransparentFX (1), IgnoreRaycast (2),  UI (5)
            referenceFrameLayerMask = ~((1 << 1) | (1 << 2) | (1 << 5));
        }

        /// <summary>
        /// Attempt to restore the current reference frame, to the initial or default setting.
        /// This is automatically called when exiting a StickyZone.
        /// </summary>
        public void RestoreDefaultReferenceFrame()
        {
            SetCurrentReferenceFrame(initialReferenceFrame);
        }

        /// <summary>
        /// Attempt to restore the previous reference frame that was being used before what is
        /// currently set. NOTE: We do not support nesting.
        /// </summary>
        public void RestorePreviousReferenceFrame()
        {
            SetCurrentReferenceFrame(previousReferenceFrame);
        }

        /// <summary>
        /// Attempt to restore the character to full height.
        /// See also ScaleToKneeHeight().
        /// </summary>
        public void RestoreFullHeight()
        {
            if (ChangeHeight(height))
            {
                capsuleCollider.height = height;
                capsuleCollider.center = new Vector3(0f, pivotToCentreOffsetY, 0f);
            }
            else
            {
                // If cannot restore normal height, consider that they
                // where previously crouching. This will allow the character
                // to resume normal height when there is sufficent space to do so.
                prevCrouching = true;
            }

            isTemporaryHeight = false;
        }

        /// <summary>
        /// Attempt to scale the character to knee height, so that when sitting,
        /// they can have the main capsule collider fit under a table, or bench.
        /// See also RestoreFullHeight().
        /// </summary>
        /// <returns></returns>
        public bool ScaleToKneeHeight()
        {
            Vector3 _offset = Vector3.zero;

            if (GetBoneBottomOffset(HumanBodyBones.RightLowerLeg, ref _offset))
            {
                if(ChangeHeight(_offset.y))
                {
                    isTemporaryHeight = true;

                    capsuleCollider.height = currentScaledHeight;
                    capsuleCollider.center = new Vector3(0f, currentScaledHeight/height * pivotToCentreOffsetY, 0f);
                }

                return isTemporaryHeight;
            }
            else { return false; }
        }

        /// <summary>
        /// Attempt to scale the character to a temporary height, so that when sitting,
        /// they can have the main capsule collider fit under a table, or bench etc.
        /// See also RestoreFullHeight().
        /// </summary>
        /// <param name="tempHeight"></param>
        /// <returns></returns>
        public bool ScaleToTemporaryHeight (float tempHeight)
        {
            // Only accept sensible heights
            if (tempHeight > 0.1f && tempHeight < 10f)
            {
                if (ChangeHeight(tempHeight))
                {
                    isTemporaryHeight = true;

                    capsuleCollider.height = currentScaledHeight;
                    capsuleCollider.center = new Vector3(0f, currentScaledHeight / height * pivotToCentreOffsetY, 0f);
                }

                return isTemporaryHeight;
            }
            else { return false; }
        }

        /// <summary>
        /// Sets the current reference frame based on a collider. This will take into consideration
        /// isUseRBodyReferenceFrame.
        /// </summary>
        /// <param name="hitCollider"></param>
        public void SetCurrentReferenceFrame (Collider hitCollider)
        {
            Rigidbody rb = hitCollider.attachedRigidbody;
            if (isUseRBodyReferenceFrame && rb != null)
            {
                //Debug.Log("[DEBUG] coll: " + hitCollider.name + " rb: " + rb.name + " for " + name + " T:" + Time.time);
                SetCurrentReferenceFrame(rb.transform);
            }
            else
            {
                SetCurrentReferenceFrame(hitCollider.transform);
            }
        }

        /// <summary>
        /// Sets the current reference frame.
        /// </summary>
        /// <param name="newReferenceFrame"></param>
        public void SetCurrentReferenceFrame (Transform newReferenceFrame)
        {
            if (newReferenceFrame != null)
            {
                // Only update if the reference frame has changed
                if (currentReferenceFrameId != newReferenceFrame.GetHashCode())
                {
                    //if (currentReferenceFrame != null) { Debug.Log("[DEBUG] currentRF: " + currentReferenceFrame.name + " new: " + newReferenceFrame.name + " T:" + Time.time); }

                    previousReferenceFrame = currentReferenceFrame;

                    // Calculate the new relative position and rotation
                    // TODO optimise this code
                    // The INTENT is to maintain the same forward direction of the character
                    // as they cross reference frame boundaries. These reference object may
                    // appear on be on a similar plane but be rotated say 90, 180 or 270 deg.
                    // We also, if possible want the character up direction to match the normal
                    // or new reference object.

                    // NOTE: CURRENTLY DOESN'T WORK WTIH SCALED MESHES
                    currentRelativePosition = newReferenceFrame.InverseTransformPoint(transform.position);

                    // Project the relative rotation into the new reference frame
                    currentRelativeRotation = Quaternion.Inverse(newReferenceFrame.rotation) * transform.rotation;

                    // Update relative velocity and angular velocity
                    currentRelativeVelocity = Quaternion.Inverse(newReferenceFrame.rotation) * (currentReferenceFrameRotation * currentRelativeVelocity);
                    currentRelativeAngularVelocity = Quaternion.Inverse(newReferenceFrame.rotation) * (currentReferenceFrameRotation * currentRelativeAngularVelocity);
                    // Remove any x/z components of the relative angular velocity
                    currentRelativeAngularVelocity.x = 0f;
                    currentRelativeAngularVelocity.z = 0f;

                    // Set the current reference frame transform
                    currentReferenceFrame = newReferenceFrame;

                    // Update reference frame data
                    currentReferenceFramePosition = currentReferenceFrame.position;
                    currentReferenceFrameRotation = currentReferenceFrame.rotation;
                    currentReferenceFrameUp = currentReferenceFrame.up;

                    // GetHashCode seems to return same value as GetInstanceID()
                    // GetHashCode is faster than GetInstanceID() when doing comparisons.
                    currentReferenceFrameId = currentReferenceFrame.GetHashCode();

                    if (isLockCamToWorldPos)
                    {
                        // NOTE: This "should" work if LockCamToWorldPos is enabled and the
                        // reference frame is changed in first person or look is disabled.
                        // But those scenarios have yet to be tested....
                        currentCameraRefFrameOffset = Quaternion.Inverse(currentReferenceFrameRotation) * (currentCameraPosWS - currentReferenceFramePosition);

                        GetCameraOffsetDistance();
                    }

                    if (isLockCamToWorldRot)
                    {
                        // NOTE: This "should" work but hasn't been tested
                        // Get the new rotation of the camera, relative to the new reference frame.
                        currentCameraRefFrameRot = Quaternion.Inverse(currentReferenceFrameRotation) * currentCameraRotWS;
                    }
                }
            }
            else
            {
                // Calculate the new relative position and rotation
                currentRelativePosition = Vector3.zero;
                currentRelativeRotation = Quaternion.identity;

                // Currently we do not have a reference frame assigned
                currentReferenceFrame = null;

                // Update reference frame data
                currentReferenceFramePosition = Vector3.zero;
                currentReferenceFrameRotation = Quaternion.identity;
                currentReferenceFrameUp = Vector3.up;

                currentReferenceFrameId = 0;
            }
        }

        /// <summary>
        /// Sets the current reference frame with the option to forcefully update it.
        /// </summary>
        /// <param name="newReferenceFrame"></param>
        /// <param name="isForceUpdate"></param>
        public void SetCurrentReferenceFrame (Transform newReferenceFrame, bool isForceUpdate)
        {
            if (isForceUpdate) { currentReferenceFrameId = 0; }
            SetCurrentReferenceFrame(newReferenceFrame);
        }

        /// <summary>
        /// Change the way reference frames are determined.
        /// </summary>
        /// <param name="newRefUpdateType"></param>
        public void SetReferenceUpdateType(ReferenceUpdateType newRefUpdateType)
        {
            referenceUpdateType = newRefUpdateType;
            refUpdateTypeInt = (int)newRefUpdateType;
        }

        /// <summary>
        /// Unregister this (child) collider as one weapons will ignore when firing
        /// at with beams, projectiles etc. The collider will now be one hittable
        /// by weapons.
        /// </summary>
        /// <param name="collider"></param>
        public void UnregisterWeaponNonHitCollider(Collider collider)
        {
            if (collider != null && collider.transform.IsChildOf(transform))
            {
                weaponNonHitColliders.Remove(collider.GetInstanceID());
            }
#if UNITY_EDITOR
            else { Debug.LogWarning("ERROR UnregisterWeaponNonHitCollider the (" + (collider == null ? "null" : collider.name) + " collider is not a child of " + name); }
#endif
        }

        #endregion

        #region Public API Methods - Jet Pack

        /// <summary>
        /// Prevent the Jet Pack from being enabled
        /// </summary>
        public void DisableJetPackAvailability()
        {
            EnableOrDisableJetPackAvailability(false);
        }

        /// <summary>
        /// Allow the Jet Pack to be enabled.
        /// </summary>
        public void EnableJetPackAvailability()
        {
            EnableOrDisableJetPackAvailability(true);
        }

        /// <summary>
        /// Call this if changing the Jet Pack audio source or thruster effects.
        /// Correct order:
        /// 1. RestoreJetPackInitialSettings()
        /// 2. Make changes
        /// 3. ResetJetPackSettings()
        /// </summary>
        public void ResetJetPackSettings()
        {
            if (jetPackAudio != null)
            {
                // Ensure looping is enabled on the jet pack audio source
                jetPackAudio.loop = true;
            }

            // Reset jetpack ramp up/down varibles
            // jetpack left/right movement
            if (jetPackRampInputX == null) { jetPackRampInputX = new S3DRamp(); }
            else { jetPackRampInputX.Reset(); }

            jetPackRampInputX.rampUpDuration = jetPackRampUpDuration;
            jetPackRampInputX.rampDownDuration = jetPackRampDownDuration;

            // jetpack up/down movement 
            if (jetPackRampInputY == null) { jetPackRampInputY = new S3DRamp(); }
            else { jetPackRampInputY.Reset(); }

            jetPackRampInputY.rampUpDuration = jetPackRampUpDuration;
            jetPackRampInputY.rampDownDuration = jetPackRampDownDuration;

            // jetpack forward/backward movement
            if (jetPackRampInputZ == null) { jetPackRampInputZ = new S3DRamp(); }
            else { jetPackRampInputZ.Reset(); }

            jetPackRampInputZ.rampUpDuration = jetPackRampUpDuration;
            jetPackRampInputZ.rampDownDuration = jetPackRampDownDuration;

            // Do we need to create any S3DEffects?
            if (jetPackThrusterFwd != null && jetPackEffectsFwd == null) { jetPackEffectsFwd = new S3DEffects(); }
            if (jetPackThrusterBack != null && jetPackEffectsBack == null) { jetPackEffectsBack = new S3DEffects(); }
            if (jetPackThrusterUp != null && jetPackEffectsUp == null) { jetPackEffectsUp = new S3DEffects(); }
            if (jetPackThrusterDown != null && jetPackEffectsDown == null) { jetPackEffectsDown = new S3DEffects(); }
            if (jetPackThrusterRight != null && jetPackEffectsRight == null) { jetPackEffectsRight = new S3DEffects(); }
            if (jetPackThrusterLeft != null && jetPackEffectsLeft == null) { jetPackEffectsLeft = new S3DEffects(); }

            ResetJetPackThruster(jetPackThrusterFwd, jetPackEffectsFwd);
            ResetJetPackThruster(jetPackThrusterBack, jetPackEffectsBack);
            ResetJetPackThruster(jetPackThrusterUp, jetPackEffectsUp);
            ResetJetPackThruster(jetPackThrusterDown, jetPackEffectsDown);
            ResetJetPackThruster(jetPackThrusterRight, jetPackEffectsRight);
            ResetJetPackThruster(jetPackThrusterLeft, jetPackEffectsLeft);
        }

        /// <summary>
        /// Call before making changes to audio source and/or jet pack thrusters.
        /// Correct order:
        /// 1. RestoreJetPackInitialSettings()
        /// 2. Make changes
        /// 3. ResetJetPackSettings()
        /// </summary>
        public void RestoreJetPackInitialSettings()
        {
            if (!isInitialised) { return; }

            if (jetPackAudio != null)
            {
                jetPackAudio.volume = jetPackMaxVolume;
            }

            if (jetPackThrusterFwd != null)
            {
                if (jetPackEffectsFwd == null) { jetPackEffectsFwd = new S3DEffects(); }
                else { jetPackEffectsFwd.RestoreInitialValues(); }
            }
            else { jetPackEffectsFwd = null; }

            if (jetPackThrusterBack != null)
            {
                if (jetPackEffectsBack == null) { jetPackEffectsBack = new S3DEffects(); }
                else { jetPackEffectsBack.RestoreInitialValues(); }
            }
            else { jetPackEffectsBack = null; }

            if (jetPackThrusterUp != null)
            {
                if (jetPackEffectsUp == null) { jetPackEffectsUp = new S3DEffects(); }
                else { jetPackEffectsUp.RestoreInitialValues(); }
            }
            else { jetPackEffectsUp = null; }

            if (jetPackThrusterDown != null)
            {
                if (jetPackEffectsDown == null) { jetPackEffectsDown = new S3DEffects(); }
                else { jetPackEffectsDown.RestoreInitialValues(); }
            }
            else { jetPackEffectsDown = null; }

            if (jetPackThrusterRight != null)
            {
                if (jetPackEffectsRight == null) { jetPackEffectsRight = new S3DEffects(); }
                else { jetPackEffectsRight.RestoreInitialValues(); }
            }
            else { jetPackEffectsRight = null; }

            if (jetPackThrusterLeft != null)
            {
                if (jetPackEffectsLeft == null) { jetPackEffectsLeft = new S3DEffects(); }
                else { jetPackEffectsLeft.RestoreInitialValues(); }
            }
            else { jetPackEffectsLeft = null; }
        }

        /// <summary>
        /// Attempt to toggle if the jet pack can be used or not
        /// </summary>
        public void ToggleIsJetPackAvailable()
        {
            EnableOrDisableJetPackAvailability(!isJetPackAvailable);
        }

        #endregion

        #region Public API Methods - Animate (General)

        /// <summary>
        /// Blend in an Animator layer over time using the Layer Weight.
        /// See also SetAnimLayerBlendInDuration(..).
        /// </summary>
        /// <param name="layerIndex">Range 0 to layerCount</param>
        public void BlendInAnimLayer (int layerIndex)
        {
            if (isAnimateEnabled && layerIndex >= 0 && layerIndex < numAnimLayers)
            {
                animlayerDataList[layerIndex].blendWeight = 0f;
                animlayerDataList[layerIndex].isBlendingIn = true;
                animlayerDataList[layerIndex].isBlendingOut = false;
            }
        }

        /// <summary>
        /// Blend out an Animator layer over time using the Layer Weight.
        /// See also SetAnimLayerBlendOutDuration(..).
        /// </summary>
        /// <param name="layerIndex">Range 0 to layerCount</param>
        public void BlendOutAnimLayer (int layerIndex)
        {
            if (isAnimateEnabled && layerIndex >= 0 && layerIndex < numAnimLayers)
            {
                animlayerDataList[layerIndex].blendWeight = 1f;
                animlayerDataList[layerIndex].isBlendingIn = false;
                animlayerDataList[layerIndex].isBlendingOut = true;
            }
        }

        /// <summary>
        /// Check to see if all the conditions (if any) are satisfied for an animate action.
        /// Returns true if all conditions are satisfied, else returns false.
        /// </summary>
        /// <param name="s3dAnimAction"></param>
        /// <returns></returns>
        public bool CheckAnimateConditions (S3DAnimAction s3dAnimAction)
        {
            if (s3dAnimAction == null || s3dAnimAction.paramHashCode == 0) { return false; }
            else if (s3dAnimAction.numConditions < 1) { return true; }
            else
            {
                bool areAllConditionsTrue = true;

                // If any conditions are not true, exit out
                for (int acIdx = 0; areAllConditionsTrue && acIdx < s3dAnimAction.numConditions; acIdx++)
                {
                    S3DAnimCondition s3dAnimCondition = s3dAnimAction.s3dAnimConditionList[acIdx];
                    if (s3dAnimCondition != null)
                    {
                        int conditionTypeInt = (int)s3dAnimCondition.conditionType;

                        switch (s3dAnimCondition.actionCondition)
                        {
                            case S3DAnimCondition.ActionCondition.IsGrounded:
                                areAllConditionsTrue = conditionTypeInt == S3DAnimCondition.ConditionTypeAndInt ? isGrounded : !isGrounded;
                                break;
                            case S3DAnimCondition.ActionCondition.IsStepping:
                                areAllConditionsTrue = conditionTypeInt == S3DAnimCondition.ConditionTypeAndInt ? isStepping : !isStepping;
                                break;
                            case S3DAnimCondition.ActionCondition.IsCrouching:
                                areAllConditionsTrue = conditionTypeInt == S3DAnimCondition.ConditionTypeAndInt ? IsCrouching : !IsCrouching;
                                break;
                            case S3DAnimCondition.ActionCondition.IsIdle:
                                areAllConditionsTrue = conditionTypeInt == S3DAnimCondition.ConditionTypeAndInt ? IsIdle : !IsIdle;
                                break;
                            case S3DAnimCondition.ActionCondition.IsJetPacking:
                                areAllConditionsTrue = conditionTypeInt == S3DAnimCondition.ConditionTypeAndInt ? isJetPackEnabled && isJetPackAvailable : !isJetPackAvailable || !isJetPackEnabled;
                                break;
                            case S3DAnimCondition.ActionCondition.IsWalking:
                                areAllConditionsTrue = conditionTypeInt == S3DAnimCondition.ConditionTypeAndInt ? IsWalking : !IsWalking;
                                break;
                            case S3DAnimCondition.ActionCondition.IsWalkingForward:
                                areAllConditionsTrue = conditionTypeInt == S3DAnimCondition.ConditionTypeAndInt ? IsWalkingForward : !IsWalkingForward;
                                break;
                            case S3DAnimCondition.ActionCondition.IsWalkingBackward:
                                areAllConditionsTrue = conditionTypeInt == S3DAnimCondition.ConditionTypeAndInt ? IsWalkingBackward : !IsWalkingBackward;
                                break;
                            case S3DAnimCondition.ActionCondition.IsWalkingOrStrafing:
                                areAllConditionsTrue = conditionTypeInt == S3DAnimCondition.ConditionTypeAndInt ? IsWalkingOrStrafing : !IsWalkingOrStrafing;
                                break;
                            case S3DAnimCondition.ActionCondition.IsWalkingOrSprinting:
                                areAllConditionsTrue = conditionTypeInt == S3DAnimCondition.ConditionTypeAndInt ? IsWalkingOrSprinting : !IsWalkingOrSprinting;
                                break;
                            case S3DAnimCondition.ActionCondition.IsStrafing:
                                areAllConditionsTrue = conditionTypeInt == S3DAnimCondition.ConditionTypeAndInt ? IsStrafing : !IsStrafing;
                                break;
                            case S3DAnimCondition.ActionCondition.IsStrafingRight:
                                areAllConditionsTrue = conditionTypeInt == S3DAnimCondition.ConditionTypeAndInt ? IsStrafingRight : !IsStrafingRight;
                                break;
                            case S3DAnimCondition.ActionCondition.IsStrafingLeft:
                                areAllConditionsTrue = conditionTypeInt == S3DAnimCondition.ConditionTypeAndInt ? IsStrafingLeft : !IsStrafingLeft;
                                break;
                            case S3DAnimCondition.ActionCondition.IsSprinting:
                                areAllConditionsTrue = conditionTypeInt == S3DAnimCondition.ConditionTypeAndInt ? IsSprinting : !IsSprinting;
                                break;
                            case S3DAnimCondition.ActionCondition.HasLanded:
                                areAllConditionsTrue = conditionTypeInt == S3DAnimCondition.ConditionTypeAndInt ? isLanding : !isLanding;
                                break;
                            case S3DAnimCondition.ActionCondition.HasJumped:
                                areAllConditionsTrue = conditionTypeInt == S3DAnimCondition.ConditionTypeAndInt ? isJumpStartedThisFrame : !isJumpStartedThisFrame;
                                break;
                            case S3DAnimCondition.ActionCondition.IsClimbing:
                                areAllConditionsTrue = conditionTypeInt == S3DAnimCondition.ConditionTypeAndInt ? IsClimbing : !IsClimbing;
                                break;
                            case S3DAnimCondition.ActionCondition.IsClimbingAtTop:
                                areAllConditionsTrue = conditionTypeInt == S3DAnimCondition.ConditionTypeAndInt ? IsClimbingAtTop : !IsClimbingAtTop;
                                break;
                            case S3DAnimCondition.ActionCondition.IsSprintInput:
                                areAllConditionsTrue = conditionTypeInt == S3DAnimCondition.ConditionTypeAndInt ? IsSprintInput : !IsSprintInput;
                                break;
                            case S3DAnimCondition.ActionCondition.IsStrafeInput:
                                areAllConditionsTrue = conditionTypeInt == S3DAnimCondition.ConditionTypeAndInt ? IsStrafeInput : !IsStrafeInput;
                                break;
                            case S3DAnimCondition.ActionCondition.IsWalkInput:
                                areAllConditionsTrue = conditionTypeInt == S3DAnimCondition.ConditionTypeAndInt ? IsWalkInput : !IsWalkInput;
                                break;
                            case S3DAnimCondition.ActionCondition.IsLookLeftInput:
                                areAllConditionsTrue = conditionTypeInt == S3DAnimCondition.ConditionTypeAndInt ? IsLookLeftInput : !IsLookLeftInput;
                                break;
                            case S3DAnimCondition.ActionCondition.IsLookRightInput:
                                areAllConditionsTrue = conditionTypeInt == S3DAnimCondition.ConditionTypeAndInt ? IsLookRightInput : !IsLookRightInput;
                                break;
                            case S3DAnimCondition.ActionCondition.IsLookDownInput:
                                areAllConditionsTrue = conditionTypeInt == S3DAnimCondition.ConditionTypeAndInt ? IsLookDownInput : !IsLookDownInput;
                                break;
                            case S3DAnimCondition.ActionCondition.IsLookUpInput:
                                areAllConditionsTrue = conditionTypeInt == S3DAnimCondition.ConditionTypeAndInt ? IsLookUpInput : !IsLookUpInput;
                                break;
                            case S3DAnimCondition.ActionCondition.IsLookWhileIdle:
                                areAllConditionsTrue = conditionTypeInt == S3DAnimCondition.ConditionTypeAndInt ? IsLookWhileIdle : !IsLookWhileIdle;
                                break;
                            case S3DAnimCondition.ActionCondition.IsLookLeftOrRightWhileIdle:
                                areAllConditionsTrue = conditionTypeInt == S3DAnimCondition.ConditionTypeAndInt ? IsLookLeftOrRightWhileIdle : !IsLookLeftOrRightWhileIdle;
                                break;
                            case S3DAnimCondition.ActionCondition.IsLookUpOrDownWhileIdle:
                                areAllConditionsTrue = conditionTypeInt == S3DAnimCondition.ConditionTypeAndInt ? IsLookUpOrDownWhileIdle : !IsLookUpOrDownWhileIdle;
                                break;
                            case S3DAnimCondition.ActionCondition.IsWeaponInAnyHand:
                                areAllConditionsTrue = conditionTypeInt == S3DAnimCondition.ConditionTypeAndInt ? isLeftHandHoldingWeapon || isRightHandHoldingWeapon : !isLeftHandHoldingWeapon && !isRightHandHoldingWeapon;
                                break;
                            case S3DAnimCondition.ActionCondition.IsWeaponInLeftHand:
                                areAllConditionsTrue = conditionTypeInt == S3DAnimCondition.ConditionTypeAndInt ? isLeftHandHoldingWeapon : !isLeftHandHoldingWeapon;
                                break;
                            case S3DAnimCondition.ActionCondition.IsWeaponInRightHand:
                                areAllConditionsTrue = conditionTypeInt == S3DAnimCondition.ConditionTypeAndInt ? isRightHandHoldingWeapon : !isRightHandHoldingWeapon;
                                break;
                            case S3DAnimCondition.ActionCondition.IsMagazineInLeftHand:
                                areAllConditionsTrue = conditionTypeInt == S3DAnimCondition.ConditionTypeAndInt ? isLeftHandHoldingMagazine : !isLeftHandHoldingMagazine;
                                break;
                            case S3DAnimCondition.ActionCondition.IsMagazineInRightHand:
                                areAllConditionsTrue = conditionTypeInt == S3DAnimCondition.ConditionTypeAndInt ? isRightHandHoldingMagazine : !isRightHandHoldingMagazine;
                                break;
                            default: break;
                        }
                    }
                }

                return areAllConditionsTrue;
            }
        }

        /// <summary>
        /// Disable the sending of animation data to the character animation controller
        /// </summary>
        public void DisableAnimate()
        {
            EnableOrDisableAnimate(false);
        }

        /// <summary>
        /// Disable Animation Root Motion. This is currently in Technical Preview.
        /// </summary>
        public void DisableRootMotion()
        {
            EnableOrDisableRootMotion(false);
        }

        /// <summary>
        /// Enable the sending of animation data to the character animation controller.
        /// This will fall back to Disabled if the current setup does not support it.
        /// </summary>
        public void EnableAnimate()
        {
            EnableOrDisableAnimate(true);
        }

        /// <summary>
        /// Enable Animation Root Motion. This is currently in Technical Preview.
        /// </summary>
        public void EnableRootMotion()
        {
            EnableOrDisableRootMotion(true);
        }

        /// <summary>
        /// Get an S3DAnimAction class instance using the unique identifier (guidHash) of AnimAction from the list
        /// displayed in editor on the Animate tab.
        /// </summary>
        /// <param name="guidHash"></param>
        /// <returns></returns>
        public S3DAnimAction GetAnimAction(int guidHash)
        {
            S3DAnimAction s3DAnimAction = null;

            if (guidHash != 0)
            {
                int _numAnimateActions = isInitialised ? numAnimateActions : s3dAnimActionList == null ? 0 : s3dAnimActionList.Count;

                for (int aaIdx = 0; aaIdx < _numAnimateActions; aaIdx++)
                {
                    S3DAnimAction _tempAnimAction = s3dAnimActionList[aaIdx];
                    if (_tempAnimAction != null && _tempAnimAction.guidHash == guidHash)
                    {
                        s3DAnimAction = _tempAnimAction;
                        break;
                    }
                }
            }

            return s3DAnimAction;
        }

        /// <summary>
        /// Get an S3DAnimAction class instance using the zero-based index or sequence number in the list
        /// which is seen in the editor on the Animate tab.
        /// </summary>
        /// <param name="animActionIndex"></param>
        /// <returns></returns>
        public S3DAnimAction GetAnimActionByIndex(int animActionIndex)
        {
            int _numAnimateActions = isInitialised ? numAnimateActions : s3dAnimActionList == null ? 0 : s3dAnimActionList.Count;

            if (animActionIndex >= 0 && animActionIndex < _numAnimateActions)
            {
                return s3dAnimActionList[animActionIndex];
            }
            else { return null; }
        }

        /// <summary>
        /// Get the unique guidHash of an S3DAnimAction using the zero-based index or sequence number in the list
        /// which is seen in the editor on the Animate tab.
        /// </summary>
        /// <param name="animActionIndex"></param>
        /// <returns></returns>
        public int GetAnimActionHashByIndex(int animActionIndex)
        {
            int _numAnimateActions = isInitialised ? numAnimateActions : s3dAnimActionList == null ? 0 : s3dAnimActionList.Count;

            if (animActionIndex >= 0 && animActionIndex < _numAnimateActions)
            {
                S3DAnimAction _tempAnimAction = s3dAnimActionList[animActionIndex];
                if (_tempAnimAction != null) { return _tempAnimAction.guidHash; }
                else { return 0; }
            }
            else { return 0; }
        }

        /// <summary>
        /// Get the zero-based index of AnimAction from the list seen in the editor on the Animate tab,
        /// using the unique identifier (guidHash) of an AnimAction. Returns -1 if not found.
        /// </summary>
        /// <param name="guidHash"></param>
        /// <returns></returns>
        public int GetAnimActionIndex(int guidHash)
        {
            int aaIndex = -1;

            if (guidHash != 0)
            {
                int _numAnimateActions = isInitialised ? numAnimateActions : s3dAnimActionList == null ? 0 : s3dAnimActionList.Count;

                for (int aaIdx = 0; aaIdx < _numAnimateActions; aaIdx++)
                {
                    S3DAnimAction _tempAnimAction = s3dAnimActionList[aaIdx];
                    if (_tempAnimAction != null && _tempAnimAction.guidHash == guidHash)
                    {
                        aaIndex = aaIdx;
                        break;
                    }
                }
            }

            return aaIndex;
        }

        /// <summary>
        /// Return the state Id (hash) given a state in an Animation Controller.
        /// NOTE: This does not test if the state exists in any of the layers.
        /// </summary>
        /// <param name="stateName"></param>
        /// <returns></returns>
        public int GetAnimationStateId(string stateName)
        {
            return Animator.StringToHash(stateName);
        }

        /// <summary>
        /// Get the S3D internal data being stored for the Animator zero-based Layer.
        /// </summary>
        /// <param name="layerIndex">Range 0 to number of Animator Layers</param>
        /// <returns></returns>
        public S3DAnimLayerData GetAnimLayerData(int layerIndex)
        {
            if (layerIndex >= 0 && layerIndex < numAnimLayers)
            {
                return animlayerDataList[layerIndex];
            }
            else { return null; }
        }

        /// <summary>
        /// This is the distance from the upper arm to the hand bone. It does not include the hand.
        /// Typically you want to cache this value rather than calling it often.
        /// </summary>
        /// <param name="side"></param>
        /// <param name="armLength"></param>
        /// <returns></returns>
        public bool GetArmLength(S3Dside side, ref float armLength)
        {
            bool isSuccessful = false;

            // Check for humanoid and get bones if not already cached.
            if (RefreshBoneTransforms(false))
            {
                // Note: The shoulder is an optional bone and may not be present in all humanoids.
                // Upper Arm, Lower Arm, and Hand are mandatory for a valid humanoid.

                if (side == S3Dside.Left)
                {
                    // Make sure we have all the bones we need
                    if (leftHandTrfm != null && leftLowerArmTrfm != null && leftUpperArmTrfm != null)
                    {
                        armLength = (leftUpperArmTrfm.position - leftLowerArmTrfm.position).magnitude + (leftLowerArmTrfm.position - leftHandTrfm.position).magnitude;
                    }
                }
                else
                {
                    // Make sure we have all the bones we need
                    if (rightHandTrfm != null && rightLowerArmTrfm != null && rightUpperArmTrfm != null)
                    {
                        armLength = (rightUpperArmTrfm.position - rightLowerArmTrfm.position).magnitude + (rightLowerArmTrfm.position - rightHandTrfm.position).magnitude;
                    }
                }
            }
            #if UNITY_EDITOR
            else
            {
                Debug.LogWarning("ERROR: StickyControlModule.GetArmLength(" + side + ") on " + name + " failed");
            }
            #endif

            return isSuccessful;
        }

        /// <summary>
        /// Updates the offset parameter with the local space offset from the bottom
        /// of the (humanoid) character if the bone is found and returns true.
        /// Returns false if there is no valid animator controller, the character
        /// rig is not humanoid, or the bone is not found.
        /// </summary>
        /// <param name="bone"></param>
        /// <param name="offset"></param>
        /// <returns></returns>
        public bool GetBoneBottomOffset(HumanBodyBones bone, ref Vector3 offset)
        {
            bool isSuccessful = false;

            if (isAnimateEnabled)
            {
                if (defaultAnimator.isHuman)
                {
                    Transform boneTrfm = defaultAnimator.GetBoneTransform(bone);

                    if (boneTrfm != null)
                    {
                        offset = GetLocalOffsetFromBottom(currentWorldPosition, boneTrfm.position);
                        isSuccessful = true;
                    }
#if UNITY_EDITOR
                    else
                    {
                        Debug.LogWarning("StickyControlModule.GetBoneBottomOffset - " + name + " does not appear to have a " + bone.ToString() + " bone");
                    }
#endif
                }
#if UNITY_EDITOR
                else
                {
                    Debug.LogWarning("StickyControlModule.GetBoneBottomOffset - " + name + " does not appear to have a humanoid rig");
                }
#endif
            }
#if UNITY_EDITOR
            else
            {
                Debug.LogWarning("StickyControlModule.GetBoneBottomOffset - Animate on " + name + " is not configured or enabled");
            }
#endif

            return isSuccessful;
        }

        /// <summary>
        /// Attempt to get the transform for a human body bone.
        /// </summary>
        /// <param name="humanBone"></param>
        /// <returns></returns>
        public Transform GetBoneTransform (HumanBodyBones humanBone)
        {
            return defaultAnimator == null ? null : defaultAnimator.GetBoneTransform(humanBone);
        }

        /// <summary>
        /// Get the current root motion idle threshold. Character velocity magnitude below this value
        /// is considered idle.
        /// </summary>
        /// <returns></returns>
        public float GetRootMotionIdleThreshold()
        {
            return rootMotionIdleThreshold;
        }

        /// <summary>
        /// Check to see if an IKEnabler component is required. If the Animator is not on the root
        /// gameobject of S3D and isFootIK/isHeadIK/isHandIK/isRootMotion is enabled, we need the S3DIKEnabler component
        /// to send OnAnimatorIK events to S3D.
        /// WARNING: Currently may incur some GC, so use sparingly. If this is an issue, please contact us.
        /// </summary>
        public void IKCheckEnabler()
        {
            bool isIKEnablerRequired = false;

            if (defaultAnimator != null)
            {
                Animator anim = GetComponent<Animator>();

                // Is there an Animator on the root gameobject?
                if (anim != null)
                {
                    // Is this Animator the same as the one referenced in the Animator tab?
                    isIKEnablerRequired = (anim.GetInstanceID() != defaultAnimator.GetInstanceID()) && (isFootIK || isHandIK || isHeadIK || isRootMotion);
                }
                else { isIKEnablerRequired = isFootIK || isHeadIK || isHandIK || isRootMotion; }
            }

            S3DIKEnabler[] s3dIKEnabler = GetComponentsInChildren<S3DIKEnabler>(false);

            int numEnablers = s3dIKEnabler == null ? 0 : s3dIKEnabler.Length;

            if (isIKEnablerRequired)
            {
                if (numEnablers == 0)
                {
                    defaultAnimator.gameObject.AddComponent<S3DIKEnabler>();
                }
            }
            else if (numEnablers > 0)
            {
                for (int enIdx = numEnablers - 1; enIdx >= 0; enIdx--)
                {
#if UNITY_EDITOR
                    DestroyImmediate(s3dIKEnabler[enIdx]);
#else
                    Destroy(s3dIKEnabler[enIdx]);
#endif
                }
            }
        }

        /// <summary>
        /// Import a json file from disk and return as list of S3DAnimAction
        /// </summary>
        /// <param name="folderPath"></param>
        /// <param name="fileName"></param>
        /// <returns></returns>
        public List<S3DAnimAction> ImportAnimateDataFromJson(string folderPath, string fileName)
        {
            List<S3DAnimAction> importedAnimActionList = null;

            if (!string.IsNullOrEmpty(folderPath) && !string.IsNullOrEmpty(fileName))
            {
                try
                {
                    string filePath = System.IO.Path.Combine(folderPath, fileName);
                    if (System.IO.File.Exists(filePath))
                    {
                        string jsonText = System.IO.File.ReadAllText(filePath);

                        importedAnimActionList = S3DUtils.FromJson<S3DAnimAction>(jsonText);

                        // Currently cannot do this because we need a wrapper class for the list
                        //JsonUtility.FromJsonOverwrite(jsonText, importedAnimActionList);
                    }
#if UNITY_EDITOR
                    else
                    {
                        Debug.LogWarning("ERROR: StickyControlModule Import Animation Actions. Could not find file at " + filePath);
                    }
#endif
                }
                catch (System.Exception ex)
                {
#if UNITY_EDITOR
                    Debug.LogWarning("ERROR: StickyControlModule - could not import Animation Actions from: " + folderPath + " PLEASE REPORT - " + ex.Message);
#else
                    // Keep compiler happy
                    if (ex != null) { }
#endif
                }
            }

            return importedAnimActionList;
        }

        /// <summary>
        /// Check if the character Animator is updating in the FixedUpdate loop (aka Unity Physics).
        /// If forceRefresh is true, it will check the Animator component rather than just returning the last known value.
        /// </summary>
        /// <param name="forceRefresh"></param>
        /// <returns></returns>
        public bool IsAnimatorFixedUpdate (bool forceRefresh)
        {
            if (forceRefresh)
            {
                #if UNITY_2023_1_OR_NEWER
                isAnimatorFixedUpdate = defaultAnimator != null && defaultAnimator.updateMode == AnimatorUpdateMode.Fixed;
                #else
                isAnimatorFixedUpdate = defaultAnimator != null && defaultAnimator.updateMode == AnimatorUpdateMode.AnimatePhysics;
                #endif
            }

            return isAnimatorFixedUpdate;
        }

        /// <summary>
        /// Does this character look like a valid humanoid?
        /// </summary>
        /// <returns></returns>
        public bool IsValidHumanoid(bool showErrors = false)
        {
            bool isValid = false;

            // Check for a valid Animator (rather than isAnimateEnabled) so that we can run this
            // before EnableOrDisableAnimate(..) is called in Initialise().
            if (defaultAnimator != null)
            {
                if (defaultAnimator.isHuman && defaultAnimator.avatar != null && defaultAnimator.avatar.isValid)
                {
                    isValid = true;
                }
#if UNITY_EDITOR
                else if (showErrors)
                {
                    Debug.LogWarning("StickyControlModule.IsValidHumanoid - " + name + " does not appear to have a valid humanoid rig");
                }
#endif
            }
#if UNITY_EDITOR
            else if (showErrors)
            {
                Debug.LogWarning("StickyControlModule.IsValidHumanoid - Animate on " + name + " is not configured or enabled");
            }
#endif

            return isValid;
        }

        /// <summary>
        /// Play the Animation State in the layer within the Animator Controller. Set the 
        /// layerIndex to -1 if you want to play the first matching state (on any layer).
        /// If the zero-based layerIndex is set, it will also check if the state exists.
        /// For no transition, set transitionDuration to 0. For a smoother, but slower
        /// transition, increase transitionDuration.
        /// </summary>
        /// <param name="stateId"></param>
        /// <param name="layerIndex"></param>
        /// <param name="transitionDuration">Transition time in seconds</param>
        public void PlayAnimationState(int stateId, int layerIndex, float transitionDuration = 0.2f)
        {
            if (isAnimateEnabled && (layerIndex == -1 || defaultAnimator.HasState(layerIndex, stateId)))
            {
                if (transitionDuration > 0f) { defaultAnimator.CrossFadeInFixedTime(stateId, transitionDuration, layerIndex); }
                else { defaultAnimator.Play(stateId, layerIndex); }
            }
        }

        /// <summary>
        /// Play the Animation State in the layer within the Animator Controller starting at a normalised
        /// offset from the start of the clip. Set the layerIndex to -1 if you want to play the first
        /// matching state (on any layer). If the zero-based layerIndex is set, it will also check if the
        /// state exists. An offset of 0.0 starts at the beginning, while 0.9 starts near the end of the
        /// clip for the animation state.
        /// </summary>
        /// <param name="stateId"></param>
        /// <param name="layerIndex"></param>
        /// <param name="transitionNormalised">Range 0.0 to 1.0</param>
        /// <param name="offsetNormalised">0.0 starts at the beginning, 0.9 starts near the end of the clip</param>
        public void PlayAnimationStateWithOffset(int stateId, int layerIndex, float transitionNormalised, float offsetNormalised)
        {
            if (isAnimateEnabled && (layerIndex == -1 || defaultAnimator.HasState(layerIndex, stateId)))
            {
                if (offsetNormalised <= 0f || offsetNormalised >= 1f)
                {
                    if (transitionNormalised > 0f && transitionNormalised <= 1f) { defaultAnimator.CrossFade(stateId, transitionNormalised, layerIndex); }
                    else { defaultAnimator.Play(stateId, layerIndex); }
                }
                else if (transitionNormalised > 0f && transitionNormalised <= 1f)
                {
                    defaultAnimator.CrossFade(stateId, transitionNormalised, layerIndex, offsetNormalised);
                }
                else
                {
                    defaultAnimator.Play(stateId, layerIndex, offsetNormalised);
                }
            }
        }

        /// <summary>
        /// Refresh and validate Animate settings. Call this after changing any Animate settings.
        /// </summary>
        public void RefreshAnimateSettings()
        {
            RefreshAnimateSettings(false);
        }

        /// <summary>
        /// Replace all instances of the currentClip in the Animator Controller with a new AnimationClip.
        /// Update the reference to the currentClip when it has been replaced.
        /// </summary>
        /// <param name="currentClip"></param>
        /// <param name="newClip"></param>
        public void ReplaceAnimationClip(ref AnimationClip currentClip, AnimationClip newClip)
        {
            if (isInitialised && currentClip != null && newClip != null)
            {
                if (animOverrideController[currentClip.name] != newClip)
                {
                    animOverrideController[currentClip.name] = newClip;
                    currentClip = newClip;
                }
            }
        }

        /// <summary>
        /// Replace all instances of the currentClip in the Animator Controller with a new AnimationClip.
        /// </summary>
        /// <param name="currentClip"></param>
        /// <param name="newClip"></param>
        public void ReplaceAnimationClipNoRef(AnimationClip currentClip, AnimationClip newClip)
        {
            if (isInitialised && currentClip != null && newClip != null)
            {
                if (animOverrideController[currentClip.name] != newClip)
                {
                    animOverrideController[currentClip.name] = newClip;
                }
            }
        }

        /// <summary>
        /// When a weapon is dropped, we may wish to delay replacing the animation clips with the original
        /// ones. For example, immediately replacing weapon held animations will having the weapon being
        /// held incorrectly as it transitions back to say an idle state.
        /// See stickyWeapon.ApplyOrRevertWeaponAnimSets(..).
        /// </summary>
        /// <param name="animClipPairList"></param>
        /// <param name="delay"></param>
        /// <returns></returns>
        public IEnumerator ReplaceAnimationClipsDelayed (List<S3DAnimClipPair> animClipPairList, float delay)
        {
            yield return new WaitForSeconds(delay);

            // In the future we may not want to delay replacement of all clip pairs.

            int numAnimClipPairs = animClipPairList.Count;

            // Loop through all the Clip Pairs in the Weapon Anim Set scriptable object
            for (int animClipPairIdx = 0; animClipPairIdx < numAnimClipPairs; animClipPairIdx++)
            {
                S3DAnimClipPair clipPair = animClipPairList[animClipPairIdx];

                ReplaceAnimationClipNoRef(clipPair.originalClip, clipPair.originalClip);

                //Debug.Log("[DEBUG] Delay Reverting clip " + clipPair.replacementClip.name + " to " + clipPair.originalClip.name + " T:" + Time.time);
            }
        }

        /// <summary>
        /// Save the list of S3DAnimAction for this StickyControlModule to a json file on disk.
        /// </summary>
        /// <param name="filePath"></param>
        public bool SaveAnimateDataAsJson(string filePath)
        {
            bool isSuccessful = false;

            if (s3dAnimActionList != null && !string.IsNullOrEmpty(filePath))
            {
                try
                {
                    string jsonData = S3DUtils.ToJson(s3dAnimActionList);

                    if (!string.IsNullOrEmpty(jsonData) && !string.IsNullOrEmpty(filePath))
                    {
                        System.IO.File.WriteAllText(filePath, jsonData);
                        isSuccessful = true;
                    }
                }
                catch (System.Exception ex)
                {
#if UNITY_EDITOR
                    Debug.LogWarning("ERROR: StickyControlModule - could not export Animation Actions for " + transform.name + " PLEASE REPORT - " + ex.Message);
#else
                    // Keep compiler happy
                    if (ex != null) { }
#endif
                }
            }

            return isSuccessful;
        }

        /// <summary>
        /// Set the duration, in seconds, it takes for an animator layer weight to reach 1.0.
        /// See also BlendInAnimLayer (..).
        /// </summary>
        /// <param name="layerIndex"></param>
        /// <param name="blendInDuration">Min value is 0.001 seconds</param>
        public void SetAnimLayerBlendInDuration(int layerIndex, float blendInDuration)
        {
            if (isAnimateEnabled && layerIndex >= 0 && layerIndex < numAnimLayers)
            {
                animlayerDataList[layerIndex].blendInDuration = blendInDuration < 0.001f ? 0.001f : blendInDuration;
            }
        }

        /// <summary>
        /// Set the duration, in seconds, it takes for an animator layer weight to reach 0.0.
        /// See also BlendOutAnimLayer (..).
        /// </summary>
        /// <param name="layerIndex"></param>
        /// <param name="blendOutDuration">Min value is 0.001 second</param>
        public void SetAnimLayerBlendOutDuration(int layerIndex, float blendOutDuration)
        {
            if (isAnimateEnabled && layerIndex >= 0 && layerIndex < numAnimLayers)
            {
                animlayerDataList[layerIndex].blendOutDuration = blendOutDuration < 0.001f ? 0.001f : blendOutDuration;
            }
        }

        /// <summary>
        /// Given the guidHash of a custom S3DAnimAction set its boolean value, assuming it has a matching ParamaterType.
        /// If Toggle is enabled, attempt to toggle the current value in the animation controller.
        /// </summary>
        /// <param name="guidHash"></param>
        /// <param name="value"></param>
        public void SetCustomAnimActionBoolValue(int guidHash, bool value)
        {
            SetCustomAnimActionBoolValue(GetAnimAction(guidHash), value);
        }

        /// <summary>
        /// Given a custom S3DAnimAction set its boolean value, assuming it has a matching ParamaterType
        /// and the standardAction is a custom action.
        /// If Toggle is enabled, attempt to toggle the current value in the animation controller.
        /// </summary>
        /// <param name="s3DAnimAction"></param>
        /// <param name="value"></param>
        public void SetCustomAnimActionBoolValue(S3DAnimAction s3DAnimAction, bool value)
        {
            if (s3DAnimAction != null && (int)s3DAnimAction.standardAction == S3DAnimAction.StandardActionCustomInt && s3DAnimAction.parameterType == S3DAnimAction.ParameterType.Bool)
            {
                // If required, attempt to toggle the current value in the animator.
                if (s3DAnimAction.isToggle && isAnimateEnabled && s3DAnimAction.paramHashCode != 0)
                {
                    // Query the animation controller for the current value, then toggle it.
                    s3DAnimAction.customActionBoolValue = !defaultAnimator.GetBool(s3DAnimAction.paramHashCode);
                }
                else
                {
                    s3DAnimAction.customActionBoolValue = value;
                }
            }
        }

        /// <summary>
        /// Given the guidHash of a custom S3DAnimAction set its float value, assuming it has a matching ParamaterType
        /// and the standardAction is a custom action.
        /// </summary>
        /// <param name="guidHash"></param>
        /// <param name="value"></param>
        public void SetCustomAnimActionFloatValue(int guidHash, float value)
        {
            SetCustomAnimActionFloatValue(GetAnimAction(guidHash), value);
        }

        /// <summary>
        /// Given a custom S3DAnimAction set its float value, assuming it has a matching ParamaterType
        /// and the standardAction is a custom action.
        /// </summary>
        /// <param name="s3DAnimAction"></param>
        /// <param name="value"></param>
        public void SetCustomAnimActionFloatValue(S3DAnimAction s3DAnimAction, float value)
        {
            if (s3DAnimAction != null && (int)s3DAnimAction.standardAction == S3DAnimAction.StandardActionCustomInt && s3DAnimAction.parameterType == S3DAnimAction.ParameterType.Float)
            {
                s3DAnimAction.customActionFloatValue = value;
            }
        }

        /// <summary>
        /// Given the guidHash of a custom S3DAnimAction set its integer value, assuming it has a matching ParamaterType
        /// and the standardAction is a custom action.
        /// </summary>
        /// <param name="guidHash"></param>
        /// <param name="value"></param>
        public void SetCustomAnimActionIntegerValue(int guidHash, int value)
        {
            SetCustomAnimActionIntegerValue(GetAnimAction(guidHash), value);
        }

        /// <summary>
        /// Given a custom S3DAnimAction set its integer value, assuming it has a matching ParamaterType
        /// and the standardAction is a custom action.
        /// </summary>
        /// <param name="s3DAnimAction"></param>
        /// <param name="value"></param>
        public void SetCustomAnimActionIntegerValue(S3DAnimAction s3DAnimAction, int value)
        {
            if (s3DAnimAction != null && (int)s3DAnimAction.standardAction == S3DAnimAction.StandardActionCustomInt && s3DAnimAction.parameterType == S3DAnimAction.ParameterType.Integer)
            {
                s3DAnimAction.customActionIntegerValue = value;
            }
        }

        /// <summary>
        /// Given the guidHash of a custom S3DAnimAction set its trigger (bool) value, assuming it has a matching ParamaterType
        /// and the standardAction is a custom action.
        /// </summary>
        /// <param name="guidHash"></param>
        /// <param name="value"></param>
        public void SetCustomAnimActionTriggerValue(int guidHash, bool value)
        {
            SetCustomAnimActionTriggerValue(GetAnimAction(guidHash), value);
        }

        /// <summary>
        /// Given a custom S3DAnimAction set its trigger (bool) value, assuming it has a matching ParamaterType
        /// and the standardAction is a custom action.
        /// </summary>
        /// <param name="s3DAnimAction"></param>
        /// <param name="value"></param>
        public void SetCustomAnimActionTriggerValue(S3DAnimAction s3DAnimAction, bool value)
        {
            if (s3DAnimAction != null && (int)s3DAnimAction.standardAction == S3DAnimAction.StandardActionCustomInt && s3DAnimAction.parameterType == S3DAnimAction.ParameterType.Trigger)
            {
                s3DAnimAction.customActionTriggerValue = value;
            }
        }

        /// <summary>
        /// Change the current root motion idle threshold. Character velocity magnitude below this value
        /// is considered idle.
        /// </summary>
        /// <returns></returns>
        public void SetRootMotionIdleThreshold(float newThreshold)
        {
            if (isRootMotion && newThreshold >= 0.0001f && newThreshold < 0.5f)
            {
                rootMotionIdleThreshold = newThreshold;

                // Root motion threshold overrides the default threshold
                moveIdleThreshold = newThreshold;
            }
        }

        /// <summary>
        /// If there is an ReplaceAnimationClipsDelayed(..) pending completion,
        /// attempt to stop it. Can be useful if wanting to replace some animations
        /// soon after another weapon has been dropped or equipped.
        /// </summary>
        public void StopRevertAnimClips()
        {
            if (revertAnimClipsDelayed != null)
            {
                StopCoroutine(revertAnimClipsDelayed);
                revertAnimClipsDelayed = null;
            }
        }

        /// <summary>
        /// At runtime, verify if a parameter of the given name and type exists on the animator controller.
        /// Returns 0 if no matching parameter is found, else returns the parameter hashcode.
        /// WARNING: This impacts GC and should never be called in an update loop. Use sparingly.
        /// </summary>
        /// <param name="parameterName"></param>
        /// <param name="parameterType"></param>
        /// <returns></returns>
        public int VerifyAnimParameter(string parameterName, S3DAnimAction.ParameterType parameterType)
        {
            int hashCode = 0;

            if (isAnimateEnabled && defaultAnimator.parameterCount > 0)
            {
                foreach (AnimatorControllerParameter parm in defaultAnimator.parameters)
                {
                    if (parm.name == parameterName)
                    {
                        if (parm.type == AnimatorControllerParameterType.Bool && parameterType == S3DAnimAction.ParameterType.Bool ||
                            parm.type == AnimatorControllerParameterType.Float && parameterType == S3DAnimAction.ParameterType.Float ||
                            parm.type == AnimatorControllerParameterType.Int && parameterType == S3DAnimAction.ParameterType.Integer ||
                            parm.type == AnimatorControllerParameterType.Trigger && parameterType == S3DAnimAction.ParameterType.Trigger
                        )
                        {
                            hashCode = parm.nameHash;

                            //Debug.Log("[DEBUG] " + parameterName + " HashCode: " + hashCode);
                            break;
                        }
                    }
                }

#if UNITY_EDITOR
                if (hashCode == 0)
                {
                    Debug.LogWarning("StickyControlModule.VerifyAnimParameter [" + (string.IsNullOrEmpty(parameterName) ? "BLANK" : parameterName) + "] does not exist in animator controller or is the wrong type.");
                }
#endif
            }

            return hashCode;
        }

        #endregion

        #region Public API Methods - Animate (Aim IK)

        /// <summary>
        /// Enable or disable Aim IK. Called from stickyWeapon.EnableOrDisableAiming(..).
        /// Rather than calling this directly, devs will typically want to call
        /// StartAimingWeapon(..), StopAimingWeapon(..) or ToggleAimWeapon(..).
        /// </summary>
        /// <param name="isEnable"></param>
        /// <param name="isSmooth"></param>
        public void EnableAimAtTarget (bool isEnable, bool isSmooth)
        {
            EnableOrDisableAimIK(isEnable, isSmooth);
        }

        /// <summary>
        /// Get the ray where the character is aiming while holding a weapon.
        /// See also GetLookingAtRay(..).
        /// </summary>
        /// <returns></returns>
        public Ray GetAimingRay()
        {
            if (isLookEnabled && isAimAtTargetEnabled && !isNPC)
            {
                /// TODO - GetAimRay - Ideally this should be infront of the weapon fire point, but forward from the centre of the camera.
                if (isThirdPerson && !isAimIKSmoothEnable)
                {
                    // When in third person and the initial phase has completed, we (prob) need
                    // to be looking straight ahead.
                    Ray ray = new Ray(lookTransform.position, lookCamera1.transform.forward);

                    // Move third person aim start position from behind character
                    float cameraLSZ = -currentCameraPosition.z;

                    ray.origin += ray.direction * (cameraLSZ > lookCamera1.nearClipPlane ? cameraLSZ : lookCamera1.nearClipPlane);

                    return ray;
                }
                else
                {
                    // Get where the camera is looking toward the cursor position. If
                    // no cursor, use the centre of the screen which is the default
                    // in first person aiming.
                    Ray ray = lookCamera1.ScreenPointToRay(MouseScreenPoint(false));

                    float cameraLSZ = -currentCameraPosition.z;
                    ray.origin += ray.direction * (cameraLSZ > lookCamera1.nearClipPlane ? cameraLSZ : lookCamera1.nearClipPlane);

                    //DebugExtension.DebugArrow(ray.origin, ray.direction);

                    //Debug.Break();

                    return ray;
                }
            }
            else
            {
                return new Ray(GetWorldEyePosition(), GetWorldLookDirection());
            }
        }

        /// <summary>
        /// Get the bone transforms for the aimBones array configured in the editor.
        /// Typically this will only be called once during Initialise().
        /// NOTE: The list is only populated with bone transforms found on the humanoid rig.
        /// </summary>
        public void RefreshAimBoneTransforms()
        {
            numAimBones = aimBones == null ? 0 : aimBones.Length;

            if (numAimBones > 0 && defaultAnimator != null && IsValidHumanoid())
            {
                HumanBodyBones pairedAimBone = HumanBodyBones.Hips;

                for (int abIdx = 0; abIdx < numAimBones; abIdx++)
                {
                    S3DHumanBone s3DHumanBone = aimBones[abIdx];

                    if (s3DHumanBone != null)
                    {
                        if (aimBones[abIdx].bone != HumanBodyBones.LastBone)
                        {
                            // These "may" return null if the bone is not available on this rig
                            Transform aimBoneTfrm = defaultAnimator.GetBoneTransform(aimBones[abIdx].bone);

                            if (aimBoneTfrm != null)
                            {
                                s3DHumanBone.boneTransform = aimBoneTfrm;

                                // If this bone is paired, find it's twin transform
                                if (s3DHumanBone.isPaired && S3DHumanBone.GetTwin(s3DHumanBone.bone, ref pairedAimBone))
                                {
                                    s3DHumanBone.boneTransformTwin = defaultAnimator.GetBoneTransform(pairedAimBone);
                                    s3DHumanBone.boneTwin = pairedAimBone;
                                    s3DHumanBone.isTwinValid = s3DHumanBone.boneTransformTwin != null;
                                }

                                s3DHumanBone.isValid = true;
                            }
#if UNITY_EDITOR
                            else { Debug.LogWarning(aimBones[abIdx].bone.ToString() + " Aim Bone is not found on the " + name + " character rig."); }
#endif
                        }
                        else
                        {
                            s3DHumanBone.isValid = false;
                            s3DHumanBone.isTwinValid = false;
#if UNITY_EDITOR
                            Debug.LogWarning("ERROR: Aim Bone " + (abIdx + 1).ToString() + " cannot use LastBone on " + name + " character. Please select a valid bone.");
#endif
                        }
                    }
#if UNITY_EDITOR
                    else { Debug.LogWarning("ERROR: S3DHumanBone in Aim Bones array is NULL on " + name + " character. PLEASE REPORT."); }
#endif
                }
            }
        }

        /// <summary>
        /// Set (update) an existing aim bone in the current array.
        /// </summary>
        /// <param name="newAimBone">Cannot be null</param>
        /// <param name="arrayIndex">The zero-based index in the current array of aim bones</param>
        public void SetAimBone (S3DHumanBone newAimBone, int arrayIndex)
        {
            if (numAimBones == 0) { numAimBones = aimBones == null ? 0 : aimBones.Length; }

            if (arrayIndex >= 0 && arrayIndex < numAimBones && newAimBone != null)
            {
                aimBones[arrayIndex] = newAimBone;

                if (newAimBone.guidHash == 0) { newAimBone.SetClassDefaults(); }

                RefreshAimBoneTransforms();
            }
        }

        /// <summary>
        /// Set a new array of Aim Bones
        /// </summary>
        /// <param name="newS3DHumanBones"></param>
        public void SetAimBones (S3DHumanBone[] newS3DHumanBones)
        {
            aimBones = newS3DHumanBones;

            RefreshAimBoneTransforms();
        }

        /// <summary>
        /// If a weapon is held, will it always attempt to face the target?
        /// Otherwise, it will only do this when weapon IsAiming is true.
        /// </summary>
        /// <param name="newValue"></param>
        public void SetAimIKWhenNotAiming (bool newValue)
        {
            isAimIKWhenNotAiming = newValue;
        }

        #endregion

        #region Public API Methods - Animate (Head IK)

        /// <summary>
        /// Disable Head Inverse Kinematics.
        /// SmoothDisable will attempt to blend out the change over several frames.
        /// </summary>
        /// <param name="isSmoothDisable"></param>
        public void DisableHeadIK(bool isSmoothDisable)
        {
            EnableOrDisableHeadIK(false, false, isSmoothDisable);
        }

        /// <summary>
        /// Enable Head Inverse Kinematics. SmoothDisable will attempt to blend the change over several frames.
        /// </summary>
        /// <param name="isSmoothEnable"></param>
        public void EnableHeadIK(bool isSmoothEnable)
        {
            EnableOrDisableHeadIK(true, false, isSmoothEnable);
        }

        /// <summary>
        /// When the HeadIK target is a Sticky3D character, should this character look at their eyes?
        /// </summary>
        /// <returns></returns>
        public bool GetHeadIKLookAtEyes()
        {
            return headIKLookAtEyes;
        }

        /// <summary>
        /// When look interactive and Update Looking Point are enabled,
        /// while the character is stationary, should the head face either
        /// the interactive enabled object being looked at, or in the direction
        /// the character is looking?
        /// </summary>
        /// <returns></returns>
        public bool GetHeadIKLookAtInteractive()
        {
            return headIKLookAtInteractive;
        }

        /// <summary>
        /// Get the previous world space position the Head IK was looking at.
        /// </summary>
        /// <returns></returns>
        public Vector3 GetHeadIKPreviousPosition()
        {
            return prevHeadIKPos;
        }

        /// <summary>
        /// Get a reference to the transform (if any) Head IK is targeting.
        /// NOTE: This does not check if Head IK is enabled or not.
        /// </summary>
        /// <returns></returns>
        public Transform GetHeadIKTarget()
        {
            return headTargetTrfm;
        }

        /// <summary>
        /// Get the world space position of the Head IK target (if any).
        /// Otherwise return 0,0,0.
        /// </summary>
        /// <returns></returns>
        public Vector3 GetHeadIKTargetPosition()
        {
            if (isAnimateEnabled && isHeadIK)
            {
                return targetHeadIKPos;
            }
            else { return Vector3.zero; }
        }

        /// <summary>
        /// Reset the Head IK target position to be looking straight ahead for characters.
        /// </summary>
        public void ResetHeadIK()
        {
            if (isInitialised)
            {
                if (headTrfm != null)
                {
                    // Use the character forward rather than the head forward as the head bone
                    // may not be aligned with character Up direction.
                    targetHeadIKPos = headTrfm.position + currentCharacterFwd;

                    prevHeadIKPos = targetHeadIKPos;
                }
                else
                {
                    targetHeadIKPos = GetWorldEyePosition() + currentCharacterFwd;

                    prevHeadIKPos = targetHeadIKPos;
                }

                prevHeadIKAngles = Vector3.zero;
            }
        }

        /// <summary>
        /// When the HeadIK target is a Sticky3D character, should this character
        /// look at their eyes?
        /// </summary>
        /// <param name="isLookAtEyes"></param>
        public void SetHeadIKLookAtEyes(bool isLookAtEyes)
        {
            headIKLookAtEyes = isLookAtEyes;
        }

        /// <summary>
        /// When look interactive and Update Looking Point are enabled,
        /// while the character is stationary, should the head face either
        /// the interactive enabled object being looked at, or in the direction
        /// the character is looking?
        /// </summary>
        /// <param name="isLookAtInteractive"></param>
        public void SetHeadIKLookAtInteractive(bool isLookAtInteractive)
        {
            headIKLookAtInteractive = isLookAtInteractive;
        }

        /// <summary>
        /// Change where the head should be looking
        /// </summary>
        /// <param name="targetPosition"></param>
        public void SetHeadIKTarget(Vector3 targetPosition)
        {
            targetHeadIKPos = targetPosition;
        }

        /// <summary>
        /// Change the object that the head should be looking at. Automatically checks if it is a S3D character.
        /// EXAMPLE: SetHeadIKTarget (myTargetObject)
        /// </summary>
        /// <param name="targetTransform"></param>
        public void SetHeadIKTarget(Transform targetTransform)
        {
            SetHeadIKTarget(targetTransform, Vector3.zero, false, targetTransform == null ? false : targetTransform.GetComponent<StickyControlModule>() != null);
        }

        /// <summary>
        /// Change the object that the head should be looking at.
        /// The target offset is in the local space of the target.
        /// When isReset is true, the head will attempt to start looking straight ahead.
        /// EXAMPLE: SetHeadIKTarget (myTargetObject, Vector3.zero);
        /// </summary>
        /// <param name="targetTransform"></param>
        /// <param name="targetOffset"></param>
        /// <param name="isReset"></param>
        /// <param name="isCharacter"></param>
        public void SetHeadIKTarget(Transform targetTransform, Vector3 targetOffset, bool isReset = false, bool isCharacter = false)
        {
            if (targetTransform != null)
            {
                // Only set the target transform if it has changed
                if (headTargetTrfm == null || targetTransform.GetInstanceID() != headTargetTrfm.GetInstanceID())
                {
                    headTargetTrfm = targetTransform;
                    targetHeadIKPosOffset = targetOffset;
                    targetHeadIKPos = targetTransform.position;

                    // Do we need to get the target character's eyes offset?
                    if (isCharacter && headIKLookAtEyes)
                    {
                        StickyControlModule targetCharacter = targetTransform.GetComponent<StickyControlModule>();
                        if (targetCharacter != null)
                        {
                            targetHeadIKPosOffset += targetCharacter.GetLocalPosition(targetCharacter.GetWorldEyePosition());
                        }
#if UNITY_EDITOR
                        else { Debug.LogWarning("ERROR: StickyControlModule.SetHeadIKTarget - the target [" + targetTransform.name + "] is not a S3D character"); }
#endif
                    }

                    // Add local space offset if required
                    if (targetHeadIKPosOffset.x != 0f) { targetHeadIKPos += headTargetTrfm.right * targetHeadIKPosOffset.x; }
                    if (targetHeadIKPosOffset.y != 0f) { targetHeadIKPos += headTargetTrfm.up * targetHeadIKPosOffset.y; }
                    if (targetHeadIKPosOffset.z != 0f) { targetHeadIKPos += headTargetTrfm.forward * targetHeadIKPosOffset.z; }

                    if (headTrfm != null)
                    {
                        // Use the character forward rather than the head forward as the head bone
                        // may not be aligned with character Up direction.
                        if (isReset || prevHeadIKPos == Vector3.zero) { prevHeadIKPos = headTrfm.position + currentCharacterFwd; }
                    }
                    else { prevHeadIKPos = targetHeadIKPos; }
                }
            }
            else
            {
                headTargetTrfm = null;
                targetHeadIKPos = Vector3.zero;
                targetHeadIKPosOffset = Vector3.zero;
                // TODO - check
                if (isReset)
                {
                    prevHeadIKPos = headTrfm == null ? Vector3.zero : headTrfm.position + currentCharacterFwd;
                    prevHeadIKAngles = Vector3.zero;
                }
                else
                {
                    prevHeadIKPos = targetHeadIKPos;
                }
            }
        }

        /// <summary>
        /// If Head IK is currently being smoothly disabled over several frames,
        /// this attempts to reverse Head IK to being smoothly enabled.
        /// </summary>
        public void StopHeadIKDisable()
        {
            if (isHeadIK && isAnimateEnabled && isHeadIKSmoothDisable)
            {
                isHeadIKSmoothDisable = false;
                isHeadIKSmoothEnable = true;
            }
        }

        /// <summary>
        /// Attempt to turn on or off Head IK (Inverse Kinematics).
        /// Smoothly enable or disable Head IK.
        /// </summary>
        public void ToggleEnableHeadIK()
        {
            EnableOrDisableHeadIK(!isHeadIK, false, true);
        }

        #endregion

        #region Public API Methods - Animate (Hand IK)

        /// <summary>
        /// Clear or reset the interactive IK target for the left hand
        /// </summary>
        public void ClearLeftHandIKInterativeTarget()
        {
            HandIKResetInteractiveTarget(true);
        }

        /// <summary>
        /// Clear or reset the interactive IK target for the right hand
        /// </summary>
        public void ClearRightHandIKInterativeTarget()
        {
            HandIKResetInteractiveTarget(false);
        }

        /// <summary>
        /// Disable Hand Inverse Kinematics.
        /// SmoothDisable will attempt to blend out the change over several frames.
        /// </summary>
        /// <param name="isSmoothDisable"></param>
        public void DisableHandIK(bool isSmoothDisable)
        {
            EnableOrDisableHandIK(false, false, isSmoothDisable);
        }

        /// <summary>
        /// Enable Hand Inverse Kinematics. SmoothDisable will attempt to blend the change over several frames.
        /// </summary>
        /// <param name="isSmoothEnable"></param>
        public void EnableHandIK(bool isSmoothEnable)
        {
            EnableOrDisableHandIK(true, false, isSmoothEnable);
        }

        /// <summary>
        /// Get the world space palm position, or centre, of the left hand. If the hand transform is not
        /// available, Vector3.zero is returned.
        /// When handIK is enabled return the animated palm of hand position.
        /// </summary>
        /// <returns></returns>
        public Vector3 GetLeftHandPalmPosition()
        {
            if (isHandIK && leftHandData != null && leftHandData.lastKnownHandPos != Vector3.zero)
            {
                return leftHandData.lastKnownHandPos + (leftHandData.lastKnownHandRot * leftHandPalmOffset);
            }
            else if (leftHandTrfm != null)
            {
                return leftHandTrfm.position + (leftHandTrfm.rotation * leftHandPalmOffset);
            }
            else { return Vector3.zero; }
        }

        /// <summary>
        /// Get the world space rotation of the left hand palm
        /// </summary>
        /// <returns></returns>
        public Quaternion GetLeftHandPalmRotation()
        {
            if (isHandIK && leftHandData != null && leftHandData.lastKnownHandRot != Quaternion.identity)
            {
                return leftHandData.lastKnownHandRot * Quaternion.Euler(leftHandPalmRotation);
            }
            else if (leftHandTrfm != null)
            {
                // Rotate around the local space fwd direction of the hand (wrist bone)
                return leftHandTrfm.rotation * Quaternion.Euler(leftHandPalmRotation);
            }
            else { return Quaternion.identity; }
        }

        /// <summary>
        /// Get the local space offset the palm, or centre, of the hand is from the left bone position
        /// </summary>
        /// <returns></returns>
        public Vector3 GetLeftHandPalmOffset()
        {
            return leftHandPalmOffset;
        }

        /// <summary>
        /// Get the world space palm position, or centre, of the right hand. If the hand transform is not
        /// available, Vector3.zero is returned.
        /// When handIK is enabled return the animated palm of hand position.
        /// </summary>
        /// <returns></returns>
        public Vector3 GetRightHandPalmPosition()
        {
            if (isHandIK && rightHandData != null && rightHandData.lastKnownHandPos != Vector3.zero)
            {
                return rightHandData.lastKnownHandPos + (rightHandData.lastKnownHandRot * rightHandPalmOffset);
            }
            else if (rightHandTrfm != null)
            {
                return rightHandTrfm.position + (rightHandTrfm.rotation * rightHandPalmOffset);
            }
            else { return Vector3.zero; }
        }

        /// <summary>
        /// Get the world space rotation of the right hand palm
        /// </summary>
        /// <returns></returns>
        public Quaternion GetRightHandPalmRotation()
        {
            if (isHandIK && rightHandData != null && rightHandData.lastKnownHandRot != Quaternion.identity)
            {
                return rightHandData.lastKnownHandRot * Quaternion.Euler(rightHandPalmRotation);
            }
            else if (rightHandTrfm != null)
            {
                // Rotate around the local space fwd direction of the hand (wrist bone)
                return rightHandTrfm.rotation * Quaternion.Euler(rightHandPalmRotation);
            }
            else { return Quaternion.identity; }
        }

        /// <summary>
        /// Get the local space offset the palm, or centre, of the hand is from the right bone position
        /// </summary>
        /// <returns></returns>
        public Vector3 GetRightHandPalmOffset()
        {
            return rightHandPalmOffset;
        }

        /// <summary>
        /// Get the world space left hand IK previous position (if any).
        /// Otherwise return 0,0,0.
        /// </summary>
        /// <returns></returns>
        public Vector3 GetLeftHandIKPreviousPosition()
        {
            if (isAnimateEnabled && isHandIK)
            {
                return leftHandData.prevHandIKPos;
            }
            else { return Vector3.zero; }
        }

        /// <summary>
        /// Get the world space right hand IK previous position (if any).
        /// Otherwise return 0,0,0.
        /// </summary>
        /// <returns></returns>
        public Vector3 GetRightHandIKPreviousPosition()
        {
            if (isAnimateEnabled && isHandIK)
            {
                return rightHandData.prevHandIKPos;
            }
            else { return Vector3.zero; }
        }

        /// <summary>
        /// Get a reference to the transform (if any) the left hand IK is targeting.
        /// NOTE: This does not check if Hand IK is enabled or not.
        /// </summary>
        /// <returns></returns>
        public Transform GetLeftHandIKTarget()
        {
            return leftHandTargetTrfm;
        }

        /// <summary>
        /// Get a reference to the transform (if any) the right hand IK is targeting.
        /// NOTE: This does not check if Hand IK is enabled or not.
        /// </summary>
        /// <returns></returns>
        public Transform GetRightHandIKTarget()
        {
            return rightHandTargetTrfm;
        }

        /// <summary>
        /// Get a reference to the Sticky Interactive object (if any) the left hand IK is targeting.
        /// NOTE: This does not check if Hand IK is enabled or not.
        /// </summary>
        /// <returns></returns>
        public StickyInteractive GetLeftHandIKTargetInteractive()
        {
            return leftHandTargetInteractive;
        }

        /// <summary>
        /// Get the StickyInteractiveID of the current left hand IK target.
        /// If there isn't one, it will return 0.
        /// </summary>
        /// <returns></returns>
        public int GetLeftHandIKTargetInteractiveID()
        {
            return leftHandTargetInteractive == null ? StickyInteractive.NoID : leftHandTargetInteractive.StickyInteractiveID;
        }

        /// <summary>
        /// Get a reference to the Sticky Interactive object (if any) the right hand IK is targeting.
        /// NOTE: This does not check if Hand IK is enabled or not.
        /// </summary>
        /// <returns></returns>
        public StickyInteractive GetRightHandIKTargetInteractive()
        {
            return rightHandTargetInteractive;
        }

        /// <summary>
        /// Get the StickyInteractiveID of the current right hand IK target.
        /// If there isn't one, it will return 0.
        /// </summary>
        /// <returns></returns>
        public int GetRightHandIKTargetInteractiveID()
        {
            return rightHandTargetInteractive == null ? StickyInteractive.NoID : rightHandTargetInteractive.StickyInteractiveID;
        }

        /// <summary>
        /// Get the world space position of the left hand IK target (if any).
        /// Otherwise return 0,0,0.
        /// </summary>
        /// <returns></returns>
        public Vector3 GetLeftHandIKTargetPosition()
        {
            if (isAnimateEnabled && isHandIK)
            {
                return leftHandData.targetHandIKPos;
            }
            else { return Vector3.zero; }
        }

        /// <summary>
        /// Get the world space position of the right hand IK target (if any).
        /// Otherwise return 0,0,0.
        /// </summary>
        /// <returns></returns>
        public Vector3 GetRightHandIKTargetPosition()
        {
            if (isAnimateEnabled && isHandIK)
            {
                return rightHandData.targetHandIKPos;
            }
            else { return Vector3.zero; }
        }

        /// <summary>
        /// The maximum distance the left hand will attempt to reach for an object.
        /// </summary>
        /// <returns></returns>
        public float GetLeftHandMaxReachDistance()
        {
            return handIKLHMaxReachDist;
        }

        /// <summary>
        /// The maximum distance the right hand will attempt to reach for an object.
        /// </summary>
        /// <returns></returns>
        public float GetRightHandMaxReachDistance()
        {
            return handIKRHMaxReachDist;
        }

        /// <summary>
        /// Attempt to set the Hand IK left elbow hint.
        /// </summary>
        /// <param name="newElbowHint"></param>
        public void SetLeftHandElbowHint (Transform newElbowHint)
        {
            if (newElbowHint == null) { handIKLHElbowHint = null; }
            else if (newElbowHint.IsChildOf(transform))
            {
                handIKLHElbowHint = newElbowHint;
            }
            #if UNITY_EDITOR
            else
            {
                Debug.LogWarning("ERROR: SetLeftHandElbowHint - " + newElbowHint + " must be a child of " + transform.name);
            }
            #endif
        }

        /// <summary>
        /// Attempt to set the Hand IK right elbow hint.
        /// </summary>
        /// <param name="newElbowHint"></param>
        public void SetRightHandElbowHint (Transform newElbowHint)
        {
            if (newElbowHint == null) { handIKRHElbowHint = null; }
            else if (newElbowHint.IsChildOf(transform))
            {
                handIKRHElbowHint = newElbowHint;
            }
            #if UNITY_EDITOR
            else
            {
                Debug.LogWarning("ERROR: SetRightHandElbowHint - " + newElbowHint + " must be a child of " + transform.name);
            }
            #endif
        }

        /// <summary>
        /// Set the local space offset the palm, or centre, of the hand is from the left bone position
        /// </summary>
        /// <returns></returns>
        public void SetLeftHandPalmOffset(Vector3 newOffset)
        {
            leftHandPalmOffset = newOffset;
        }

        /// <summary>
        /// Set the local space rotation of the palm, relative to the left hand bone.
        /// </summary>
        /// <param name="newRotation"></param>
        public void SetLeftHandPalmRotation(Vector3 newRelativeRotation)
        {
            leftHandPalmRotation = newRelativeRotation;
        }

        /// <summary>
        /// Set the local space offset the palm, or centre, of the hand is from the right bone position
        /// </summary>
        /// <returns></returns>
        public void SetRightHandPalmOffset(Vector3 newOffset)
        {
            rightHandPalmOffset = newOffset;
        }

        /// <summary>
        /// Set the local space rotation of the palm, relative to the right hand bone.
        /// </summary>
        /// <param name="newRotation"></param>
        public void SetRightHandPalmRotation(Vector3 newRelativeRotation)
        {
            rightHandPalmRotation = newRelativeRotation;
        }

        /// <summary>
        /// Change the world space position of where the left hand should be reaching toward
        /// </summary>
        /// <param name="targetPosition"></param>
        public void SetLeftHandIKTarget(Vector3 targetPosition)
        {
            if (leftHandData == null) { leftHandData = new S3DHandData() { hand = AvatarIKGoal.LeftHand }; }
            leftHandData.targetHandIKPos = targetPosition;
        }

        /// <summary>
        /// Change the object that the left hand should reach toward.
        /// EXAMPLE: SetLeftHandIKTarget (myTargetObject)
        /// </summary>
        /// <param name="targetTransform"></param>
        public void SetLeftHandIKTarget(Transform targetTransform)
        {
            SetLeftHandIKTarget(targetTransform, Vector3.zero, Vector3.zero, false);
        }

        /// <summary>
        /// Change the object the the left hand should reach toward with a local space offset and rotation from the object.
        /// EXAMPLE: SetLeftHandIKTarget (myTargetObject, new Vector3(0f, 0.5f, 0f), new Vector3(0f, 30f, 0f), false)
        /// </summary>
        /// <param name="targetTransform"></param>
        /// <param name="targetOffset"></param>
        /// <param name="targetRotation"></param>
        /// <param name="isReset"></param>
        public void SetLeftHandIKTarget(Transform targetTransform, Vector3 targetOffset, Vector3 targetRotation, bool isReset = false)
        {
            if (leftHandData == null) { leftHandData = new S3DHandData() { hand = AvatarIKGoal.LeftHand }; }

            if (targetTransform != null)
            {
                // Only set the target transform if it has changed
                if (leftHandTargetTrfm == null || targetTransform.GetInstanceID() != leftHandTargetTrfm.GetInstanceID())
                {
                    leftHandTargetTrfm = targetTransform;
                    leftHandData.targetHandIKPosOffset = targetOffset;
                    leftHandData.targetHandIKRotMod = targetRotation;
                    leftHandData.targetHandIKPos = targetTransform.position;
                    leftHandData.targetHandIKRot = targetTransform.rotation;

                    // Add local space offset if required
                    if (leftHandData.targetHandIKPosOffset.x != 0f) { leftHandData.targetHandIKPos += leftHandTargetTrfm.right * leftHandData.targetHandIKPosOffset.x; }
                    if (leftHandData.targetHandIKPosOffset.y != 0f) { leftHandData.targetHandIKPos += leftHandTargetTrfm.up * leftHandData.targetHandIKPosOffset.y; }
                    if (leftHandData.targetHandIKPosOffset.z != 0f) { leftHandData.targetHandIKPos += leftHandTargetTrfm.forward * leftHandData.targetHandIKPosOffset.z; }

                    // Add local space rotation if required
                    leftHandData.targetHandIKRot *= Quaternion.Euler(leftHandData.targetHandIKRotMod);

                    if (leftHandTrfm != null)
                    {
                        // TODO - this may not be correct and will need to be tested. Look at HeadIK methods...
                        //if (isReset || leftHandData.prevHandIKPos == Vector3.zero) { leftHandData.prevHandIKPos = leftHandTrfm.position + leftHandTrfm.forward; }

                        if (isReset || leftHandData.prevHandIKPos == Vector3.zero)
                        {
                            if (leftHandData.lastKnownHandPos != Vector3.zero && isReset) { leftHandData.prevHandIKPos = leftHandData.lastKnownHandPos; }
                            else
                            {
                                leftHandData.prevHandIKPos = leftHandTrfm.position;
                                leftHandData.lastKnownHandPos = leftHandData.prevHandIKPos;
                            }
                        }

                        if (isReset || leftHandData.prevHandIKRot == Quaternion.identity) { leftHandData.prevHandIKRot = leftHandTrfm.rotation; }
                    }
                    else
                    {
                        leftHandData.prevHandIKPos = leftHandData.targetHandIKPos;
                        leftHandData.prevHandIKRot = leftHandData.targetHandIKRot;
                    }
                }
            }
            else
            {
                leftHandTargetTrfm = null;
                leftHandData.targetHandIKPos = Vector3.zero;
                leftHandData.targetHandIKRot = Quaternion.identity;
                leftHandData.targetHandIKPosOffset = Vector3.zero;
                leftHandData.targetHandIKRotMod = Vector3.zero;
                // TODO - check - this looks wrong should one of these be leftHandTrfm.position + leftHandTrfm.forward ??
                leftHandData.prevHandIKPos = isReset ? Vector3.zero : leftHandData.targetHandIKPos;
                leftHandData.prevHandIKRot = isReset ? Quaternion.identity : leftHandData.targetHandIKRot;
            }
        }

        /// <summary>
        /// Set the Left Hand target to be the interactive-enabled object the character is currently looking toward.
        /// If not interactive-enabled object is being looked at, the existing target is set to null.
        /// </summary>
        public void SetLeftHandIKTargetLookingAtInteractive()
        {
            // Are we currently looking at an interactive-enabled object?
            if (CheckLookingAtInteractive())
            {
                SetLeftHandIKTargetInteractive(lookingAtInteractive, false, true);
            }
            else
            {
                SetLeftHandIKTargetInteractive(null, false, true);
            }
        }

        /// <summary>
        /// Set the left hand target to be an interactive-enabled object in the scene.
        /// The object must be touchable.
        /// Invoke custom callbackOnChangeInteractiveTarget method if required.
        /// WARNING: If this is called directly, or indirectly from stickyInteractive.StopTouchObject(..)
        /// you MUST set isNotifyStopTouchingOnNull as false, to avoid a StackOverflowException due to a
        /// recursive loop.
        /// </summary>
        /// <param name="stickyInteractive"></param>
        /// <param name="isSecondaryHandHold"></param>
        /// <param name="isNotifyStopTouchingOnNull"></param>
        public void SetLeftHandIKTargetInteractive(StickyInteractive stickyInteractive, bool isSecondaryHandHold, bool isNotifyStopTouchingOnNull = true)
        {
            // Get out quick if S3D not initialised
            if (!isInitialised) { return; }

            StickyInteractive oldTarget = leftHandTargetInteractive;
            int oldTargetInteractiveID = oldTarget == null ? StickyInteractive.NoID : oldTarget.StickyInteractiveID;
            int newTargetInteractiveID = stickyInteractive == null ? StickyInteractive.NoID : stickyInteractive.StickyInteractiveID;

            if (stickyInteractive == null)
            {
                // We must be no longer touching any previous objects
                if (isNotifyStopTouchingOnNull && leftHandTargetInteractive != null && leftHandTargetInteractive.IsTouchable)
                {
                    leftHandTargetInteractive.StopTouchingObject(StickyID);
                }

                // Reset
                HandIKResetInteractiveTarget(true);
            }
            // Check if the character is already attempting to touch this interactive-enabled object
            else if (leftHandTargetInteractive == null || leftHandTargetInteractive.StickyInteractiveID != lookingAtInteractiveId)
            {
                // Is it still touchable?
                if (stickyInteractive.IsTouchable)
                {
                    // We must be no longer touching any previous objects
                    if (leftHandTargetInteractive != null && leftHandTargetInteractive.IsTouchable)
                    {
                        leftHandTargetInteractive.StopTouchingObject(StickyID);
                    }

                    leftHandTargetInteractive = stickyInteractive;

                    // If the hand is not currently reaching towards the previous target reset things for the new target.
                    bool isReachingToOldtarget = rightHandData == null || rightHandData.currentHandIKWeight == 0f ? false : true;

                    if (isSecondaryHandHold)
                    {
                        SetLeftHandIKTarget(stickyInteractive.transform, stickyInteractive.handHold2Offset, stickyInteractive.handHold2Rotation, !isReachingToOldtarget);
                    }
                    else
                    {
                        SetLeftHandIKTarget(stickyInteractive.transform, stickyInteractive.handHold1Offset, stickyInteractive.handHold1Rotation, !isReachingToOldtarget);
                    }
                }
            }

            // If the StickyInteractive target has been changed call the callback if it has been set
            if (callbackOnChangeInteractiveTarget != null &&
                ((oldTarget == null && stickyInteractive != null) ||
                 (oldTarget != null && stickyInteractive == null) ||
                  oldTargetInteractiveID != newTargetInteractiveID)
               )
            {
                callbackOnChangeInteractiveTarget(this, oldTarget, stickyInteractive);
            }
        }

        /// <summary>
        /// Set the maximum distance the left hand will attempt to reach for an object.
        /// </summary>
        /// <returns></returns>
        public void SetLeftHandMaxReachDistance(float newReachDistance)
        {
            handIKLHMaxReachDist = newReachDistance;

            if (isInitialised && isHandIK) { leftMaxArmReachDistance = HandIKGetMaxReachDistance(AvatarIKGoal.LeftHand); }
        }

        /// <summary>
        /// Change the world space position of where the right hand should be reaching toward
        /// </summary>
        /// <param name="targetPosition"></param>
        public void SetRightHandIKTarget(Vector3 targetPosition)
        {
            if (rightHandData == null) { rightHandData = new S3DHandData() { hand = AvatarIKGoal.RightHand }; }
            rightHandData.targetHandIKPos = targetPosition;
        }

        /// <summary>
        /// Change the object that the right hand should reach toward.
        /// EXAMPLE: SetRightHandIKTarget (myTargetObject)
        /// </summary>
        /// <param name="targetTransform"></param>
        public void SetRightHandIKTarget(Transform targetTransform)
        {
            SetRightHandIKTarget(targetTransform, Vector3.zero, Vector3.zero, false);
        }

        /// <summary>
        /// Change the object the the right hand should reach toward with a local space offset and rotation from the object.
        /// EXAMPLE: SetRightHandIKTarget (myTargetObject, new Vector3(0f, 0.5f, 0f), new Vector3(0f, 30f, 0f), false)
        /// </summary>
        /// <param name="targetTransform"></param>
        /// <param name="targetOffset"></param>
        /// <param name="isReset"></param>
        public void SetRightHandIKTarget(Transform targetTransform, Vector3 targetOffset, Vector3 targetRotation, bool isReset = false)
        {
            if (rightHandData == null) { rightHandData = new S3DHandData() { hand = AvatarIKGoal.RightHand }; }

            if (targetTransform != null)
            {
                // Only set the target transform if it has changed
                if (rightHandTargetTrfm == null || targetTransform.GetInstanceID() != rightHandTargetTrfm.GetInstanceID())
                {
                    rightHandTargetTrfm = targetTransform;
                    rightHandData.targetHandIKPosOffset = targetOffset;
                    rightHandData.targetHandIKRotMod = targetRotation;
                    rightHandData.targetHandIKPos = targetTransform.position;
                    rightHandData.targetHandIKRot = targetTransform.rotation;

                    // Add local space offset if required
                    if (rightHandData.targetHandIKPosOffset.x != 0f) { rightHandData.targetHandIKPos += rightHandTargetTrfm.right * rightHandData.targetHandIKPosOffset.x; }
                    if (rightHandData.targetHandIKPosOffset.y != 0f) { rightHandData.targetHandIKPos += rightHandTargetTrfm.up * rightHandData.targetHandIKPosOffset.y; }
                    if (rightHandData.targetHandIKPosOffset.z != 0f) { rightHandData.targetHandIKPos += rightHandTargetTrfm.forward * rightHandData.targetHandIKPosOffset.z; }

                    // Add local space rotation if required
                    rightHandData.targetHandIKRot *= Quaternion.Euler(rightHandData.targetHandIKRotMod);

                    if (rightHandTrfm != null)
                    {
                        // TODO - this may not be correct and will need to be tested. Look at HeadIK methods...
                        //if (isReset || rightHandData.prevHandIKPos == Vector3.zero) { rightHandData.prevHandIKPos = rightHandTrfm.position + rightHandTrfm.forward; }
                        //if (isReset || rightHandData.prevHandIKRot == Quaternion.identity) { rightHandData.prevHandIKRot = rightHandTrfm.rotation; }

                        // 1.0.4 Testing
                        if (isReset || rightHandData.prevHandIKPos == Vector3.zero)
                        {
                            if (rightHandData.lastKnownHandPos != Vector3.zero && isReset) { rightHandData.prevHandIKPos = rightHandData.lastKnownHandPos; }
                            else
                            {
                                rightHandData.prevHandIKPos = rightHandTrfm.position;
                                rightHandData.lastKnownHandPos = rightHandData.prevHandIKPos;
                            }
                        }
                        if (isReset || rightHandData.prevHandIKRot == Quaternion.identity) { rightHandData.prevHandIKRot = rightHandTrfm.rotation; }
                    }
                    else
                    {
                        rightHandData.prevHandIKPos = rightHandData.targetHandIKPos;
                        rightHandData.prevHandIKRot = rightHandData.targetHandIKRot;
                    }
                }
            }
            else
            {
                rightHandTargetTrfm = null;
                rightHandData.targetHandIKPos = Vector3.zero;
                rightHandData.targetHandIKRot = Quaternion.identity;
                rightHandData.targetHandIKPosOffset = Vector3.zero;
                rightHandData.targetHandIKRotMod = Vector3.zero;
                // TODO - check - this looks wrong should one of these be rightHandTrfm.position + rightHandTrfm.forward ??
                rightHandData.prevHandIKPos = isReset ? Vector3.zero : rightHandData.targetHandIKPos;
                rightHandData.prevHandIKRot = isReset ? Quaternion.identity : rightHandData.targetHandIKRot;
            }
        }

        /// <summary>
        /// Set the Right Hand target to be the interactive-enabled object the character is currently looking toward.
        /// If not interactive-enabled object is being looked at, the existing target is set to null.
        /// </summary>
        public void SetRightHandIKTargetLookingAtInteractive()
        {
            // Are we currently looking at an interactive-enabled object?
            if (CheckLookingAtInteractive())
            {
                SetRightHandIKTargetInteractive(lookingAtInteractive, false, true);
            }
            else
            {
                SetRightHandIKTargetInteractive(null, false, true);
            }
        }

        /// <summary>
        /// Set the right hand target to be an interactive-enabled object in the scene.
        /// The object must be touchable.
        /// Invoke custom callbackOnChangeInteractiveTarget method if required.
        /// WARNING: If this is called directly, or indirectly from stickyInteractive.StopTouchObject
        /// you MUST set isNotifyStopTouchingOnNull as false, to avoid a StackOverflowException due to a
        /// recursive loop.
        /// </summary>
        /// <param name="stickyInteractive"></param>
        /// <param name="isSecondaryHandHold"></param>
        /// <param name="isNotifyStopTouchingOnNull">Set to false if called directly or indirectly from stickyInteractive.StopTouchObject(..)</param>
        public void SetRightHandIKTargetInteractive(StickyInteractive stickyInteractive, bool isSecondaryHandHold, bool isNotifyStopTouchingOnNull = true)
        {
            // Get out quick if S3D not initialised
            if (!isInitialised) { return; }

            StickyInteractive oldTarget = rightHandTargetInteractive;
            int oldTargetInteractiveID = oldTarget == null ? StickyInteractive.NoID : oldTarget.StickyInteractiveID;
            int newTargetInteractiveID = stickyInteractive == null ? StickyInteractive.NoID : stickyInteractive.StickyInteractiveID;

            if (stickyInteractive == null)
            {
                // We must be no longer touching any previous objects
                if (isNotifyStopTouchingOnNull && rightHandTargetInteractive != null)
                {
                    if (rightHandTargetInteractive.IsTouchable)
                    {
                        rightHandTargetInteractive.StopTouchingObject(StickyID);
                    }
                }

                HandIKResetInteractiveTarget(false);
            }
            // Check if the character is already attempting to touch this interactive-enabled object
            else if (rightHandTargetInteractive == null || rightHandTargetInteractive.StickyInteractiveID != lookingAtInteractiveId)
            {
                // Is it still touchable?
                if (stickyInteractive.IsTouchable)
                {
                    // We must be no longer touching any previous objects
                    if (rightHandTargetInteractive != null && rightHandTargetInteractive.IsTouchable)
                    {
                        rightHandTargetInteractive.StopTouchingObject(StickyID);
                    }

                    rightHandTargetInteractive = stickyInteractive;

                    // If the hand is not currently reaching towards the previous target reset things for the new target.
                    bool isReachingToOldtarget = rightHandData == null || rightHandData.currentHandIKWeight == 0f ? false : true;

                    if (isSecondaryHandHold)
                    {
                        SetRightHandIKTarget(stickyInteractive.transform, stickyInteractive.handHold2Offset, stickyInteractive.handHold2Rotation, !isReachingToOldtarget);
                    }
                    else
                    {
                        SetRightHandIKTarget(stickyInteractive.transform, stickyInteractive.handHold1Offset, stickyInteractive.handHold1Rotation, !isReachingToOldtarget);
                    }
                }
            }

            // If the StickyInteractive target has been changed call the callback if it has been set
            if (callbackOnChangeInteractiveTarget != null &&
                ((oldTarget == null && stickyInteractive != null) ||
                 (oldTarget != null && stickyInteractive == null) ||
                  oldTargetInteractiveID != newTargetInteractiveID)
               )
            {
                callbackOnChangeInteractiveTarget(this, oldTarget, stickyInteractive);
            }
        }

        /// <summary>
        /// Set the maximum distance the right hand will attempt to reach for an object.
        /// </summary>
        /// <returns></returns>
        public void SetRightHandMaxReachDistance(float newReachDistance)
        {
            handIKRHMaxReachDist = newReachDistance;

            if (isInitialised && isHandIK) { rightMaxArmReachDistance = HandIKGetMaxReachDistance(AvatarIKGoal.RightHand); }
        }

        /// <summary>
        /// If Hand IK is currently being smoothly disabled over several frames,
        /// this attempts to reverse Hand IK to being smoothly enabled.
        /// </summary>
        public void StopHandIKDisable()
        {
            if (isHandIK && isAnimateEnabled && isHandIKSmoothDisable)
            {
                isHandIKSmoothDisable = false;
                isHandIKSmoothEnable = true;
            }
        }

        /// <summary>
        /// Attempt to turn on or off Hand IK (Inverse Kinematics).
        /// Smoothly enable or disable Hand IK.
        /// </summary>
        public void ToggleEnableHandIK()
        {
            EnableOrDisableHandIK(!isHandIK, false, true);
        }

        #endregion

        #region Public API Methods - Animate (Hand VR)

        /// <summary>
        /// Disable Hand VR Animation
        /// </summary>
        public void DisableHandVR()
        {
            EnableOrDisableHandVR(false, false);
        }

        /// <summary>
        /// Enable Hand VR animation.
        /// </summary>
        public void EnableHandVR()
        {
            EnableOrDisableHandVR(true, false);
        }

        #endregion

        #region Public API Methods - Animate (Foot IK)

        /// <summary>
        /// Disable Foot Inverse Kinematics. This is currently in Technical Preview.
        /// </summary>
        public void DisableFootIK()
        {
            EnableOrDisableFootIK(false, false);
        }

        /// <summary>
        /// Enable Foot Inverse Kinematics. This is currently in Technical Preview.
        /// </summary>
        public void EnableFootIK()
        {
            EnableOrDisableFootIK(true, false);
        }

        /// <summary>
        /// Get the world space position of the current left foot IK position (if any).
        /// Otherwise return 0,0,0.
        /// </summary>
        /// <returns></returns>
        public Vector3 GetLeftFootIKPosition()
        {
            if (isAnimateEnabled && isFootIK)
            {
                return leftFootData.currentFootIKPos;
            }
            else { return Vector3.zero; }
        }

        /// <summary>
        /// Get the world space position of the current right foot IK position (if any).
        /// Otherwise return 0,0,0.
        /// </summary>
        /// <returns></returns>
        public Vector3 GetRightFootIKPosition()
        {
            if (isAnimateEnabled && isFootIK)
            {
                return rightFootData.currentFootIKPos;
            }
            else { return Vector3.zero; }
        }

        #endregion

        #region Public API Methods - Animate (Ragdoll)

        /// <summary>
        /// Attempt to get and set the bones used to create a ragdoll.
        /// Only applies to valid humanoid rigs.
        /// </summary>
        public void ConfigureRagdollBones()
        {
            if (IsValidHumanoid(false))
            {
                if (ragdollBoneList == null)
                {
                    ragdollBoneList = new List<S3DHumanBonePersist>(13);
                }
                else { ragdollBoneList.Clear(); }

                ragdollBoneList.Add(new S3DHumanBonePersist(HumanBodyBones.Hips, defaultAnimator.GetBoneTransform(HumanBodyBones.Hips)));
                ragdollBoneList.Add(new S3DHumanBonePersist(HumanBodyBones.Chest, defaultAnimator.GetBoneTransform(HumanBodyBones.Chest)));
                ragdollBoneList.Add(new S3DHumanBonePersist(HumanBodyBones.Head, defaultAnimator.GetBoneTransform(HumanBodyBones.Head)));
                ragdollBoneList.Add(new S3DHumanBonePersist(HumanBodyBones.LeftUpperArm, defaultAnimator.GetBoneTransform(HumanBodyBones.LeftUpperArm)));
                ragdollBoneList.Add(new S3DHumanBonePersist(HumanBodyBones.LeftLowerArm, defaultAnimator.GetBoneTransform(HumanBodyBones.LeftLowerArm)));
                ragdollBoneList.Add(new S3DHumanBonePersist(HumanBodyBones.LeftHand, defaultAnimator.GetBoneTransform(HumanBodyBones.LeftHand)));
                ragdollBoneList.Add(new S3DHumanBonePersist(HumanBodyBones.RightUpperArm, defaultAnimator.GetBoneTransform(HumanBodyBones.RightUpperArm)));
                ragdollBoneList.Add(new S3DHumanBonePersist(HumanBodyBones.RightLowerArm, defaultAnimator.GetBoneTransform(HumanBodyBones.RightLowerArm)));
                ragdollBoneList.Add(new S3DHumanBonePersist(HumanBodyBones.RightHand, defaultAnimator.GetBoneTransform(HumanBodyBones.RightHand)));
                ragdollBoneList.Add(new S3DHumanBonePersist(HumanBodyBones.LeftUpperLeg, defaultAnimator.GetBoneTransform(HumanBodyBones.LeftUpperLeg)));
                ragdollBoneList.Add(new S3DHumanBonePersist(HumanBodyBones.LeftLowerLeg, defaultAnimator.GetBoneTransform(HumanBodyBones.LeftLowerLeg)));
                ragdollBoneList.Add(new S3DHumanBonePersist(HumanBodyBones.LeftFoot, defaultAnimator.GetBoneTransform(HumanBodyBones.LeftFoot)));
                ragdollBoneList.Add(new S3DHumanBonePersist(HumanBodyBones.RightUpperLeg, defaultAnimator.GetBoneTransform(HumanBodyBones.RightUpperLeg)));
                ragdollBoneList.Add(new S3DHumanBonePersist(HumanBodyBones.RightLowerLeg, defaultAnimator.GetBoneTransform(HumanBodyBones.RightLowerLeg)));
                ragdollBoneList.Add(new S3DHumanBonePersist(HumanBodyBones.RightFoot, defaultAnimator.GetBoneTransform(HumanBodyBones.RightFoot)));
            }
        }

        /// <summary>
        /// Attempt to disable the ragdoll
        /// </summary>
        public void DisableRagdoll()
        {
            EnableOrDisableRagdoll(false);
        }

        /// <summary>
        /// Attempt to enable the ragdoll
        /// </summary>
        public void EnableRagdoll()
        {
            EnableOrDisableRagdoll(true);
        }

        /// <summary>
        /// Get the length of a bone
        /// </summary>
        /// <param name="humanBoneTfrm"></param>
        /// <param name="childBoneTfrm"></param>
        /// <param name="boneAxis"></param>
        /// <param name="boneLength"></param>
        public void GetBoneLength (Transform humanBoneTfrm, Transform childBoneTfrm, out int boneAxis, out float boneLength)
        {
            if (humanBoneTfrm != null && childBoneTfrm != null)
            {
                S3DMath.LongestAxis(S3DUtils.GetLocalSpacePosition(humanBoneTfrm, childBoneTfrm.position), out boneAxis, out boneLength);
                //S3DMath.LongestAxis(humanBoneTfrm.InverseTransformPoint(childBoneTfrm.position), out boneAxis, out boneLength);
            }
            else
            {
                boneAxis = 0;
                boneLength = 0f;
            }
        }

        /// <summary>
        /// Find the persistent bone in the list of ragdoll bones
        /// </summary>
        /// <param name="humanBodyBone"></param>
        /// <returns></returns>
        public S3DHumanBonePersist GetRagdollBone (HumanBodyBones humanBodyBone)
        {
            int boneIndex = GetRagdollBoneIndex(humanBodyBone);

            if (boneIndex < 0) { return null; }
            else { return ragdollBoneList[boneIndex]; }
        }

        /// <summary>
        /// Find the index of the bone in the list of ragdoll bones.
        /// Returns -1 if not found.
        /// </summary>
        /// <param name="humanBodyBone"></param>
        /// <returns></returns>
        public int GetRagdollBoneIndex (HumanBodyBones humanBodyBone)
        {
            int boneIdx = -1;

            List<S3DHumanBonePersist> bones = ragdollBoneList;

            int numBones = bones == null ? 0 : bones.Count;

            for (int bIdx = 0; bIdx < numBones; bIdx++)
            {
                S3DHumanBonePersist s3dBone = bones[bIdx];
                if (s3dBone.bone == humanBodyBone)
                {
                    boneIdx = bIdx;
                    break;
                }
            }

            return boneIdx;
        }

        /// <summary>
        /// Attempt to find the persistent bone in the list of ragdoll bones, and return the boneTransform.
        /// </summary>
        /// <param name="humanBodyBone"></param>
        /// <returns></returns>
        public Transform GetRagdollBoneTransform (HumanBodyBones humanBodyBone)
        {
            S3DHumanBonePersist humanBonePersist = GetRagdollBone(humanBodyBone);

            if (humanBonePersist != null) { return humanBonePersist.boneTransform; }
            else { return null; }
        }

        /// <summary>
        /// Set a list of bones used for the ragdoll feature.
        /// </summary>
        /// <param name="newRagdollBones"></param>
        public void SetRagdollBones (List<S3DHumanBonePersist> newRagdollBones)
        {
            if (newRagdollBones == null)
            {
                if (ragdollBoneList != null)
                {
                    ragdollBoneList.Clear();
                }
                numRagdollBones = 0;
            }
            else
            {
                if (ragdollBoneList != null)
                {
                    ragdollBoneList.Clear();
                    ragdollBoneList.AddRange(newRagdollBones);
                }
                else
                {
                    ragdollBoneList = newRagdollBones;
                }

                numRagdollBones = ragdollBoneList.Count;
            }
        }

        #endregion

        #region Public API Methods - Engage (General)

        /// <summary>
        /// Remove the record of the instance ID of an active StickyPopupModule that was directly or indirectly opened by this character.
        /// See also ClearActivePopups(), GetActivePopups(), IsActivePopup(..), IsActivePopups(), SeActivePopup(..).
        /// </summary>
        /// <param name="instanceID"></param>
        public void ClearActivePopup (int instanceID)
        {
            popupActiveInstanceIDs.Remove(instanceID);
        }

        /// <summary>
        /// Remove or clear ALL the record of any active StickyPopupModules that where directly or indirectly opened by this character.
        /// See also ClearActivePopup(..), GetActivePopups(), IsActivePopup(..), IsActivePopups(), SeActivePopup(..).
        /// </summary>
        public void ClearActivePopups()
        {
            popupActiveInstanceIDs.Clear();
        }

        /// <summary>
        /// Drop the interactive-enabled object in the hand of the character.
        /// </summary>
        /// <param name="isLeftHand"></param>
        public void DropInteractive(bool isLeftHand)
        {
            DropInteractive(isLeftHand ? leftHandInteractive : rightHandInteractive, isLeftHand);
        }

        /// <summary>
        /// Attempt to engage with first sockets, then interactive-enabled objects that the character
        /// is looking toward. Look at Interactive and/or Sockets must be enabled to take any action.
        /// </summary>
        /// <param name="isLeftHand">Use the left hand, if applicable</param>
        public void EngageLookingAt (bool isLeftHand)
        {
            if (isLookSocketsEnabled && CheckLookingAtSocket())
            {
                EngageLookingAtSocket();
            }
            else if (isLookInteractiveEnabled)
            {
                EngageLookingAtInteractive(isLeftHand);
            }
        }

        /// <summary>
        /// Attempt to take action using a hand, based on what the
        /// interactive-enabled object the character is currently looking at.
        /// This will be based on what features are enabled on the object.
        /// Will clear any current target if not looking at an interactive-enabled object.
        /// </summary>
        public void EngageLookingAtInteractive (bool isLeftHand)
        {
            // Are we currently looking at an interactive-enabled object?
            if (CheckLookingAtInteractive())
            {
                bool isAttemptingToGrab = false;

                // When an item is grabbed it is automatically unselected
                if (lookingAtInteractive.IsSelectable)
                {
                    ToggleSelectLookedAtInteractive();
                }

                bool isActivablePriorityOverGrab = lookingAtInteractive.isActivablePriorityOverGrab && lookingAtInteractive.IsActivable;

                if (!isActivablePriorityOverGrab && lookingAtInteractive.IsGrabbable)
                {
                    // If it is not also touchable, immediately attempt to grab the object.
                    // The character could be out of hand reach and the object could "snap"
                    // into the hand.
                    if (!lookingAtInteractive.IsTouchable)
                    {
                        isAttemptingToGrab = true;
                        GrabLookedAtInteractive(isLeftHand, false);
                    }
                    // Touch is enabled and the hand is touching the object to grab
                    else if ((isLeftHand && leftHandData.isTouching) ||
                             (!isLeftHand && rightHandData.isTouching))
                    {
                        isAttemptingToGrab = true;
                        GrabLookedAtInteractive(isLeftHand, false);
                    }
                }

                // if attempting to grab, lookingAtInteractive may be null.
                if (!isAttemptingToGrab)
                {
                    if (lookingAtInteractive.IsTouchable)
                    {
                        if (isLeftHand) { SetLeftHandIKTargetInteractive(lookingAtInteractive, false, true); }
                        else { SetRightHandIKTargetInteractive(lookingAtInteractive, false, true); }
                    }
                    else if (isActivablePriorityOverGrab)
                    {
                        lookingAtInteractive.ToggleActivateObject(capsuleColliderId);
                    }
                    // Attempt to activate (or deactivate) an object that is not grabbable
                    // that is currently being looked at.
                    else if (lookingAtInteractive.IsActivable && !lookingAtInteractive.IsGrabbable)
                    {
                        lookingAtInteractive.ToggleActivateObject(capsuleColliderId);
                    }
                }
            }
            else
            {
                // If not looking at an interactive-enabled object, set the target to null
                if (isLeftHand) { SetLeftHandIKTargetInteractive(null, false, true); }
                else { SetRightHandIKTargetInteractive(null, false, true); }
            }
        }

        /// <summary>
        /// Attempt to take action based on what StickySocket the character is currently looking toward.
        /// </summary>
        public void EngageLookingAtSocket()
        {
            // Check if currently looking toward a StickySocket
            if (CheckLookingAtSocket())
            {
                // Ensure there isn't already a popup being displayed for this socket
                if (lookingAtSocket.GetActivePopupID() == 0)
                {
                    lookingAtSocket.SetPopupCamera(lookCamera1);
                    lookingAtSocket.HideSocket();
                    lookingAtSocket.ShowPopupFromCharacter(this);
                }
            }
        }

        /// <summary>
        /// Return the HashSet of Instance IDs of the active StickyPopupModules that were directly or indirectly opened by this character.
        /// See also ClearActivePopup(..), ClearActivePopups(), IsActivePopup(..), IsActivePopups(), SeActivePopup(..).
        /// </summary>
        /// <returns></returns>
        public HashSet<int> GetActivePopupIDs()
        {
            return popupActiveInstanceIDs;
        }

        /// <summary>
        /// Get the number of currently selected interactive-enabled objects in the scene.
        /// This does not verify if any of the objects have been destroyed.
        /// </summary>
        /// <returns></returns>
        public int GetNumberSelectedInteractive()
        {
            return numStoreSelectedInScene;
        }

        /// <summary>
        /// Get one of the interactive-enabled objects currently selected by the character, using
        /// the zero-based index of the items currently selected.
        /// This is NOT the StickyInteractiveID of the object itself.
        /// </summary>
        /// <param name="selectedIndex"></param>
        /// <returns></returns>
        public StickyInteractive GetSelectedInteractiveByIndex(int selectedIndex)
        {
            if (isInitialised && selectedIndex >= 0 && selectedIndex < numStoreSelectedInScene)
            {
                S3DStoreItem s3dStoreItem = selectedInSceneStoreItemList[selectedIndex];

                return s3dStoreItem == null ? null : s3dStoreItem.stickyInteractive;
            }
            else { return null; }
        }

        /// <summary>
        /// Get one of the interactive-enabled objects currently selected by the character, using
        /// the StoreItemID returned from AddSelectedInteractive(..).
        /// </summary>
        /// <param name="storeItemID"></param>
        /// <returns></returns>
        public StickyInteractive GetSelectedInteractiveByStoreItemID(int storeItemID)
        {
            if (isInitialised && storeItemID != 0)
            {
                StickyInteractive stickyInteractive = null;

                for (int sIdx = 0; sIdx < numStoreSelectedInScene; sIdx++)
                {
                    S3DStoreItem s3dStoreItem = selectedInSceneStoreItemList[sIdx];

                    if (s3dStoreItem != null && s3dStoreItem.StoreItemID == storeItemID)
                    {
                        stickyInteractive = s3dStoreItem.stickyInteractive;
                        break;
                    }
                }

                return stickyInteractive;
            }
            else { return null; }
        }

        /// <summary>
        /// Was the instanceID of a StickyPopupModules, directly or indirectly opened by this character?
        /// See also ClearActivePopup(..), ClearActivePopups(), GetActivePopups(), IsActivePopups(), SeActivePopup(..).
        /// </summary>
        /// <param name="instanceID"></param>
        /// <returns></returns>
        public bool IsActivePopup (int instanceID)
        {
            return popupActiveInstanceIDs.Contains(instanceID);
        }

        /// <summary>
        /// Are there any active StickyPopupModules displayed, that where directly or indirectly opened by this character?
        /// See also ClearActivePopup(..), ClearActivePopups(), GetActivePopups(), IsActivePopup(..), SeActivePopup(..).
        /// </summary>
        /// <returns></returns>
        public bool IsActivePopups()
        {
            return popupActiveInstanceIDs.Count > 0;
        }

        /// <summary>
        /// Return true if the faction of another character is a foe (enemy).
        /// Otherwise return false.
        /// </summary>
        /// <param name="otherFactionId"></param>
        /// <returns></returns>
        public bool IsFoe (int otherFactionId)
        {
            return IsFriendOrFoe(otherFactionId) == -1;
        }

        /// <summary>
        /// Return true if the faction of another character is a foe (enemy).
        /// Otherwise return false.
        /// </summary>
        /// <param name="otherCharacter"></param>
        /// <returns></returns>
        public bool IsFoe (StickyControlModule otherCharacter)
        {
            if (otherCharacter != null)
            {
                return IsFoe(otherCharacter.factionId);
            }
            else { return false; }
        }

        /// <summary>
        /// Return true if the faction of another character either neutral or friendly.
        /// Otherwise return false.
        /// </summary>
        /// <param name="otherFactionId"></param>
        /// <returns></returns>
        public bool IsFriend (int otherFactionId)
        {
            return IsFriendOrFoe(otherFactionId) != -1;
        }

        /// <summary>
        /// Return true if the faction of another character either neutral or friendly.
        /// Otherwise return false.
        /// </summary>
        /// <param name="otherCharacter"></param>
        /// <returns></returns>
        public bool IsFriend (StickyControlModule otherCharacter)
        {
            if (otherCharacter != null)
            {
                return IsFriend(otherCharacter.factionId);
            }
            else { return false; }
        }

        /// <summary>
        /// Return true if other faction is the same faction of this character AND
        /// the faction of this character is not neutral (0).
        /// </summary>
        /// <param name="otherFactionId"></param>
        /// <returns></returns>
        public bool IsFriendOnly (int otherFactionId)
        {
            return IsFriendOrFoe(otherFactionId) == 1;
        }

        /// <summary>
        /// Return true if other character is in the same faction AND
        /// the faction of either is not neutral (0).
        /// </summary>
        /// <param name="otherCharacter"></param>
        /// <returns></returns>
        public bool IsFriendOnly (StickyControlModule otherCharacter)
        {
            if (factionId != 0 && otherCharacter != null && IsFriendOnly(otherCharacter.factionId)) { return true; }
            else { return false; }
        }

        /// <summary>
        /// Given a factionId, return 1 if friend, 0 if neutral, or -1 if foe (enemy).
        /// </summary>
        /// <param name="otherFactionId"></param>
        /// <returns></returns>
        public int IsFriendOrFoe (int otherFactionId)
        {
            return otherFactionId == 0 ? 0 : otherFactionId == factionId ? 1 : -1;
        }

        /// <summary>
        /// Call this when you wish to remove any custom event listeners, like
        /// after creating them in code and then destroying the object.
        /// You could add this to your game play OnDestroy code.
        /// </summary>
        public void RemoveListeners()
        {
            if (isInitialised)
            {
                if (onInitialised != null) { onInitialised.RemoveAllListeners(); }
                if (onDestroyed != null) { onDestroyed.RemoveAllListeners(); }
                if (onInteractLookAtChanged != null) { onInteractLookAtChanged.RemoveAllListeners(); }
                if (onRespawned != null) { onRespawned.RemoveAllListeners(); }
                if (onRespawning != null) { onRespawning.RemoveAllListeners(); }
            }
        }

        /// <summary>
        /// Reinitialise the storage and selection of interactive-enabled objects.
        /// Also re-initialises Equip points and Stash (inventory)
        /// </summary>
        public void ReinitialiseStoreSettings()
        {
            if (storeMaxSelectableInScene > 0 && selectedInSceneStoreItemList == null) { selectedInSceneStoreItemList = new List<S3DStoreItem>(storeMaxSelectableInScene); }
            else if (selectedInSceneStoreItemList != null)
            {
                selectedInSceneStoreItemList.Clear();
            }

            numStoreSelectedInScene = selectedInSceneStoreItemList == null ? 0 : selectedInSceneStoreItemList.Count;

            ReinitialiseEquip();
            ReinitialiseStash();

            // FUTURE - consider dropping a objects in the hands without invoking callbacks or on[Event] items.
        }

        /// <summary>
        /// Select the interactive-enabled object currently being looked at (if any)
        /// </summary>
        public void SelectLookedAtInteractive()
        {
            // Can we select an interactive-enabled object, and are we currently looking at one?
            if (isInitialised && storeMaxSelectableInScene > 0 && numStoreSelectedInScene < storeMaxSelectableInScene && lookingAtInteractiveId != StickyInteractive.NoID)
            {
                // Check that it hasn't been destroyed
                if (lookingAtInteractive == null)
                {
                    RemoveSelectedInteractiveID(lookingAtInteractiveId);

                    // Cannot find it so assume character is no longer looking at it
                    lookingAtInteractiveId = StickyInteractive.NoID;
                }
                else if (!IsInteractiveIDSelected(lookingAtInteractiveId))
                {
                    int storeItemID = AddSelectedInteractive(lookingAtInteractive);

                    // Pass the StickyID of this character and the storeItemID of the selected item
                    lookingAtInteractive.SelectObject(StickyID, storeItemID);

                    // Check if the item acts more like a clickable button
                    if (lookingAtInteractive.IsAutoUnselect)
                    {
                        RemoveSelectedInteractiveID(lookingAtInteractiveId);
                    }
                }
            }
        }

        /// <summary>
        /// Select an interactive-enabled item in the scene
        /// </summary>
        /// <param name="stickyInteractive"></param>
        /// <returns></returns>
        public bool SelectInteractive(StickyInteractive stickyInteractive)
        {
            bool isSelected = false;

            if (isInitialised && storeMaxSelectableInScene > 0 && numStoreSelectedInScene < storeMaxSelectableInScene && stickyInteractive != null)
            {
                int storeItemID = AddSelectedInteractive(stickyInteractive);
                isSelected = storeItemID != S3DStoreItem.NoStoreItem;

                // Pass the StickyID of this character and the StoreItemID of the selected item.
                stickyInteractive.SelectObject(StickyID, storeItemID);

                // Check if the item acts more like a clickable button
                if (stickyInteractive.IsAutoUnselect)
                {
                    RemoveSelectedInteractiveID(stickyInteractive.StickyInteractiveID);
                    isSelected = false;
                }
            }

            return isSelected;
        }

        /// <summary>
        /// Set the instance ID of an active StickyPopupModule currently being displayed.
        /// See also GetActivePopupIDs().
        /// </summary>
        /// <param name="instanceID"></param>
        public void SetActivePopupID (int instanceID)
        {
            popupActiveInstanceIDs.Add(instanceID);
        }

        /// <summary>
        /// Set the colour typically used for when the character engages with an interactive-enabled
        /// object in the scene.
        /// </summary>
        /// <param name="newColour"></param>
        public void SetEngageColour(Color32 newColour)
        {
            engageColour = newColour;
        }

        /// <summary>
        /// The common interactive tags scriptableobject used to determine which interactive objects can be added to this character.
        /// See also Equip Points.
        /// </summary>
        /// <param name="newInteractiveTags"></param>
        public void SetInteractiveTags (S3DInteractiveTags newInteractiveTags)
        {
            interactiveTags = newInteractiveTags;
        }

        /// <summary>
        /// Set the colour typically used for when the character is not engaged with an interactive-enabled
        /// object in the scene.
        /// </summary>
        /// <param name="newColour"></param>
        public void SetNonEngageColour(Color32 newColour)
        {
            nonengageColour = newColour;
        }

        /// <summary>
        /// Change the amount of time the configured event methods are called
        /// after the character is initialised. This will have no effect after
        /// the character is initialised.
        /// </summary>
        /// <param name="newValue"></param>
        public void SetOnInitialisedEvtDelay(float newValue)
        {
            if (newValue >= 0f && newValue < 30f)
            {
                onInitialisedEvtDelay = newValue;
            }
        }

        /// <summary>
        /// Change the maximum number of interactive-enabled items that can
        /// selected in the scene at the same time. Valid values 0-5.
        /// NOTE: Doing this multiple times at runtime with isModifyCapacity true may impact GC.
        /// </summary>
        /// <param name="newValue"></param>
        public void SetStoreMaxSelectableInScene(int newValue, bool isModifyCapacity = false)
        {
            if (newValue >= 0 && newValue < 6 && newValue != storeMaxSelectableInScene)
            {
                if (selectedInSceneStoreItemList == null)
                {
                    selectedInSceneStoreItemList = new List<S3DStoreItem>(newValue);
                    storeMaxSelectableInScene = newValue;
                }

                // Expand the capacity of the selectable list
                if (newValue > 0 && newValue > storeMaxSelectableInScene)
                {
                    if (selectedInSceneStoreItemList != null)
                    {
                        if (isModifyCapacity && selectedInSceneStoreItemList.Capacity < newValue)
                        {
                            selectedInSceneStoreItemList.Capacity = newValue;
                            storeMaxSelectableInScene = newValue;
                        }
                    }
                }
                // Reduce the size of the selectable list
                else if (newValue < storeMaxSelectableInScene)
                {
                    while (selectedInSceneStoreItemList.Count > newValue)
                    {
                        // Trim the first selected item from the list
                        selectedInSceneStoreItemList.RemoveAt(0);
                    }

                    if (isModifyCapacity && selectedInSceneStoreItemList.Capacity > newValue)
                    {
                        selectedInSceneStoreItemList.Capacity = newValue;
                        storeMaxSelectableInScene = newValue;
                    }
                }
            }
        }

        /// <summary>
        /// If an interactive-enabled object is being held in the hand, drop it.
        /// Otherwise, if a grabbable object is the target, attempt to grab it
        /// using the primary hand hold on the object.
        /// If neither of the above is true, attempt to grab the object from a
        /// distance if they are currently looking at it (and it isn't Touchable).
        /// </summary>
        /// <param name="isLeftHand"></param>
        public void ToggleHoldInteractive(bool isLeftHand)
        {
            bool isHoldingObject = isLeftHand ? IsLeftHandHoldingInteractive : IsRightHandHoldingInteractive;

            if (isHoldingObject)
            {
                DropInteractive(isLeftHand ? leftHandInteractive : rightHandInteractive, isLeftHand);
            }
            // Grabbing an item in the hand has dependency on Hand IK and Animate config.
            else if (isInitialised && isAnimateEnabled && isHandIK)
            {
                StickyInteractive handTarget = isLeftHand ? leftHandTargetInteractive : rightHandTargetInteractive;

                if (handTarget != null)
                {
                    if (handTarget.IsGrabbable)
                    {
                        GrabInteractive(handTarget, isLeftHand, false);
                    }
#if UNITY_EDITOR
                    else
                    {
                        Debug.LogWarning("StickyControlModule - ToggleHoldInteractive - the interactive-enabled object, " + handTarget.name + ", cannot be grabbed by " + name);
                    }
#endif
                }
                // If the character is not currently targetting (reaching for) a touchable object,
                // check if they wish to grab (at a distance) a Grabble (but not touchable) object.
                else if (CheckLookingAtInteractive() && lookingAtInteractive.IsGrabbable && !lookingAtInteractive.IsTouchable)
                {
                    GrabInteractive(lookingAtInteractive, isLeftHand, false);
                }
#if UNITY_EDITOR
                else
                {
                    Debug.LogWarning("StickyControlModule - ToggleHoldInteractive - no Hand IK target assigned to " + (isLeftHand ? "left" : "right") + " hand on " + name);
                }
#endif
            }
#if UNITY_EDITOR
            else
            {
                Debug.LogWarning("StickyControlModule - ToggleHoldInteractive - Hand IK does not seem to be enabled or configured on " + name);
            }
#endif
        }

        /// <summary>
        /// Attempt to toggle a selectable interactive-enabled object on or off.
        /// </summary>
        /// <param name="stickyInteractive"></param>
        /// <returns></returns>
        public bool ToggleSelectInteractive(StickyInteractive stickyInteractive)
        {
            bool isSelected = false;

            if (isInitialised && storeMaxSelectableInScene > 0 && stickyInteractive != null)
            {
                int interactiveId = stickyInteractive.StickyInteractiveID;

                if (interactiveId != StickyInteractive.NoID)
                {
                    if (IsInteractiveIDSelected(interactiveId))
                    {
                        UnselectInteractive(stickyInteractive);
                    }
                    else
                    {
                        isSelected = SelectInteractive(stickyInteractive);
                    }
                }
            }

            return isSelected;
        }

        /// <summary>
        /// Attempt to select or unselect an interactive-enabled item in the scene that is being looked at
        /// </summary>
        public void ToggleSelectLookedAtInteractive()
        {
            if (isInitialised && storeMaxSelectableInScene > 0 && lookingAtInteractiveId != StickyInteractive.NoID)
            {
                // If selected, attempt to unselect it
                if (numStoreSelectedInScene > 0 && IsInteractiveIDSelected(lookingAtInteractiveId))
                {
                    UnselectLookedAtInteractive();
                }
                // If not selected, attempt to select it
                else
                {
                    SelectLookedAtInteractive();
                }
            }
        }

        /// <summary>
        /// Attempt to unselect or deselect an interactive-enabled item that is currently being looked at by this character
        /// </summary>
        public void UnselectLookedAtInteractive()
        {
            if (isInitialised && numStoreSelectedInScene > 0 && lookingAtInteractiveId != StickyInteractive.NoID)
            {
                // Check that it hasn't been destroyed
                if (lookingAtInteractive == null)
                {
                    RemoveSelectedInteractiveID(lookingAtInteractiveId);

                    // Cannot find it so assume character is no longer looking at it
                    lookingAtInteractiveId = StickyInteractive.NoID;
                }
                else if (IsInteractiveIDSelected(lookingAtInteractiveId))
                {
                    RemoveSelectedInteractiveID(lookingAtInteractiveId);
                    lookingAtInteractive.UnselectObject(StickyID);
                }
            }
        }

        /// <summary>
        /// Attempt to unselect or deselect an interactive-enabled item in the scene.
        /// Send notification to the object if it is unselected.
        /// Do NOT call this directly or indirectly from a onUnselected StickyInteractive event.
        /// </summary>
        /// <param name="stickyInteractive"></param>
        public void UnselectInteractive(StickyInteractive stickyInteractive)
        {
            if (isInitialised && numStoreSelectedInScene > 0 && stickyInteractive != null)
            {
                RemoveSelectedInteractiveID(stickyInteractive.StickyInteractiveID);

                stickyInteractive.UnselectObject(StickyID);
            }
        }

        /// <summary>
        /// Attempt to unselect or deselect and interactive-enabled item using the zero-based
        /// index of items currently selected by this character.
        /// Send notification to the object if it is unselected.
        /// Do NOT call this directly or indirectly from a onUnselected StickyInteractive event.
        /// </summary>
        /// <param name="selectedIndex"></param>
        public void UnselectInteractiveByIndex(int selectedIndex)
        {
            StickyInteractive stickyInteractive = GetSelectedInteractiveByIndex(selectedIndex);

            RemoveSelectedInteractiveIndex(selectedIndex);

            if (stickyInteractive != null)
            {
                stickyInteractive.UnselectObject(StickyID);
            }
        }

        /// <summary>
        /// Attempt to unselect or deselect and interactive-enabled item using the StoreItemID
        /// returned from AddSelectedInteractive(..)
        /// Send notification to the object if it is unselected.
        /// Do NOT call this directly or indirectly from a onUnselected StickyInteractive event.
        /// </summary>
        /// <param name="selectedStoreItemID"></param>
        public void UnselectInteractiveByStoreItemID(int selectedStoreItemID)
        {
            StickyInteractive stickyInteractive = GetSelectedInteractiveByIndex(selectedStoreItemID);

            RemoveSelectedInteractiveByStoreItemID(selectedStoreItemID);

            if (stickyInteractive != null)
            {
                stickyInteractive.UnselectObject(StickyID);
            }
        }

        #endregion

        #region Public API Methods - Engage (Damage)

        /// <summary>
        /// Add a damage region to character.
        /// Will return the index in the zero-based list, or -1 if it fails.
        /// </summary>
        /// <param name="damageRegion">The new damage region</param>
        /// <returns></returns>
        public int AddDamageRegion (S3DDamageRegion damageRegion)
        {
            if (damageRegion != null)
            {
                ValidateDamageRegions();

                damageRegionList.Add(damageRegion);

                numDamageRegions = damageRegionList.Count;

                return numDamageRegions - 1;
            }
            else { return -1; }
        }

        /// <summary>
        /// [INCOMPLETE]
        /// Add health to a specific S3DDamageRegion.
        /// If isAffectShield is true, and the health reaches the maximum configured, excess health will
        /// be applied to the shield for the specified DamageRegion.
        /// NOTE: -ve values are ignored. To incur damage use the ApplyNormalDamage or ApplyCollisionDamage
        /// API methods.
        /// </summary>
        /// <param name="damageRegion"></param>
        /// <param name="healthAmount">+ve to max 100.0</param>
        /// <param name="isAffectShield"></param>
        public void AddHealth(S3DDamageRegion damageRegion, float healthAmount, bool isAffectShield)
        {
            if (healthAmount > 0f && HasDamageRegion(damageRegion))
            {
                if (healthAmount > 100f) { healthAmount = 100f; }
                float startingHealth = damageRegion.startingHealth * 100f;

                // dmgHealth has range 0.0 to 100.0
                float dmgHealth = damageRegion.Health;
                if (dmgHealth < 0f) { dmgHealth = healthAmount; }
                else { dmgHealth += healthAmount; }

                if (dmgHealth > startingHealth)
                {
                    if (isAffectShield && damageRegion.useShielding)
                    {
                        float newShieldHealth = 0f;
                        // When shielding is -ve (e.g. -0.01 when it has been used up) set the shielding amount rather than adding it.
                        // Max value of ShieldHealth is shieldAmount.
                        if (damageRegion.ShieldHealth < 0f) { newShieldHealth = dmgHealth - startingHealth; }
                        else { newShieldHealth = damageRegion.ShieldHealth + dmgHealth - startingHealth; }

                        // Cap shielding to maximum permitted.
                        if (newShieldHealth > damageRegion.shieldingAmount) { newShieldHealth = damageRegion.shieldingAmount; }

                        damageRegion.ShieldHealth = newShieldHealth;
                    }

                    // Cap health to maximum permitted
                    dmgHealth = startingHealth;
                }

                damageRegion.Health = dmgHealth;
            }
        }

        /// <summary>
        /// Applies a specified amount of damage to the character damage region at a specified position.
        /// Always affects the main damage region.
        /// EXAMPLE: ApplyNormalDamage(damageRegion.DamageRegionId, damageValue, projectile.damageType, hitInfo.point)
        /// </summary>
        /// <param name="damageRegionId"></param>
        /// <param name="damageAmount"></param>
        /// <param name="damageType"></param>
        /// <param name="damagePosition"></param>
        public void ApplyNormalDamage(int damageRegionId, float damageAmount, S3DDamageRegion.DamageType damageType, Vector3 damagePosition)
        {
            //Debug.Log("[DEBUG] ApplyNormalDamage to " + name + " who was hit. T:" + Time.time);

            ApplyDamage(damageRegionId, damageAmount, damageType, damagePosition, false);
            // Remember that this was not collision damage
            //lastDamageWasCollisionDamage = false;
        }

        /// <summary>
        /// Copy the damage region multipliers from the given damage region
        /// to all other damage regions on this character.
        /// </summary>
        /// <param name="damageRegion"></param>
        public void CopyDamageMultipliersToAll (S3DDamageRegion damageRegion)
        {
            int _numDamageRegions = isInitialised ? numDamageRegions : NumberOfDamageRegions;

            if (_numDamageRegions > 1 && damageRegion != null && damageRegion.guidHash != 0)
            {
                // Ensure damage multipliers are initialised
                damageRegion.Initialise();

                S3DDamageRegion.DamageType[] damageTypes = (S3DDamageRegion.DamageType[])System.Enum.GetValues(typeof(S3DDamageRegion.DamageType));

                int numDamageTypes = damageTypes == null ? 0 : damageTypes.Length;
                float[] multiplierValue = new float[numDamageTypes];

                // Loop through the damage types (currently A-F). Skip Default damage type
                for (int dTypeIdx = 1; dTypeIdx < numDamageTypes; dTypeIdx++)
                {
                    //Put the damage multipliers for the region into an array of values
                    multiplierValue[dTypeIdx] = damageRegion.GetDamageMultiplier(damageTypes[dTypeIdx]);
                }

                for (int dmIdx = 0; dmIdx < _numDamageRegions; dmIdx++)
                {
                    S3DDamageRegion thisDamageRegion = damageRegionList[dmIdx];
                    if (thisDamageRegion != null && thisDamageRegion.guidHash != damageRegion.guidHash)
                    {
                        thisDamageRegion.Initialise();

                        // Loop through the A-F damage types (skip Default)
                        for (int dTypeIdx = 1; dTypeIdx < numDamageTypes; dTypeIdx++)
                        {
                            thisDamageRegion.SetDamageMultiplier(damageTypes[dTypeIdx], multiplierValue[dTypeIdx]);
                        }
                   }
                }
            }
        }

        /// <summary>
        /// Get the damage region with guidHash in the list of regions.
        /// See also GetDamageRegionByIndex().
        /// </summary>
        /// <param name="guidHash"></param>
        /// <returns></returns>
        public S3DDamageRegion GetDamageRegion (int guidHash)
        {
            S3DDamageRegion damageRegion = null;
            int _numDamageRegions = isInitialised ? numDamageRegions : NumberOfDamageRegions;

            if (guidHash != 0 && _numDamageRegions > 0)
            {
                // Attempt to find a matching guidHash
                for (int dmIdx = 0; dmIdx < _numDamageRegions; dmIdx++)
                {
                    if (damageRegionList[dmIdx].guidHash == guidHash)
                    {
                        damageRegion = damageRegionList[dmIdx]; break;
                    }
                }
            }

            return damageRegion;
        }

        /// <summary>
        /// Get the first damage region with a matching HumanBodyBone.
        /// This will never return the first (Main) damage region.
        /// </summary>
        /// <param name="humanBodyBone"></param>
        /// <returns></returns>
        public S3DDamageRegion GetDamageRegion (HumanBodyBones humanBodyBone)
        {
            S3DDamageRegion damageRegion = null;
            S3DHumanBonePersist bonePersist;

            int _numDamageRegions = isInitialised ? numDamageRegions : NumberOfDamageRegions;

            // Skip the Main damage region
            for (int dmIdx = 1; dmIdx < _numDamageRegions; dmIdx++)
            {
                bonePersist = damageRegionList[dmIdx].s3dHumanBonePersist;

                if (bonePersist != null && bonePersist.bone == humanBodyBone)
                {
                    damageRegion = damageRegionList[dmIdx]; break;
                }
            }

            return damageRegion;
        }

        /// <summary>
        /// Get a Damage Region from the zero-based index from the list.
        /// To get the main damage region, use damageIndex = 0.
        /// </summary>
        /// <param name="damageIndex"></param>
        /// <returns></returns>
        public S3DDamageRegion GetDamageRegionByIndex(int damageIndex)
        {
            if (damageIndex >= 0 && damageIndex < (isInitialised ? numDamageRegions : NumberOfDamageRegions))
            {
                return damageRegionList[damageIndex];
            }
            else { return null; }
        }

        /// <summary>
        /// Get a Damage Region by name. This will likely impact GC so don't use in an Update loop
        /// or get it each frame. Where possible, use GetDamageRegion() or GetDamageRegionByIndex().
        /// </summary>
        /// <param name="regionName">The case-sensitive name of the damage region</param>
        /// <returns></returns>
        public S3DDamageRegion GetDamageRegionIndexByName(string regionName)
        {
            if (string.IsNullOrEmpty(regionName) && damageRegionList != null)
            {
                // The Find will create GC for each S3DDamageRegion it searches
                // and each name string comparison.
                return damageRegionList.Find(dr => dr.name == regionName);
            }
            else { return null; }
        }

        /// <summary>
        /// Get the main (overall) damage region for the character.
        /// </summary>
        /// <returns></returns>
        public S3DDamageRegion GetMainDamageRegion()
        {
            if (!isInitialised)
            {
                ValidateDamageRegions();
                mainDamageRegion = damageRegionList[0];
            }

            return mainDamageRegion;
        }

        /// <summary>
        /// Get the unique ID of the main (overall) damage region for the character
        /// </summary>
        /// <returns></returns>
        public int GetMainDamageRegionID()
        {
            return isInitialised ? mainDamageRegion.guidHash : GetMainDamageRegion().guidHash;
        }

        /// <summary>
        /// Attempt to create a new damage region 
        /// </summary>
        /// <param name="humanBodyBone"></param>
        /// <returns></returns>
        public S3DDamageRegion GetOrCreateDamageRegion (HumanBodyBones humanBodyBone)
        {
            S3DDamageRegion damageRegion = GetDamageRegion(humanBodyBone);

            // If damage region does not already exist for this bone, create one
            if (damageRegion == null && IsValidHumanoid(false))
            {
                Transform boneTransform = defaultAnimator.GetBoneTransform(humanBodyBone);

                S3DHumanBonePersist s3dBonePersist = new S3DHumanBonePersist(humanBodyBone, boneTransform);

                if (s3dBonePersist != null)
                {
                    damageRegion = new S3DDamageRegion();
                    damageRegion.name = humanBodyBone.ToString();
                    damageRegion.s3dHumanBonePersist = s3dBonePersist;
                    AddDamageRegion(damageRegion);

                    S3DDamageRegionReceiver dmRgnReceiver = null;

                    if (boneTransform != null)
                    {
                        // If the component doesn't already exist, add it now
                        if (!boneTransform.gameObject.TryGetComponent(out dmRgnReceiver))
                        {
                            #if UNITY_EDITOR
                            dmRgnReceiver = UnityEditor.Undo.AddComponent<S3DDamageRegionReceiver>(boneTransform.gameObject);
                            #else
                            dmRgnReceiver = boneTransform.gameObject.AddComponent<S3DDamageRegionReceiver>();
                            #endif
                        }

                        dmRgnReceiver.stickyControlModule = this;
                        dmRgnReceiver.isValid = true;
                    }
                }
            }

            return damageRegion;
        }

        /// <summary>
        /// Does this character have a damage region with a matching HumanBodyBone?
        /// This will ignore the first (Main) damage region.
        /// </summary>
        /// <param name="humanBodyBone"></param>
        /// <returns></returns>
        public bool HasDamageRegion (HumanBodyBones humanBodyBone)
        {
            bool hasDamageRegion = false;
            S3DHumanBonePersist bonePersist;

            int _numDamageRegions = isInitialised ? numDamageRegions : NumberOfDamageRegions;

            // Skip the Main damage region
            for (int dmIdx = 1; dmIdx < _numDamageRegions; dmIdx++)
            {
                bonePersist = damageRegionList[dmIdx].s3dHumanBonePersist;

                if (bonePersist != null && bonePersist.bone == humanBodyBone)
                {
                    hasDamageRegion = true; break;
                }
            }

            return hasDamageRegion;
        }

        /// <summary>
        /// Does this character contain this damage region?
        /// </summary>
        /// <param name="damageRegion"></param>
        /// <returns></returns>
        public bool HasDamageRegion (S3DDamageRegion damageRegion)
        {
            if (damageRegion == null || damageRegion.guidHash == 0) { return false; }
            else if (!isInitialised) { ValidateDamageRegions(); }

            int guidHash = damageRegion.guidHash;
            int damageRegionIndex = -1;

            // Attempt to find a matching guidHash
            for (int dmIdx = 0; dmIdx < numDamageRegions; dmIdx++)
            {
                if (damageRegionList[dmIdx].guidHash == guidHash)
                {
                    damageRegionIndex = dmIdx; break;
                }
            }

            return damageRegionIndex >= 0;
        }

        /// <summary>
        /// Make the whole character invincible to damage.
        /// For individual damageRegions change the isInvisible value on the localised region.
        /// </summary>
        public void MakeCharacterInvincible()
        {
            if (!isInitialised)
            {
                ValidateDamageRegions();
                mainDamageRegion = damageRegionList[0];
            }

            mainDamageRegion.isInvincible = true;
        }

        /// <summary>
        /// Make the whole character vincible to damage. When hit, the character or shields will take damage.
        /// For individual damageRegions change the isInvisible value on the localised region.
        /// </summary>
        public void MakeCharacterVincible()
        {
            if (!isInitialised)
            {
                ValidateDamageRegions();
                mainDamageRegion = damageRegionList[0];
            }

            mainDamageRegion.isInvincible = false;
        }

        /// <summary>
        /// Initialise or reinitialise damage settings for this character.
        /// The Unity physics system will ignore all collisions between the
        /// main capsule collider and damage region colliders.
        /// IsColliderSelf(..) will return true for damage region colliders.
        /// </summary>
        public void ReinitialiseDamage()
        {
            ValidateDamageRegions();

            mainDamageRegion = damageRegionList[0];

            ResetLives();

            if (isInitialised) { ResetHealth(); }
            else
            {
                mainDamageRegion.ResetHealth();
                health = mainDamageRegion.startingHealth;
            }

            S3DDamageRegionReceiver damageRegionReceiver;

            damageRegionColliders.Clear();

            for (int drIdx = 1; drIdx < numDamageRegions; drIdx++)
            {
                S3DDamageRegion damageRegion = damageRegionList[drIdx];
                if (damageRegion != null)
                {
                    S3DHumanBonePersist s3dHumanBone = damageRegion.s3dHumanBonePersist;

                    if (s3dHumanBone != null && s3dHumanBone.boneTransform != null && s3dHumanBone.boneCollider != null)
                    {
                        s3dHumanBone.isValid = s3dHumanBone.guidHash != 0;
                        damageRegion.colliderId = s3dHumanBone.boneCollider.GetInstanceID();

                        // Ensure IsColliderSelf(..) will return true for this damage region collider.
                        damageRegionColliders.Add(damageRegion.colliderId);

                        // Ensure we don't have issues drawing the inspector in the editor while not in play mode
                        if (capsuleColliderId != 0)
                        {
                            // Prevent any physics interaction between the damage region collider and the main capsule
                            // collider when "Trigger Collider" is enabled on the Collide tab.
                            Physics.IgnoreCollision(capsuleCollider, s3dHumanBone.boneCollider, true);

                            s3dHumanBone.boneCollider.enabled = true;
                        }

                        // Update the reference in the S3DDamageRegionReceiver to the StickyControlModule
                        // for this character. This is used to detect hit damage
                        if (s3dHumanBone.boneTransform.TryGetComponent(out damageRegionReceiver))
                        {
                            damageRegionReceiver.stickyControlModule = this;
                            damageRegionReceiver.isValid = true;
                            damageRegionReceiver.damageRegionId = damageRegion.guidHash;
                        }
                    }
                    else
                    {
                        damageRegion.colliderId = 0;
                    }
                }
            }
        }

        /// <summary>
        /// Attempt to find a damage region and remove (delete) it from the list.
        /// It does not attempt to remove a collider that may be associated with the damage region.
        /// NOTE: The main damage region cannot be removed.
        /// </summary>
        /// <param name="damageRegion"></param>
        public void RemoveDamageRegion (S3DDamageRegion damageRegion)
        {
            if (damageRegion != null)
            {
                int _numDamageRegions = isInitialised ? numDamageRegions : NumberOfDamageRegions;

                // Skip the Main damage region
                for (int dmIdx = 1; dmIdx < _numDamageRegions; dmIdx++)
                {
                    if (damageRegionList[dmIdx].guidHash == damageRegion.guidHash)
                    {
                        damageRegionList.RemoveAt(dmIdx);
                        damageRegion = null;
                        numDamageRegions = damageRegionList.Count;
                        break;
                    }
                }
            }
        }

        /// <summary>
        /// Reset the health of the whole character.
        /// The character must be initialised.
        /// </summary>
        public void ResetHealth()
        {
            if (isInitialised)
            {
                // Reset health for each damage region
                for (int dmgIdx = 0; dmgIdx < numDamageRegions; dmgIdx++)
                {
                    damageRegionList[dmgIdx].ResetHealth();

                    if (dmgIdx == 0)
                    {
                        // Reset overall healh of the character
                        health = mainDamageRegion.startingHealth;
                    }
                }
            }
        }

        /// <summary>
        /// If not unlimited lives, set the currentLives back to the startingLives value.
        /// </summary>
        public void ResetLives()
        {
            // If there is not unlimited lives, set the number of lives available
            if (startLives >= 0) { currentLives = startLives; }
        }

        /// <summary>
        /// Set the (overall) health of the character.
        /// Values should be between 0.0 and 100.0
        /// </summary>
        /// <param name="newHealthValue"></param>
        public void SetHealth(float newHealthValue)
        {
            if (newHealthValue < 0.0001f) { health = 0f; }
            else if (newHealthValue > 100f) { health = 1f; }
            else { health = newHealthValue / 100f; }

            if (!isInitialised)
            {
                GetMainDamageRegion();
            }

            // Don't update the startHealth of the damage region
            // as we want to avoid an endless update loop in the editor.
            mainDamageRegion.SetHealth(health * 100f);
        }

        #endregion

        #region Public API Methods - Engage (Equip)

        /// <summary>
        /// Add a Equip Point to character.
        /// Will return the index in the zero-based list, or -1 if it fails.
        /// </summary>
        /// <param name="equipPoint"></param>
        /// <returns></returns>
        public int AddEquipPoint (S3DEquipPoint equipPoint)
        {
            if (equipPoint != null)
            {
                if (!isEquipInitialised) { ValidateEquipPoints(); }

                equipPointList.Add(equipPoint);

                numEquipPoints = equipPointList.Count;

                return numEquipPoints - 1;
            }
            else { return -1; }
        }

        /// <summary>
        /// Drop all the equipped items.
        /// </summary>
        public void DropEquipAll()
        {
            if (isEquipInitialised)
            {
                for (int eqptIdx = 0; eqptIdx < numEquipPoints; eqptIdx++)
                {
                    S3DEquipPoint equipPoint = equipPointList[eqptIdx];
                    int _numEquippedItems = equipPoint.storeItemList.Count;

                    // Drop starting from last in the list for this equip point
                    for (int siIdx = _numEquippedItems - 1; siIdx >= 0; siIdx--)
                    {
                        DropEquipItem(equipPoint.storeItemList[siIdx]);
                    }
                }
            }
        }

        /// <summary>
        /// Drop an interactive object currently equipped on the character.
        /// </summary>
        /// <param name="storeItemId"></param>
        public void DropEquipItem (int storeItemId)
        {
            if (storeItemId != S3DStoreItem.NoStoreItem)
            {
                DropEquipItem(GetEquipItem(storeItemId));
            }
        }

        /// <summary>
        /// Drop an interactive object currently equipped on the character.
        /// </summary>
        /// <param name="storeItem"></param>
        public void DropEquipItem (S3DStoreItem storeItem)
        {
            if (storeItem != null && storeItem.stickyInteractiveID != StickyInteractive.NoID)
            {
                StickyInteractive equippedItem = storeItem.stickyInteractive;

                // If the Equip operation hasn't been finalised and parented when it is dropped,
                // cancel the finalise operation so it doesn't attempt to run after the item is dropped.
                StopDelayEquip(equippedItem);

                DetachColliders(equippedItem.Colliders);

                // Get a random position and rotation near the character
                Vector3 placeRot = Vector3.zero;

                Vector3 placePos = GetRandomPositionXZ(radius + minEquipDropDistance, radius + maxEquipDropDistance);
                placePos.y = 0.5f;

                placeRot.y = miscS3DRandom.Range(0f, 360f);
                placeRot.z = miscS3DRandom.Range(-20f, 20f);

                equippedItem.transform.position = GetWorldPosition(placePos);
                equippedItem.transform.rotation = GetWorldRotation(Quaternion.Euler(placeRot));

                equippedItem.DropObject(capsuleColliderId);

                // Find the Equip Point it belongs to
                S3DEquipPoint equipPoint = FindEquipPoint(equippedItem.StickyInteractiveID);

                if (equipPoint != null)
                {
                    equipPoint.storeItemList.Remove(storeItem);
                }

                // finally, turn it back on
                if (!equippedItem.gameObject.activeSelf) { equippedItem.gameObject.SetActive(true); }
            }
        }

        /// <summary>
        /// Attempt to Equip an interactive-enabled object on the first available Equip Point,
        /// with the most recent item added to the socket that the character is looking toward.
        /// Returns the Equip Point StoreItemID or S3DStoreItem.NoStoreItem.
        /// </summary>
        /// <returns></returns>
        public int EquipFromLookAtSocket()
        {
            int storeItemID = S3DStoreItem.NoStoreItem;

            if (CheckLookingAtSocket())
            {
                storeItemID = EquipFromSocket(lookingAtSocket);
            }

            return storeItemID;
        }

        /// <summary>
        /// Attempt to Equip an interactive-enabled object on the first available Equip Point,
        /// with the most recent item added to the socket that the character is looking toward.
        /// </summary>
        public void EquipFromLookAtSocketNoReturn()
        {
            EquipFromLookAtSocket();
        }

        /// <summary>
        /// Attempt to Equip an interactive-enabled object on the first available and compatible Equip Point,
        /// with the most recent item added to the socket.
        /// Returns the Equip Point StoreItemID or S3DStoreItem.NoStoreItem.
        /// </summary>
        /// <returns></returns>
        public int EquipFromSocket (StickySocket stickySocket)
        {
            int storeItemID = S3DStoreItem.NoStoreItem;

            StickyInteractive lastAddedItem = stickySocket.GetLastInteractive();

            if (lastAddedItem != null)
            {
                if (lastAddedItem.IsEquippable)
                {
                    // Find first empty equip point
                    S3DEquipPoint equipPoint = GetFirstAvailableEquipPoint(lastAddedItem);

                    if (equipPoint != null)
                    {
                        if (lastAddedItem.CheckCanBeEquipped(this, equipPoint))
                        {
                            if (lassoSpeed > 0f)
                            {
                                lastAddedItem.IsLassoEnabled = true;
                                lastAddedItem.LassoSocket = stickySocket;
                                // Character and Equip Point are only required when
                                // going from the character to the socket.
                                lastAddedItem.LassoCharacter = null;
                                lastAddedItem.LassoEquipPoint = null;
                            }

                            stickySocket.RemoveInteractive(lastAddedItem.StickyInteractiveID, true, false);
                            storeItemID = EquipInteractiveInternal(lastAddedItem, equipPoint);

                            // If required, the Lasso coroutine is started in EquipInteractiveFinalise()
                            // as parenting may be delayed. Although, playing an animation with lasso is
                            // probably not compatible.
                        }
                    }
                    #if UNITY_EDITOR
                    else { Debug.LogWarning("StickyControlModule.EquipFromSocket " + name + " cannot equip " + lastAddedItem.name + " from " + stickySocket.name + " because there are no available compatible equip point slots"); }
                    #endif
                }
                #if UNITY_EDITOR
                else { Debug.LogWarning("StickyControlModule.EquipFromSocket " + name + " cannot equip " + lastAddedItem.name + " from " + stickySocket.name + " because it is not Equippable"); }
                #endif
            }

            return storeItemID;
        }

        /// <summary>
        /// Attempt to Equip an interactive-enabled object on the first available and compatible Equip Point,
        /// with the most recent item added to the socket.
        /// Same as EquipFromSocket(..),except can be called from a StickyInputModule custom input event.
        /// </summary>
        /// <param name="stickySocket"></param>
        public void EquipFromSocketNoReturn (StickySocket stickySocket)
        {
            EquipFromSocket(stickySocket);
        }

        /// <summary>
        /// Attempt to Equip an interactive-enabled object on the first available and compatible Equip Point.
        /// Equipped objects become unselected if they were previously selected.
        /// Return the Equip Point S3DStoreItem ID or S3DStoreItem.NoStoreItem
        /// </summary>
        /// <param name="itemToEquip"></param>
        public int EquipItem (StickyInteractive itemToEquip)
        {
            int storeItemID = S3DStoreItem.NoStoreItem;

            if (isInitialised && itemToEquip != null)
            {
                if (itemToEquip.IsEquippable)
                {
                    // Find first empty equip point
                    S3DEquipPoint equipPoint = GetFirstAvailableEquipPoint(itemToEquip);

                    if (equipPoint != null)
                    {
                        // If the interactive-enable object is already selected, remove it from the list
                        RemoveSelectedInteractiveID(itemToEquip.StickyInteractiveID);

                        storeItemID = EquipInteractiveInternal(itemToEquip, equipPoint);
                    }
                    #if UNITY_EDITOR
                    else { Debug.LogWarning("StickyControlModule.EquipItem " + name + " cannot equip " + itemToEquip.name + " because there are no available compatible equip point slots"); }
                    #endif
                }
                #if UNITY_EDITOR
                else { Debug.LogWarning("StickyControlModule.EquipItem " + name + " cannot equip " + itemToEquip.name + " because it is not Equippable"); }
                #endif
            }

            return storeItemID;
        }

        /// <summary>
        /// Attempt to Equip an interactive-enabled object on an EquipPoint.
        /// Equipped objects become unselected if they were previously selected.
        /// Return the Equip Point S3DStoreItemID or S3DStoreItem.NoStoreItem
        /// </summary>
        /// <param name="itemToEquip"></param>
        /// <param name="equipPoint"></param>
        /// <returns></returns>
        public int EquipItem (StickyInteractive itemToEquip, S3DEquipPoint equipPoint)
        {
            int storeItemID = S3DStoreItem.NoStoreItem;

            if (isInitialised && itemToEquip != null && itemToEquip.CheckCanBeEquipped(this, equipPoint))
            {
                // If the interactive-enable object is already selected, remove it from the list
                RemoveSelectedInteractiveID(itemToEquip.StickyInteractiveID);

                storeItemID = EquipInteractiveInternal(itemToEquip, equipPoint);
            }

            return storeItemID;
        }

        /// <summary>
        /// If the character is holding an interactive object in their left hand,
        /// attempt to parent it to the equip point using the zero-based index.
        /// Return the Equip Point StoreItemID or S3DStoreItem.NoStoreItem.
        /// </summary>
        /// <param name="equipPointIndex"></param>
        /// <returns></returns>
        public int EquipItemFromLeftHand (int equipPointIndex)
        {
            if (isEquipInitialised && leftHandInteractiveId != StickyInteractive.NoID)
            {
                int storeItemID = EquipItem(leftHandInteractive, GetEquipPointByIndex(equipPointIndex));

                if (storeItemID != S3DStoreItem.NoStoreItem) { ClearHoldingInteractive(true); }

                return storeItemID;
            }
            else { return S3DStoreItem.NoStoreItem; }
        }

        /// <summary>
        /// If the character is holding an interactive object in their right hand,
        /// attempt to parent it to the equip point using the zero-based index.
        /// Return the Equip Point StoreItemID or S3DStoreItem.NoStoreItem.
        /// </summary>
        /// <param name="equipPointIndex"></param>
        /// <returns></returns>
        public int EquipItemFromRightHand (int equipPointIndex)
        {
            if (isEquipInitialised && rightHandInteractiveId != StickyInteractive.NoID)
            {
                int storeItemID = EquipItem(rightHandInteractive, GetEquipPointByIndex(equipPointIndex));

                if (storeItemID != S3DStoreItem.NoStoreItem) { ClearHoldingInteractive(false); }

                return storeItemID;
            }
            else { return S3DStoreItem.NoStoreItem; }
        }

        /// <summary>
        /// Attempt to Equip an interactive-enabled object currently held in a hand onto the
        /// first available compatible Equip Point.
        /// Return the Equip Point S3DStoreItem ID or S3DStoreItem.NoStoreItem
        /// </summary>
        /// <param name="isLeftHand"></param>
        /// <returns></returns>
        public int EquipItemFromHand (bool isLeftHand)
        {
            int storeItemID = S3DStoreItem.NoStoreItem;

            // Is the character holding an interactive-enabled object?
            if (isEquipInitialised && ((isLeftHand && leftHandInteractiveId != StickyInteractive.NoID) || (!isLeftHand && rightHandInteractiveId != StickyInteractive.NoID)))
            {
                int equipPointIndex = GetFirstAvailableEquipPointIndex(isLeftHand ? leftHandInteractive : rightHandInteractive);

                if (equipPointIndex >= 0)
                {
                    if (isLeftHand)
                    {
                        storeItemID = EquipItemFromLeftHand(equipPointIndex);
                    }
                    else
                    {
                        storeItemID = EquipItemFromRightHand(equipPointIndex);
                    }
                }
                #if UNITY_EDITOR
                else { Debug.LogWarning("EquipItemFromHand - " + name + " has no available compatible Equip Points"); }
                #endif
            }

            return storeItemID;
        }

        /// <summary>
        /// Attempt to Equip an interactive-enabled object currently held in a hand onto the
        /// first available compatible Equip Point.
        /// This API is callable from inspector events. See also EquipItemFromHand(..).
        /// </summary>
        /// <param name="isLeftHand"></param>
        /// <returns></returns>
        public void EquipItemFromHandNoReturn (bool isLeftHand)
        {
            EquipItemFromHand(isLeftHand);
        }

        /// <summary>
        /// Attempt to Equip an interactive-enabled object on the first available compatible Equip Point.
        /// Equipped objects become unselected if they were previously selected.
        /// This API is callable from inspector events. See also EquipItem(..).
        /// </summary>
        /// <param name="itemToEquip"></param>
        public void EquipItemNoReturn (StickyInteractive itemToEquip)
        {
            EquipItem(itemToEquip);
        }

        /// <summary>
        /// If an interactive-enabled object is being looked at, attempt to equip
        /// it on the first available Equip Point.
        /// </summary>
        /// <returns></returns>
        public int EquipLookedAtInteractive()
        {
            int storeItemID = S3DStoreItem.NoStoreItem;

            if (lookingAtInteractiveId != StickyInteractive.NoID)
            {
                storeItemID = EquipItem(lookingAtInteractive);
            }

            return storeItemID;
        }

        /// <summary>
        /// If an interactive-enabled object is being looked at, attempt to equip
        /// it on the Equip Point provided.
        /// </summary>
        /// <param name="equipPoint"></param>
        /// <returns></returns>
        public int EquipLookedAtInteractive (S3DEquipPoint equipPoint)
        {
            int storeItemID = S3DStoreItem.NoStoreItem;

            if (lookingAtInteractiveId != StickyInteractive.NoID)
            {
                storeItemID = EquipItem(lookingAtInteractive, equipPoint);
            }

            return storeItemID;
        }

        /// <summary>
        /// If an interactive-enabled object is being looked at, attempt to equip
        /// it on the first available Equip Point.
        /// This API is callable from inspector events. See also EquipLookedAtInteractive(..).
        /// </summary>
        public void EquipLookedAtInteractiveNoReturn()
        {
            EquipLookedAtInteractive();
        }

        /// <summary>
        /// Attempt to find an equip point that has a given interactive
        /// object attached.
        /// </summary>
        /// <param name="stickyInteractiveID"></param>
        /// <returns></returns>
        public S3DEquipPoint FindEquipPoint (int stickyInteractiveID)
        {
            S3DEquipPoint equipPoint = null;

            if (isEquipInitialised && stickyInteractiveID != StickyInteractive.NoID)
            {
                for (int eqptIdx = 0; eqptIdx < numEquipPoints; eqptIdx++)
                {
                    S3DEquipPoint _equipPoint = equipPointList[eqptIdx];
                    for (int siIdx = 0; siIdx < _equipPoint.storeItemList.Count; siIdx++)
                    {
                        S3DStoreItem _storeItem = _equipPoint.storeItemList[siIdx];
                        if (_storeItem.stickyInteractiveID == stickyInteractiveID)
                        {
                            equipPoint = _equipPoint;
                            eqptIdx = numEquipPoints;
                            break;
                        }
                    }
                }
            }

            return equipPoint;
        }

        /// <summary>
        /// Attempt to find an equip point that has a given S3DStoreItem attached.
        /// </summary>
        /// <param name="storeItem"></param>
        /// <returns></returns>
        public S3DEquipPoint FindEquipPoint (S3DStoreItem storeItem)
        {
            S3DEquipPoint equipPoint = null;

            if (isEquipInitialised && storeItem != null)
            {
                int storeItemID = storeItem.StoreItemID;
                for (int eqptIdx = 0; eqptIdx < numEquipPoints; eqptIdx++)
                {
                    S3DEquipPoint _equipPoint = equipPointList[eqptIdx];
                    for (int siIdx = 0; siIdx < _equipPoint.storeItemList.Count; siIdx++)
                    {
                        S3DStoreItem _storeItem = _equipPoint.storeItemList[siIdx];
                        if (_storeItem.StoreItemID == storeItemID)
                        {
                            equipPoint = _equipPoint;
                            eqptIdx = numEquipPoints;
                            break;
                        }
                    }
                }
            }

            return equipPoint;
        }

        /// <summary>
        /// Get the S3DStoreItem attached to an equip point.
        /// </summary>
        /// <param name="storeItemId"></param>
        /// <returns></returns>
        public S3DStoreItem GetEquipItem (int storeItemId)
        {
            S3DStoreItem storeItem = null;

            if (isEquipInitialised)
            {
                for (int eqptIdx = 0; eqptIdx < numEquipPoints; eqptIdx++)
                {
                    S3DEquipPoint equipPoint = equipPointList[eqptIdx];
                    for (int siIdx = 0; siIdx < equipPoint.storeItemList.Count; siIdx++)
                    {
                        S3DStoreItem _storeItem = equipPoint.storeItemList[siIdx];
                        if (_storeItem.guidHash == storeItemId)
                        {
                            storeItem = _storeItem;
                            eqptIdx = numEquipPoints;
                            break;
                        }
                    }
                }
            }

            return storeItem;
        }

        /// <summary>
        /// Get a Equip Point using the unique guidHash.
        /// See also GetEquipPointByIndex()
        /// </summary>
        /// <param name="equipPointIndex"></param>
        /// <returns></returns>
        public S3DEquipPoint GetEquipPoint (int guidHash)
        {
            S3DEquipPoint equipPoint = null;
            int _numEquipPoints = isInitialised ? numEquipPoints : NumberOfEquipPoints;

            if (guidHash != 0 && _numEquipPoints > 0)
            {
                // Attempt to find a matching guidHash
                for (int eqptIdx = 0; eqptIdx < _numEquipPoints; eqptIdx++)
                {
                    if (equipPointList[eqptIdx].guidHash == guidHash)
                    {
                        equipPoint = equipPointList[eqptIdx]; break;
                    }
                }
            }

            return equipPoint;
        }

        /// <summary>
        /// Return the zero-based index of a EquipPoint in the list using
        /// the unique guidHash. Returns -1 if not found.
        /// </summary>
        /// <param name="guidHash"></param>
        /// <returns></returns>
        public int GetEquipPointIndex (int guidHash)
        {
            int equipPointIndex = -1;
            int _numEquipPoints = isInitialised ? numEquipPoints : NumberOfEquipPoints;

            if (guidHash != 0 && _numEquipPoints > 0)
            {
                // Attempt to find a matching guidHash
                for (int eqptIdx = 0; eqptIdx < _numEquipPoints; eqptIdx++)
                {
                    if (equipPointList[eqptIdx].guidHash == guidHash)
                    {
                        equipPointIndex = eqptIdx; break;
                    }
                }
            }

            return equipPointIndex;
        }

        /// <summary>
        /// Get a Equip Point from the zero-based index from the list.
        /// </summary>
        /// <param name="equipPointIndex"></param>
        /// <returns></returns>
        public S3DEquipPoint GetEquipPointByIndex (int equipPointIndex)
        {
            if (equipPointIndex >= 0 && equipPointIndex < (isInitialised ? numEquipPoints : NumberOfEquipPoints))
            {
                return equipPointList[equipPointIndex];
            }
            else { return null; }
        }

        /// <summary>
        /// Get a Equip Point by name. This will likely impact GC so don't use in an Update loop
        /// or get it each frame. Where possible, use GetEquipPoint() or GetEquipPointByIndex().
        /// </summary>
        /// <param name="regionName">The case-sensitive name of the equip point</param>
        /// <returns></returns>
        public S3DEquipPoint GetEquipPointIndexByName (string equipPointName)
        {
            if (string.IsNullOrEmpty(equipPointName) && equipPointList != null)
            {
                // The Find will create GC for each S3DEquipPoint it searches
                // and each name string comparison.
                return equipPointList.Find(eqpt => eqpt.equipPointName == equipPointName);
            }
            else { return null; }
        }

        /// <summary>
        /// Get the world space position of an equip point.
        /// If the point is null or the parentTransform of the point
        /// is null, this will return the current position of the character.
        /// </summary>
        /// <param name="equipPoint"></param>
        /// <returns></returns>
        public Vector3 GetEquipPointPosition (S3DEquipPoint equipPoint)
        {
            if (equipPoint != null && equipPoint.parentTransform != null)
            {
                return S3DUtils.GetWorldPosition(equipPoint.parentTransform, equipPoint.relativeOffset);
            }
            else { return GetCurrentPosition; }
        }

        /// <summary>
        /// Get the world space rotation of an equip point.
        /// If the point is null or the parentTransform of the point
        /// is null, this will return the current position of the character.
        /// </summary>
        /// <param name="equipPoint"></param>
        /// <returns></returns>
        public Quaternion GetEquipPointRotation (S3DEquipPoint equipPoint)
        {
            if (equipPoint != null && equipPoint.parentTransform != null)
            {
                // Rotate around the local space fwd direction of the equip parent transform
                return equipPoint.parentTransform.rotation * Quaternion.Euler(equipPoint.relativeRotation);
            }
            else { return GetCurrentRotation; }
        }

        /// <summary>
        /// Find the first equip point with at least one available slot
        /// </summary>
        /// <returns></returns>
        public S3DEquipPoint GetFirstAvailableEquipPoint()
        {
            S3DEquipPoint equipPoint = null;

            if (isEquipInitialised)
            {
                for (int eqptIdx = 0; eqptIdx < numEquipPoints; eqptIdx++)
                {
                    S3DEquipPoint _equipPoint = equipPointList[eqptIdx];

                    if (_equipPoint.storeItemList.Count < _equipPoint.maxItems && _equipPoint.parentTransform != null)
                    {
                        equipPoint = _equipPoint; break;
                    }
                }
            }

            return equipPoint;
        }

        /// <summary>
        /// Find the first equip point with at least one available slot and is compatible with
        /// the interactive-enabled object. The interactive tag will be compared with those
        /// that are permitted for the Equip Point.
        /// </summary>
        /// <param name="stickyInteractive"></param>
        /// <returns></returns>
        public S3DEquipPoint GetFirstAvailableEquipPoint (StickyInteractive stickyInteractive)
        {
            S3DEquipPoint equipPoint = null;

            if (isEquipInitialised && numEquipPoints > 0 && stickyInteractive != null)
            {
                for (int eqptIdx = 0; eqptIdx < numEquipPoints; eqptIdx++)
                {
                    S3DEquipPoint _equipPoint = equipPointList[eqptIdx];

                    if (_equipPoint.storeItemList.Count < _equipPoint.maxItems && _equipPoint.parentTransform != null && stickyInteractive.CheckCanBeEquipped(this, _equipPoint))
                    {
                        equipPoint = _equipPoint; break;
                    }
                }
            }

            return equipPoint;
        }

        /// <summary>
        /// Find the first zero-based equip point index with at least one available slot.
        /// Returns -1 if not found.
        /// </summary>
        /// <returns></returns>
        public int GetFirstAvailableEquipPointIndex()
        {
            int equipPointIndex = -1;

            if (isEquipInitialised)
            {
                for (int eqptIdx = 0; eqptIdx < numEquipPoints; eqptIdx++)
                {
                    S3DEquipPoint _equipPoint = equipPointList[eqptIdx];

                    if (_equipPoint.storeItemList.Count < _equipPoint.maxItems && _equipPoint.parentTransform != null)
                    {
                        equipPointIndex = eqptIdx; break;
                    }
                }
            }

            return equipPointIndex;
        }

        /// <summary>
        /// Find the first zero-based equip point index with at least one available slot and is compatible with
        /// the interactive-enabled object. The interactive tag will be compared with those that are permitted
        /// for the Equip Point. Returns -1 if not found.
        /// </summary>
        /// <param name="stickyInteractive"></param>
        /// <returns></returns>
        public int GetFirstAvailableEquipPointIndex (StickyInteractive stickyInteractive)
        {
            int equipPointIndex = -1;

            if (isEquipInitialised && numEquipPoints > 0 && stickyInteractive != null)
            {
                for (int eqptIdx = 0; eqptIdx < numEquipPoints; eqptIdx++)
                {
                    S3DEquipPoint _equipPoint = equipPointList[eqptIdx];

                    if (_equipPoint.storeItemList.Count < _equipPoint.maxItems && _equipPoint.parentTransform != null && stickyInteractive.CheckCanBeEquipped(this, _equipPoint))
                    {
                        equipPointIndex = eqptIdx; break;
                    }
                }
            }

            return equipPointIndex;
        }

        /// <summary>
        /// Attempt to find the last added interactive object on the given Equip Point, that is compatible
        /// with the given Socket.
        /// </summary>
        /// <param name="equipPoint"></param>
        /// <param name="stickySocket"></param>
        /// <returns></returns>
        public S3DStoreItem GetLastSocketableEquipItem (S3DEquipPoint equipPoint, StickySocket stickySocket)
        {
            S3DStoreItem storeItem = null;

            if (isEquipInitialised && numEquipPoints > 0 && equipPoint != null && stickySocket != null)
            {
                int numEquipItems = equipPoint.storeItemList.Count;
                
                // Loop backward to find the most recent added item
                for (int eqIdx = numEquipItems - 1; eqIdx >= 0; eqIdx--)
                {
                    S3DStoreItem _storeItem = equipPoint.storeItemList[eqIdx];

                    if (stickySocket.CanAddItem(_storeItem.stickyInteractive))
                    {
                        storeItem = _storeItem;
                        break;
                    }
                }
            }

            return storeItem;
        }

        /// <summary>
        /// Attempt to get an interactive object found on an Equip Point from the
        /// left-hand side of the character.
        /// </summary>
        public S3DStoreItem GetLeftSideEquippedItem()
        {
            S3DStoreItem storeItem = null;

            if (isEquipInitialised && numEquipPoints > 0)
            {
                for (int eqptIdx = 0; eqptIdx < numEquipPoints; eqptIdx++)
                {
                    S3DEquipPoint _equipPoint = equipPointList[eqptIdx];

                    // Is this equip point on the left hand side AND contains at least 1 item?
                    if (_equipPoint.relativeOffset.x < 0f && _equipPoint.storeItemList.Count > 0)
                    {
                        storeItem = _equipPoint.storeItemList[0];
                        break;
                    }
                }
            }

            return storeItem;
        }

        /// <summary>
        /// Attempt to get a StickyWeapon found on an Equip Point from the
        /// left-hand side of the character.
        /// </summary>
        /// <returns></returns>
        public S3DStoreItem GetLeftSideEquippedWeapon()
        {
            S3DStoreItem storeItem = null;

            if (isEquipInitialised && numEquipPoints > 0)
            {
                for (int eqptIdx = 0; eqptIdx < numEquipPoints; eqptIdx++)
                {
                    S3DEquipPoint _equipPoint = equipPointList[eqptIdx];

                    // Is this equip point on the left hand side AND contains at least 1 item?
                    if (_equipPoint.relativeOffset.x < 0f && _equipPoint.storeItemList.Count > 0)
                    {
                        S3DStoreItem _storeItem = _equipPoint.storeItemList[0];
                        if (_storeItem.IsStickyWeapon)
                        {
                            storeItem = _storeItem;
                            break;
                        }
                    }
                }
            }

            return storeItem;
        }

        /// <summary>
        /// Attempt to get an interactive object found on an Equip Point from the
        /// right-hand side of the character.
        /// </summary>
        public S3DStoreItem GetRightSideEquippedItem()
        {
            S3DStoreItem storeItem = null;

            if (isEquipInitialised && numEquipPoints > 0)
            {
                for (int eqptIdx = 0; eqptIdx < numEquipPoints; eqptIdx++)
                {
                    S3DEquipPoint _equipPoint = equipPointList[eqptIdx];

                    // Is this equip point on the left hand side AND contains at least 1 item?
                    if (_equipPoint.relativeOffset.x > 0f && _equipPoint.storeItemList.Count > 0)
                    {
                        storeItem = _equipPoint.storeItemList[0];
                        break;
                    }
                }
            }

            return storeItem;
        }

        /// <summary>
        /// Attempt to get a StickyWeapon found on an Equip Point from the
        /// right-hand side of the character.
        /// </summary>
        /// <returns></returns>
        public S3DStoreItem GetRightSideEquippedWeapon()
        {
            S3DStoreItem storeItem = null;

            if (isEquipInitialised && numEquipPoints > 0)
            {
                for (int eqptIdx = 0; eqptIdx < numEquipPoints; eqptIdx++)
                {
                    S3DEquipPoint _equipPoint = equipPointList[eqptIdx];

                    // Is this equip point on the right hand side AND contains at least 1 item?
                    if (_equipPoint.relativeOffset.x > 0f && _equipPoint.storeItemList.Count > 0)
                    {
                        S3DStoreItem _storeItem = _equipPoint.storeItemList[0];
                        if (_storeItem.IsStickyWeapon)
                        {
                            storeItem = _storeItem;
                            break;
                        }
                    }
                }
            }

            return storeItem;
        }

        /// <summary>
        /// Attempt to grab the first equipped item from the specified left or right-hand
        /// side of the character with the specified left or right hand.
        /// </summary>
        /// <param name="isLeftHand"></param>
        public void GrabEquipped (bool isLeftHand)
        {
            if (isEquipInitialised && numEquipPoints > 0)
            {
                if (!isAnimateEnabled)
                {
                    #if UNITY_EDITOR
                    Debug.LogWarning("GrabEquipped - " + name + " cannot grab equipped item because animate is not enabled");
                    #endif
                }
                else if (isLeftHand && leftHandInteractiveId != StickyInteractive.NoID || !isLeftHand && rightHandInteractiveId != StickyInteractive.NoID)
                {
                    #if UNITY_EDITOR
                    Debug.LogWarning("GrabEquipped - " + name + " cannot grab equipped item because they are already holding an interactive-enabled object in their " + (isLeftHand ? "left hand" : "right hand"));
                    #endif
                }
                else
                {
                    S3DStoreItem storeItem = isLeftHand ? GetLeftSideEquippedItem() : GetRightSideEquippedItem();

                    GrabEquipped(storeItem, isLeftHand);
                }
            }
        }

        /// <summary>
        /// Attempt to grab an equipped item with the specified left or right hand.
        /// </summary>
        /// <param name="storeItem"></param>
        /// <param name="isLeftHand"></param>
        public void GrabEquipped (S3DStoreItem storeItem, bool isLeftHand)
        {
            // Find the Equip Point it belongs to
            S3DEquipPoint equipPoint = FindEquipPoint(storeItem);

            if (equipPoint != null)
            {
                StickyInteractive stickyInteractive = storeItem.stickyInteractive;

                // Check if the interactive object is still in the process of being equipped,
                // when it is trying to be grabbed from the Equip Point.
                if (stickyInteractive.IsEquipFinaliseDelayed)
                {
                    StopDelayEquip(stickyInteractive);
                }

                // Remove the item from equip point
                equipPoint.storeItemList.Remove(storeItem);

                GrabInteractive(stickyInteractive, isLeftHand, false);

                // The preGrabParent transform with be incorrectly set to the equip point parent on the character.
                if (stickyInteractive.isReparentOnDrop)
                {
                    stickyInteractive.PreGrabParentTfrm = stickyInteractive.PreEquippedParentTfrm;
                    stickyInteractive.PreEquippedParentTfrm = null;
                }
            }
        }

        /// <summary>
        /// Attempt to grab the first equipped item from the left-hand side of the
        /// character with the left hand.
        /// </summary>
        public void GrabLeftHandEquipped()
        {
            GrabEquipped(true);
        }

        /// <summary>
        /// Attempt to grab the first equipped item from the right-hand side of the
        /// character with the right hand.
        /// </summary>
        public void GrabRightHandEquipped()
        {
            GrabEquipped(false);
        }

        /// <summary>
        /// Set the parent transform of the Equip Point using the zero-based index
        /// </summary>
        /// <param name="equipPointIndex"></param>
        /// <param name="parentTransform"></param>
        public void SetEquipPointTransform (int equipPointIndex, Transform parentTransform)
        {
            if (equipPointIndex >= 0 && equipPointIndex < (isInitialised ? numEquipPoints : NumberOfEquipPoints))
            {
                if (parentTransform == null) { equipPointList[equipPointIndex].parentTransform = null; }
                else if (!parentTransform.IsChildOf(transform))
                {
                    #if UNITY_EDITOR
                    Debug.LogWarning("ERROR: stickyControlModule.SetEquipPointTransform - the parentTransform must be a child of " + name);
                    #endif
                }
                else { equipPointList[equipPointIndex].parentTransform = parentTransform; }
            }
        }

        /// <summary>
        /// Reinitialise the Equip points. These hold inactive interactive objects
        /// attached to the body of the character.
        /// </summary>
        public void ReinitialiseEquip()
        {
            ValidateEquipPoints();
            isEquipInitialised = true;
        }

        /// <summary>
        /// If a weapon is held in the specified hand, attempt to equip it
        /// to the first available equip point on the same side of the character.
        /// If a weapon is NOT held in the specified hand, attempt to get it
        /// from the first equip point on that side of the character with a weapon
        /// attached.
        /// </summary>
        /// <param name="isLeftHand"></param>
        public void ToggleEquipGrabWeapon (bool isLeftHand)
        {
            if (isLeftHand)
            {
                if (isLeftHandHoldingWeapon)
                {
                    if (leftHandWeapon != null)
                    {
                        EquipItemFromHand(true);
                    }
                }
                else
                {
                    GrabEquipped(GetLeftSideEquippedWeapon(), true);
                }
            }
            else
            {
                if (isRightHandHoldingWeapon)
                {
                    if (rightHandWeapon != null)
                    {
                        EquipItemFromHand(false);
                    }
                }
                else
                {
                    GrabEquipped(GetRightSideEquippedWeapon(), false);
                }
            }
        }

        /// <summary>
        /// Ensure the Equip Points are correctly configured. If the equipped items
        /// have been changed, call ReinitialiseEquip() instead.
        /// </summary>
        public void ValidateEquipPoints()
        {
            if (equipPointList == null) { equipPointList = new List<S3DEquipPoint>(2); }

            numEquipPoints = equipPointList.Count;
        }

        #endregion

        #region Public API Methods - Engage (Grab)

        /// <summary>
        /// Attempt to grab the most recent item added to the socket that the character is looking toward
        /// with the specified left or right hand.
        /// </summary>
        /// <param name="isLeftHand"></param>
        /// <returns></returns>
        public bool GrabFromLookingAtSocket (bool isLeftHand)
        {
            bool hasGrabbed = false;

            if (CheckLookingAtSocket())
            {
                if (isLeftHand) { GrabLeftHandFromSocket(lookingAtSocket); }
                else { GrabRightHandFromSocket(lookingAtSocket); }
            }

            return hasGrabbed;
        }

        /// <summary>
        /// Attempt to grab the most recent item added to the socket that the character is looking toward
        /// with the specified left or right hand. Same as GrabFromLookingAtSocket(..)
        /// except can be called from a StickyInputModule custom input event. 
        /// </summary>
        /// <param name="isLeftHand"></param>
        public void GrabFromLookingAtSocketNoReturn (bool isLeftHand)
        {
            GrabFromLookingAtSocket (isLeftHand);
        }

        /// <summary>
        /// Attempt to grab the last added StickyInteractive item to the socket
        /// with the left hand. This will ignore any items recently added but
        /// already removed from the socket.
        /// </summary>
        /// <param name="stickySocket"></param>
        public void GrabLeftHandFromSocket (StickySocket stickySocket)
        {
            GrabFromSocket(stickySocket, true);
        }

        /// <summary>
        /// Attempt to grab the interactive-enabled object with the left hand using
        /// the primary hand hold position on the object.
        /// Grabbed objects become unselected if they were previously selected.
        /// </summary>
        /// <param name="stickyInteractive"></param>
        public void GrabLeftHandInteractive (StickyInteractive stickyInteractive)
        {
            GrabInteractive(stickyInteractive, true, false);
        }

        /// <summary>
        /// Grab the interactive-enabled object currently being looked at (if any)
        /// with the left hand.
        /// Use the primary or secondary hand hold position on the object.
        /// Grabbed objects become unselected if they were previously selected.
        /// </summary>
        public void GrabLeftHandLookedAtInteractive (bool isSecondaryHandHold)
        {
            GrabLookedAtInteractive(true, isSecondaryHandHold);
        }

        /// <summary>
        /// Grab the interactive-enabled object currently being looked at (if any).
        /// Use the primary hand hold position on the object.
        /// Grabbed objects become unselected if they were previously selected.
        /// </summary>
        public void GrabLookedAtInteractive (bool isLeftHand)
        {
            GrabLookedAtInteractive(isLeftHand, false);
        }

        /// <summary>
        /// Attempt to grab the last added stickyInteractive item to the socket
        /// with the right hand. This will ignore any items recently added but
        /// already removed from the socket.
        /// </summary>
        /// <param name="stickySocket"></param>
        public void GrabRightHandFromSocket (StickySocket stickySocket)
        {
            GrabFromSocket(stickySocket, false);
        }

        /// <summary>
        /// Attempt to grab the interactive-enabled object with the right hand using
        /// the primary hand hold position on the object.
        /// Grabbed objects become unselected if they were previously selected.
        /// </summary>
        /// <param name="stickyInteractive"></param>
        public void GrabRightHandInteractive (StickyInteractive stickyInteractive)
        {
            GrabInteractive(stickyInteractive, false, false);
        }

        /// <summary>
        /// Grab the interactive-enabled object currently being looked at (if any)
        /// with the right hand.
        /// Use the primary or secondary hand hold position on the object.
        /// Grabbed objects become unselected if they were previously selected.
        /// </summary>
        public void GrabRightHandLookedAtInteractive (bool isSecondaryHandHold)
        {
            GrabLookedAtInteractive(false, isSecondaryHandHold);
        }

        /// <summary>
        /// Grab an interactive-enabled object in the left or right hand.
        /// Use the primary or secondary hand hold on the object.
        /// Grabbed objects become unselected if they were previously selected.
        /// </summary>
        /// <param name="stickyInteractive"></param>
        /// <param name="isLeftHand"></param>
        /// <param name="isSecondaryHandHold"></param>
        public void GrabInteractive (StickyInteractive stickyInteractive, bool isLeftHand, bool isSecondaryHandHold)
        {
            // v1.1.0 HandIK shouldn't be required to grab an non-touchable object unless you want to parent it to a hand.
            if (isInitialised && isAnimateEnabled && stickyInteractive != null)
            {
                if (stickyInteractive.IsGrabbable)
                {
                    // If the interactive-enable object is already selected, remove it from the list
                    RemoveSelectedInteractiveID(stickyInteractive.StickyInteractiveID);

                    HoldInteractive(stickyInteractive, isLeftHand, isSecondaryHandHold);
                }
                #if UNITY_EDITOR
                else { Debug.LogWarning("StickyControlModule.GrabInteractive " + name + " cannot grab " + lookingAtInteractive.name + " because it is not Grabbable"); }
                #endif
            }
        }

        #endregion

        #region Public API Methods - Engage (Respawn)

        /// <summary>
        /// Returns the position for the character to respawn at.
        /// </summary>
        /// <returns></returns>
        public Vector3 GetRespawnPosition()
        {
            if (respawnMode == RespawningMode.RespawnAtLastPosition)
            {
                return currentRespawnPosition;
            }
            else if (respawnMode == RespawningMode.RespawnAtOriginalPosition)
            {
                return currentRespawnPosition;
            }
            else if (respawnMode == RespawningMode.RespawnAtSpecifiedPosition)
            {
                return customRespawnPosition;
            }
            else { return Vector3.zero; }
        }

        /// <summary>
        /// Returns the rotation for the character to respawn with.
        /// </summary>
        /// <returns></returns>
        public Quaternion GetRespawnRotation()
        {
            if (respawnMode == RespawningMode.RespawnAtLastPosition)
            {
                return currentRespawnRotation;
            }
            else if (respawnMode == RespawningMode.RespawnAtOriginalPosition)
            {
                return currentRespawnRotation;
            }
            else if (respawnMode == RespawningMode.RespawnAtSpecifiedPosition)
            {
                return Quaternion.Euler(customRespawnRotation);
            }
            else { return Quaternion.identity; }
        }

        /// <summary>
        /// If the character is currently respawning, this will stop
        /// the countdown timer, preventing the character from respawning
        /// until ResumeRespawning() is called.
        /// NOTE: Has no effect if not already respawning.
        /// </summary>
        public void PauseRespawning()
        {
            if (isRespawning) { isRespawingPaused = true; }
        }

        /// <summary>
        /// Re-initialises respawn variables using the current position and rotation of the character
        /// </summary>
        public void ReinitialiseRespawnVariables()
        {
            // Initialise current respawn position/rotation
            currentRespawnPosition = currentWorldPosition;
            currentRespawnRotation = currentWorldRotation;
        }

        /// <summary>
        /// If respawning is currently paused, the respawning
        /// timer will now continue until the character is respawned.
        /// NOTE: Has no effect if respawningMode is DontRespawn
        /// </summary>
        public void ResumeRespawning()
        {
            isRespawingPaused = false;
        }

        public void SetMaxLives(int newValue)
        {
            if (newValue < 0) { maxLives = 0; }
            else { maxLives = newValue; }

            if (currentLives > maxLives) { currentLives = maxLives; }
        }


        public void SetRespawnMode(RespawningMode newMode)
        {
            respawnMode = newMode;

            ReinitialiseRespawnVariables();
        }

        public void SetStartLives(int newValue)
        {
            if (newValue < -1) { startLives = -1; }
            else
            {
                startLives = newValue;

                if (maxLives < startLives) { SetMaxLives(startLives); }
            }
        }


        #endregion

        #region Public API Methods - Engage (Socket)

        /// <summary>
        /// Attempt to Equip an interactive-enabled object on the first available Equip Point,
        /// with the most recent item added to the socket that the character is looking toward.
        /// Returns the Equip Point StoreItemID or S3DStoreItem.NoStoreItem.
        /// </summary>
        /// <returns></returns>
        public int LookAtSocketFromEquip()
        {
            int storeItemID = S3DStoreItem.NoStoreItem;

            if (CheckLookingAtSocket())
            {
                StickySocket stickySocket = lookingAtSocket;
                StopLookAtSocket();

                storeItemID = SocketFromEquip(stickySocket);
            }

            return storeItemID;
        }

        /// <summary>
        /// Attempt to Equip an interactive-enabled object on the first available Equip Point,
        /// with the most recent item added to the socket that the character is looking toward.
        /// Same as LookAtSocketFromEquip(), except can be called from a StickyInputModule custom input event. 
        /// </summary>
        public void LookAtSocketFromEquipNoReturn()
        {
            LookAtSocketFromEquip();
        }

        /// <summary>
        /// If the character is looking at a StickySocket, attempt to place the interactive
        /// object in the left hand into the socket.
        /// Returns the storeItemID for the item attached to the socket.
        /// If no held object is added to the socket, S3DStoreItem.NoStoreItem is returned.
        /// </summary>
        /// <returns></returns>
        public int LookAtSocketFromLeftHand()
        {
            int storeItemID = S3DStoreItem.NoStoreItem;

            if (CheckLookingAtSocket())
            {
                StickySocket stickySocket = lookingAtSocket;
                StopLookAtSocket();

                storeItemID = SocketFromLeftHand(stickySocket);
            }

            return storeItemID;
        }

        /// <summary>
        /// If the character is looking at a StickySocket, attempt to place the interactive
        /// object in the left hand into the socket.
        /// Same as LookAtSocketFromLeftHand(..), except can be called from
        /// a StickyInputModule custom input event.
        /// </summary>
        public void LookAtSocketFromLeftHandNoReturn()
        {
            LookAtSocketFromLeftHand();
        }

        /// <summary>
        /// If the character is looking at a StickySocket, attempt to place the interactive
        /// object in the right hand into the socket.
        /// Returns the storeItemID for the item attached to the socket.
        /// If no held object is added to the socket, S3DStoreItem.NoStoreItem is returned.
        /// </summary>
        /// <returns></returns>
        public int LookAtSocketFromRightHand()
        {
            int storeItemID = S3DStoreItem.NoStoreItem;

            if (CheckLookingAtSocket())
            {
                StickySocket stickySocket = lookingAtSocket;
                StopLookAtSocket();

                storeItemID = SocketFromRightHand(stickySocket);
            }

            return storeItemID;
        }

        /// <summary>
        /// If the character is looking at a StickySocket, attempt to place the interactive
        /// object in the right hand into the socket.
        /// Same as LookAtSocketFromRightHand(..), except can be called from
        /// a StickyInputModule custom input event.
        /// </summary>
        public void LookAtSocketFromRightHandNoReturn()
        {
            LookAtSocketFromRightHand();
        }

        /// <summary>
        /// If the character is looking at a StickySocket, attempt to place the most
        /// recently stashed compatible interactive object into the socket.
        /// Returns the storeItemID for the item attached to the socket.
        /// If no stashed object is added to the socket, S3DStoreItem.NoStoreItem is returned.
        /// </summary>
        /// <returns></returns>
        public int LookedAtSocketFromStash()
        {
            int storeItemID = S3DStoreItem.NoStoreItem;

            if (CheckLookingAtSocket())
            {
                StickySocket stickySocket = lookingAtSocket;
                StopLookAtSocket();

                storeItemID = SocketFromStash(stickySocket);
            }

            return storeItemID;
        }

        /// <summary>
        /// If the character is looking at a StickySocket, attempt to place the most
        /// recently stashed compatible interactive object into the socket.
        /// Same as LookedAtSocketFromStash(..), except can be called from
        /// a StickyInputModule custom input event.
        /// </summary>
        public void LookedAtSocketFromStashNoReturn()
        {
            LookedAtSocketFromStash();
        }

        /// <summary>
        /// Attempt to find the first Equipped interactive object that is compatible with the
        /// given socket, and attach it to the socket.
        /// Returns the storeItemID for the item attached to the socket.
        /// If no equipped object is added to the socket, S3DStoreItem.NoStoreItem is returned.
        /// </summary>
        /// <param name="stickySocket"></param>
        /// <returns></returns>
        public int SocketFromEquip (StickySocket stickySocket)
        {
            int storeItemID = S3DStoreItem.NoStoreItem;

            if (stickySocket == null)
            {
                #if UNITY_EDITOR
                Debug.LogWarning("[ERROR] SocketFromEquip - " + name + " cannot place equipped object in the socket because the socket is null");
                #endif
            }
            else if (isEquipInitialised)
            {
                // Loop though the Equip Points on the character
                for (int eqptIdx = 0; eqptIdx < numEquipPoints; eqptIdx++)
                {
                    S3DEquipPoint _equipPoint = equipPointList[eqptIdx];

                    // Attempt to find an equip point with an interactive object that is compatible with the socket
                    S3DStoreItem _storeItem = GetLastSocketableEquipItem(_equipPoint, stickySocket);

                    if (_storeItem != null)
                    {
                        StickyInteractive stickyInteractive = _storeItem.stickyInteractive;

                        // Remove from Equip Point

                        if (lassoSpeed > 0f)
                        {
                            stickyInteractive.IsLassoEnabled = true;
                            stickyInteractive.LassoSocket = stickySocket;
                            stickyInteractive.LassoCharacter = this;
                            stickyInteractive.LassoEquipPoint = _equipPoint;

                            // DetachColliders will happen when the object is finally snapped to the socket.
                            // We don't want the interactive colliders to be seen as a external collider
                            // while it is being moved (over time) from the equip point toward the socket. 
                        }
                        else
                        {
                            DetachColliders(stickyInteractive.Colliders);
                        }

                        _equipPoint.storeItemList.Remove(_storeItem);
                        stickyInteractive.IsEquipped = false;

                        // Add to socket
                        storeItemID = stickySocket.AddItem(_storeItem.stickyInteractive);
                        break;
                    }
                }
            }

            return storeItemID;
        }

        /// <summary>
        /// Attempt to find the first Equipped interactive object that is compatible with the
        /// given socket, and attach it to the socket.
        /// Same as SocketFromEquip(..), except can be called from a StickyInputModule custom input event.
        /// </summary>
        /// <param name="stickySocket"></param>
        public void SocketFromEquipNoReturn (StickySocket stickySocket)
        {
            SocketFromEquip(stickySocket);
        }

        /// <summary>
        /// Attempt to place the interactive-enabled object held in the left hand,
        /// into the StickySocket.
        /// Returns the storeItemID for the item attached to the socket.
        /// If it is not added, S3DStoreItem.NoStoreItem is returned.
        /// </summary>
        /// <param name="stickySocket"></param>
        /// <returns></returns>
        public int SocketFromLeftHand (StickySocket stickySocket)
        {
            int storeItemID = S3DStoreItem.NoStoreItem;

            if (CheckHandToSocket(stickySocket, true))
            {
                if (lassoSpeed > 0f)
                {
                    leftHandInteractive.IsLassoEnabled = true;
                    leftHandInteractive.LassoSocket = stickySocket;
                    leftHandInteractive.LassoCharacter = this;
                    leftHandInteractive.LassoEquipPoint = null;

                    // See also: stickySocket.ParentInteractive(..) and stickySocket.AddInteractiveFinalise(..)
                    // LassoInteractiveToSocket(..) is called from stickySocket.AddInteractiveFinalise(..).
                }
                else
                {
                    // Unregister the active colliders BEFORE socket.AddItem(..)
                    DetachColliders(leftHandInteractive.Colliders);
                }

                storeItemID = stickySocket.AddItem(leftHandInteractive);

                if (storeItemID != S3DStoreItem.NoStoreItem) { ClearHoldingInteractive(true); }

                // If lasso was not enabled above, turn back on weapon firing
                // IsLassoEnabled could have been set to false already, so use lassoSpeed.
                if (lassoSpeed == 0f)
                {
                    UnpauseWeaponsFiring(0.1f);
                }
            }

            return storeItemID;
        }

        /// <summary>
        /// Attempt to place the interactive-enabled object held in the left hand,
        /// into the StickySocket.
        /// Same as SocketFromLeftHand(..), except can be called from
        /// a StickyInputModule custom input event.
        /// </summary>
        /// <param name="stickySocket"></param>
        public void SocketFromLeftHandNoReturn (StickySocket stickySocket)
        {
            SocketFromLeftHand(stickySocket);
        }

        /// <summary>
        /// Attempt to place the interactive-enabled object held in the right hand,
        /// into the StickySocket.
        /// Returns the storeItemID for the item attached to the socket.
        /// If it is not added, S3DStoreItem.NoStoreItem is returned.
        /// </summary>
        /// <param name="stickySocket"></param>
        /// <returns></returns>
        public int SocketFromRightHand (StickySocket stickySocket)
        {
            int storeItemID = S3DStoreItem.NoStoreItem;

            if (CheckHandToSocket(stickySocket, false))
            {
                if (lassoSpeed > 0f)
                {
                    rightHandInteractive.IsLassoEnabled = true;
                    rightHandInteractive.LassoSocket = stickySocket;
                    rightHandInteractive.LassoCharacter = this;
                    rightHandInteractive.LassoEquipPoint = null;

                    // See also: stickySocket.ParentInteractive(..) and stickySocket.AddInteractiveFinalise(..)
                    // LassoInteractiveToSocket(..) is called from stickySocket.AddInteractiveFinalise(..).
                }
                else
                {
                    // Unregister the active colliders BEFORE socket.AddItem(..)
                    DetachColliders(rightHandInteractive.Colliders);
                }

                // If any weapons are held, firing will be paused while objects are added to a socket.
                PauseWeaponsFiring();

                storeItemID = stickySocket.AddItem(rightHandInteractive);

                if (storeItemID != S3DStoreItem.NoStoreItem) { ClearHoldingInteractive(false); }

                // If lasso was not enabled above, turn back on weapon firing
                // IsLassoEnabled could have been set to false already, so use lassoSpeed.
                if (lassoSpeed == 0f)
                {
                    UnpauseWeaponsFiring(0.1f);
                }
            }

            return storeItemID;
        }

        /// <summary>
        /// Attempt to place the interactive-enabled object held in the right hand,
        /// into the StickySocket.
        /// Same as SocketFromRightHand(..), except can be called from
        /// a StickyInputModule custom input event.
        /// </summary>
        /// <param name="stickySocket"></param>
        public void SocketFromRightHandNoReturn (StickySocket stickySocket)
        {
            SocketFromRightHand(stickySocket);
        }

        /// <summary>
        /// Attempt to find the most recently Stashed interactive object that is compatible with
        /// the given socket, and attach it to the socket.
        /// Returns the storeItemID for the item attached to the socket.
        /// If no stashed object is added to the socket, S3DStoreItem.NoStoreItem is returned.
        /// </summary>
        /// <param name="stickySocket"></param>
        /// <returns></returns>
        public int SocketFromStash (StickySocket stickySocket)
        {
            int storeItemID = S3DStoreItem.NoStoreItem;

            if (stickySocket == null)
            {
                #if UNITY_EDITOR
                Debug.LogWarning("[ERROR] SocketFromSocket - " + name + " cannot place stashed object in the socket because the socket is null");
                #endif
            }
            else if (isStashInitialised)
            {
                S3DStoreItem storeItem = GetLastSocketableStashItem(stickySocket, StickyInteractive.NoID);

                if (storeItem != null)
                {
                    StickyInteractive stickyInteractive = storeItem.stickyInteractive;

                    // Remove from Stash
                    stashList.Remove(storeItem);
                    numStashedItems = stashList.Count;
                    stickyInteractive.IsStashed = false;

                    // Add to socket
                    storeItemID = stickySocket.AddItem(stickyInteractive);

                    // finally, turn it back on
                    if (!stickyInteractive.gameObject.activeSelf) { stickyInteractive.gameObject.SetActive(true); }

                }
            }

            return storeItemID;
        }

        /// <summary>
        /// Attempt to find the most recently Stashed interactive object that is compatible with
        /// the given socket, and attach it to the socket.
        /// Same as SocketFromStash(..), except can be called from a StickyInputModule custom input event.
        /// </summary>
        /// <param name="stickySocket"></param>
        public void SocketFromStashNoReturn (StickySocket stickySocket)
        {
            SocketFromStash(stickySocket);
        }

        #endregion

        #region Public API Methods - Engage (Stash)

        /// <summary>
        /// Destroy the StoreItem.
        /// </summary>
        /// <param name="storeItem"></param>
        public void DestroyStashItem(S3DStoreItem storeItem)
        {
            if (storeItem != null)
            {
#if UNITY_EDITOR
                DestroyImmediate(storeItem.stickyInteractive.gameObject);
#else
                Destroy(storeItem.stickyInteractive.gameObject);
#endif

                stashList.Remove(storeItem);

                numStashedItems = stashList.Count;
            }
        }

        /// <summary>
        /// Destroy the store item given a S3DStoreItem.StoreItemId.
        /// </summary>
        /// <param name="storeItemID"></param>
        /// <returns></returns>
        public void DestroyStashItem(int storeItemID)
        {
            DestroyStashItem(GetStashItem(storeItemID));
        }

        /// <summary>
        /// Drop all the stashed items.
        /// </summary>
        public void DropStashAll()
        {
            // How may stashed items when drop begins?
            int _numStashedItems = NumberOfStashItems;

            // Drop starting from last in the list
            for (int sIdx = _numStashedItems - 1; sIdx >= 0; sIdx--)
            {
                DropStashItem(stashList[sIdx].StoreItemID);
            }
        }

        /// <summary>
        /// Drop an interactive object currently stashed by the character.
        /// </summary>
        /// <param name="storeItemId"></param>
        public void DropStashItem(int storeItemId)
        {
            if (storeItemId != S3DStoreItem.NoStoreItem)
            {
                S3DStoreItem storeItem = GetStashItem(storeItemId);

                if (storeItem != null && storeItem.stickyInteractiveID != StickyInteractive.NoID)
                {
                    StickyInteractive stashedItem = storeItem.stickyInteractive;

                    DetachColliders(stashedItem.Colliders);

                    // Get a random position and rotation near the character
                    Vector3 placeRot = Vector3.zero;

                    Vector3 placePos = GetRandomPositionXZ(radius + minStashDropDistance, radius + maxStashDropDistance);
                    placePos.y = 0.5f;

                    placeRot.y = miscS3DRandom.Range(0f, 360f);
                    placeRot.z = miscS3DRandom.Range(-20f, 20f);

                    stashedItem.transform.localPosition = placePos;
                    stashedItem.transform.localRotation = Quaternion.Euler(placeRot);

                    stashedItem.DropObject(capsuleColliderId);

                    // Remove the item from stash
                    stashList.Remove(storeItem);

                    numStashedItems = stashList.Count;

                    // finally, turn it back on
                    if (!stashedItem.gameObject.activeSelf) { stashedItem.gameObject.SetActive(true); }
                }
            }
        }

        /// <summary>
        /// Drop an interactive object currently stashed by the character.
        /// </summary>
        /// <param name="stashItem"></param>
        public void DropStashItem(StickyInteractive stashItem)
        {
            if (stashItem != null)
            {
                // Is this item in stashed on this character?
                DropStashItem(GetStashItemID(stashItem.StickyInteractiveID));
            }
        }

        /// <summary>
        /// Get the S3DStoreItem of the first Grabbable item that was Stashed.
        /// Ignores items that have already been removed or one with a matching
        /// IgnoreInteractiveID.
        /// </summary>
        /// <param name="IgnoreInteractiveID">When 0, this value has no effect</param>
        /// <returns></returns>
        public S3DStoreItem GetFirstGrabbableStashItem(int IgnoreInteractiveID)
        {
            S3DStoreItem storeItem = null;

            if (isStashInitialised && numStashedItems > 0)
            {
                // Loop through the stash and find the first grabbable
                // item that was stashed.
                for (int sIdx = 0; sIdx < numStashedItems; sIdx++)
                {
                    if (stashList[sIdx].stickyInteractive.IsGrabbable && stashList[sIdx].stickyInteractive.StickyInteractiveID != IgnoreInteractiveID)
                    {
                        storeItem = stashList[sIdx];
                        break;
                    }
                }
            }

            return storeItem;
        }

        /// <summary>
        /// Get the S3DStoreItem of the last Grabbable item that was Stashed.
        /// Ignores items that have already been removed or one with a matching
        /// IgnoreInteractiveID.
        /// </summary>
        /// <param name="IgnoreInteractiveID">When 0, this value has no effect</param>
        /// <returns></returns>
        public S3DStoreItem GetLastGrabbableStashItem(int IgnoreInteractiveID)
        {
            S3DStoreItem storeItem = null;

            if (isStashInitialised && numStashedItems > 0)
            {
                // Loop backward through the stash and find the last grabbable
                // item that was stashed.
                for (int sIdx = numStashedItems - 1; sIdx >= 0; sIdx--)
                {
                    if (stashList[sIdx].stickyInteractive.IsGrabbable && stashList[sIdx].stickyInteractive.StickyInteractiveID != IgnoreInteractiveID)
                    {
                        storeItem = stashList[sIdx];
                        break;
                    }
                }
            }

            return storeItem;
        }

        /// <summary>
        /// Get the S3DStoreItem of the last compatible Socketable item that was Stashed.
        /// Ignores items that have already been removed or one with a matching IgnoreInteractiveID.
        /// Returns the storeItemID for the Stashed item.
        /// If no stashed object is found, S3DStoreItem.NoStoreItem is returned.
        /// </summary>
        /// <param name="equipPoint"></param>
        /// <param name="stickySocket"></param>
        /// <returns></returns>
        public S3DStoreItem GetLastSocketableStashItem (StickySocket stickySocket, int IgnoreInteractiveID)
        {
            S3DStoreItem storeItem = null;

            if (isStashInitialised && numStashedItems > 0)
            {
                // Loop backward through the stash and find the most recently added socketable
                // item that was stashed.
                for (int sIdx = numStashedItems - 1; sIdx >= 0; sIdx--)
                {
                    S3DStoreItem _storeItem = stashList[sIdx];
                    StickyInteractive _stickyInteractive = _storeItem.stickyInteractive;

                    if (_stickyInteractive.IsSocketable && _stickyInteractive.StickyInteractiveID != IgnoreInteractiveID && stickySocket.CanAddItem(_stickyInteractive))
                    {
                        storeItem = stashList[sIdx];
                        break;
                    }
                }
            }

            return storeItem;
        }

        /// <summary>
        /// Get the S3DStoreItem of the last item that was Stashed.
        /// Ignores items that have already been removed.
        /// </summary>
        /// <returns></returns>
        public S3DStoreItem GetLastStashitem()
        {
            if (isStashInitialised && numStashedItems > 0)
            {
                return stashList[numStashedItems - 1];
            }
            else { return null; }
        }

        /// <summary>
        /// Get the StoreItemID of the last item that was Stashed.
        /// Ignores items that have already been removed.
        /// </summary>
        /// <returns></returns>
        public int GetLastStashitemID()
        {
            if (isStashInitialised && numStashedItems > 0)
            {
                return stashList[numStashedItems - 1].StoreItemID;
            }
            else { return S3DStoreItem.NoStoreItem; }
        }

        /// <summary>
        /// Get the StickyInteractiveID of the last item that was Stashed.
        /// Ignores items that have already been removed.
        /// </summary>
        /// <returns></returns>
        public int GetLastStashInteractiveID()
        {
            if (isStashInitialised && numStashedItems > 0)
            {
                return stashList[numStashedItems - 1].stickyInteractiveID;
            }
            else { return StickyInteractive.NoID; }
        }

        /// <summary>
        /// Get the last stashed Magazine of a given MagType, that has an ammoType from the
        /// array provided. For performance reasons, the types are provided as their
        /// integer values from the enumerations.
        /// Return the storeItemID or S3DStoreItem.NoStoreItem
        /// </summary>
        /// <param name="magTypeInt"></param>
        /// <param name="compatibleAmmoTypes"></param>
        /// <param name="allowEmpty">Can the magazine be empty?</param>
        /// <returns>The storeItemID or S3DStoreItem.NoStoreItem</returns>
        public int GetLastStashMagazineItemID(int magTypeInt, int[] compatibleAmmoTypes, bool allowEmpty)
        {
            int storeItemID = S3DStoreItem.NoStoreItem;

            if (isStashInitialised && magTypeInt >= 0 && magTypeInt < 26)
            {
                // Loop backward so we get the last compatible item stashed.
                for (int sIdx = numStashedItems - 1; sIdx >= 0; sIdx--)
                {
                    StickyInteractive stickyInteractive = stashList[sIdx].stickyInteractive;

                    // Skip if not a magazine
                    if (stickyInteractive.IsStickyMagazine)
                    {
                        StickyMagazine stickyMagazine = (StickyMagazine)stickyInteractive;

                        // If the mag is empty and we don't want those, skip this one
                        if (!allowEmpty && stickyMagazine.IsEmpty) { continue; }

                        // The magazine type AND ammo type must match
                        if (stickyMagazine.IsMagazineCompatible(magTypeInt) && stickyMagazine.IsAmmoCompatible(compatibleAmmoTypes))
                        {
                            storeItemID = stashList[sIdx].StoreItemID;
                            break;
                        }
                    }
                }
            }

            return storeItemID;
        }

        /// <summary>
        /// Get the store item given a S3DStoreItem.StoreItemId.
        /// </summary>
        /// <param name="storeItemID"></param>
        /// <returns></returns>
        public S3DStoreItem GetStashItem(int storeItemID)
        {
            S3DStoreItem storeItem = null;

            if (isStashInitialised && numStashedItems > 0)
            {
                for (int sIdx = 0; sIdx < numStashedItems; sIdx++)
                {
                    if (stashList[sIdx].StoreItemID == storeItemID)
                    {
                        storeItem = stashList[sIdx];
                        break;
                    }
                }
            }

            return storeItem;
        }

        /// <summary>
        /// Get the StoreItemID of an interactive-enabled object using the StickyInteractiveID.
        /// Returns the StoreItemID or S3DStoreItem.NoStoreItem.
        /// </summary>
        /// <param name="stickyInteractiveID"></param>
        /// <returns></returns>
        public int GetStashItemID(int stickyInteractiveID)
        {
            int storeItemID = S3DStoreItem.NoStoreItem;

            if (isStashInitialised && stickyInteractiveID != StickyManager.NoPrefabID)
            {
                for (int sIdx = 0; sIdx < numStashedItems; sIdx++)
                {
                    if (stashList[sIdx].stickyInteractiveID == stickyInteractiveID)
                    {
                        storeItemID = stashList[sIdx].StoreItemID;
                        break;
                    }
                }
            }

            return storeItemID;
        }

        /// <summary>
        /// Get the StoreItemID of an interactive-enabled object using a StickyInteractive item.
        /// Returns the StoreItemID or S3DStoreItem.NoStoreItem.
        /// </summary>
        /// <param name="stashItem"></param>
        /// <returns></returns>
        public int GetStashItemID(StickyInteractive stashItem)
        {
            if (stashItem == null) { return S3DStoreItem.NoStoreItem; }
            else { return GetStashItemID(stashItem.StickyInteractiveID); }
        }

        /// <summary>
        /// Get the number of magazines in the Stash of a given MagType, and has an ammoType from the
        /// array provided. For performance reasons, the types are provided as their integer values from the enumerations.
        /// </summary>
        /// <param name="magTypeInt"></param>
        /// <param name="compatibleAmmoTypes"></param>
        /// <param name="allowEmpty"></param>
        /// <returns></returns>
        public int GetNumberStashedMagazines(int magTypeInt, int[] compatibleAmmoTypes, bool allowEmpty)
        {
            int numberOfItems = 0;

            // Check stash is initialised and mag type is valid
            if (isStashInitialised && magTypeInt >= 0 && magTypeInt < 26)
            {
                for (int sIdx = 0; sIdx < numStashedItems; sIdx++)
                {
                    StickyInteractive stickyInteractive = stashList[sIdx].stickyInteractive;

                    // Skip if not a magazine
                    if (stickyInteractive.IsStickyMagazine)
                    {
                        StickyMagazine stickyMagazine = (StickyMagazine)stickyInteractive;

                        // If the mag is empty and we don't want those, skip this one
                        if (!allowEmpty && stickyMagazine.IsEmpty) { continue; }

                        // The magazine type AND ammo type must match
                        if (stickyMagazine.IsMagazineCompatible(magTypeInt) && stickyMagazine.IsAmmoCompatible(compatibleAmmoTypes))
                        {
                            numberOfItems++;
                        }
                    }
                }
            }

            return numberOfItems;
        }

        /// <summary>
        /// Get the last grabbable item that was stashed, and grab it with the left or right hand.
        /// If there are no grabbable items stashed or the hand is already holding an interactive
        /// object, the method will do nothing.
        /// NOTE: Animate must be enabled to grab items.
        /// </summary>
        /// <param name="isLeftHand"></param>
        public void GrabItemFromStash(bool isLeftHand)
        {
            if (isStashInitialised && numStashedItems > 0)
            {
                if (!isAnimateEnabled)
                {
#if UNITY_EDITOR
                    Debug.LogWarning("GrabItemFromStash - " + name + " cannot grab last stashed item because animate is not enabled");
#endif
                }
                else if (isLeftHand && leftHandInteractiveId != StickyInteractive.NoID || !isLeftHand && rightHandInteractiveId != StickyInteractive.NoID)
                {
#if UNITY_EDITOR
                    Debug.LogWarning("GrabItemFromStash - " + name + " cannot grab last stashed item because they are already holding an interactive-enabled object in their " + (isLeftHand ? "left hand" : "right hand"));
#endif
                }
                else
                {
                    S3DStoreItem storeItem = GetLastGrabbableStashItem(StickyInteractive.NoID);

                    if (storeItem != null)
                    {
                        StickyInteractive stickyInteractive = storeItem.stickyInteractive;

                        GrabInteractive(stickyInteractive, isLeftHand, false);

                        // The preGrabParent transform with be incorrectly set to the stash parent on the character.
                        if (stickyInteractive.isReparentOnDrop)
                        {
                            stickyInteractive.PreGrabParentTfrm = stickyInteractive.PreStashParentTfrm;
                            stickyInteractive.PreStashParentTfrm = null;
                        }

                        // Remove the item from stash
                        stashList.Remove(storeItem);

                        numStashedItems = stashList.Count;

                        // finally, turn it back on
                        if (!stickyInteractive.gameObject.activeSelf) { stickyInteractive.gameObject.SetActive(true); }
                    }
                }
            }
        }

        /// <summary>
        /// Reinitialise the Stash (inventory). This is automatically called when the character
        /// is initialised.
        /// </summary>
        public void ReinitialiseStash()
        {
            isStashInitialised = false;

            if (numStashedItems == 0)
            {
                if (stashList == null) { stashList = new List<S3DStoreItem>(); }
            }
            else
            {
                stashList.Clear();
            }

            if (stashParent != null)
            {
                // The Stash must be initialised before items can be added.
                isStashInitialised = true;

                if (tempStickyInteractiveList == null) { tempStickyInteractiveList = new List<StickyInteractive>(5); }
                else { tempStickyInteractiveList.Clear(); }

                stashParent.GetComponentsInChildren(true, tempStickyInteractiveList);

                int numItemsFound = tempStickyInteractiveList.Count;

                // Re-add any items back into the stash
                for (int sIdx = 0; sIdx < numItemsFound; sIdx++)
                {
                    StickyInteractive _stickyInteractive = tempStickyInteractiveList[sIdx];

                    // If the item isn't stashable, make it so.
                    if (!_stickyInteractive.IsStashable) { _stickyInteractive.SetIsStashable(true); }

                    // If the item is not initialised, attempt to do that now
                    if (!_stickyInteractive.IsInitialised) { _stickyInteractive.Initialise(); }

                    StashItem(_stickyInteractive);
                }

                tempStickyInteractiveList.Clear();
            }
            else
            {
                numStashedItems = 0;
            }
        }

        /// <summary>
        /// Set the child transform under which all items are stashed
        /// </summary>
        /// <param name="newStashParent"></param>
        public void SetStashParent(Transform newStashParent)
        {
            // Ensure it is a child of the character
            if (newStashParent != null && !newStashParent.IsChildOf(transform))
            {
                stashParent = null;

                #if UNITY_EDITOR
                Debug.LogWarning("Stash parent must be a child of the parent " + name + " gameobject or part of the prefab.");
                #endif
            }
            else
            {
                stashParent = newStashParent;
            }

            ReinitialiseStash();
        }

        /// <summary>
        /// Attempt to stash the most recent item added to the socket that the
        /// character is looking toward.
        /// Returns the Stash StoreItemID or S3DStoreItem.NoStoreItem.
        /// </summary>
        /// <returns></returns>
        public int StashFromLookedAtSocket()
        {
            int storeItemID = S3DStoreItem.NoStoreItem;

            if (CheckLookingAtSocket())
            {
                storeItemID = StashFromSocket(lookingAtSocket);
            }

            return storeItemID;
        }

        /// <summary>
        /// Attempt to stash the most recent item added to the socket that the
        /// character is looking toward.
        /// Same as StashFromLookedAtSocket(), except can be called from
        /// a StickyInputModule custom input event. 
        /// </summary>
        public void StashFromLookedAtSocketNoReturn()
        {
            StashFromLookedAtSocket();
        }

        /// <summary>
        /// Attempt to stash the most recent item added to the socket.
        /// Returns the Stash StoreItemID or S3DStoreItem.NoStoreItem.
        /// </summary>
        /// <param name="stickySocket"></param>
        /// <returns></returns>
        public int StashFromSocket (StickySocket stickySocket)
        {
            int storeItemID = S3DStoreItem.NoStoreItem;

            if (stickySocket != null)
            {
                StickyInteractive lastAddedItem = stickySocket.GetLastInteractive();

                if (lastAddedItem != null && lastAddedItem.CheckCanBeStashed(this))
                {
                    stickySocket.RemoveInteractive(lastAddedItem.StickyInteractiveID, false, false);
                    storeItemID = StashItem(lastAddedItem);
                }
            }

            return storeItemID;
        }

        /// <summary>
        /// Attempt to stash the most recent item added to the socket.
        /// Same as StashFromSocket(..), except can be called from
        /// a StickyInputModule custom input event.
        /// </summary>
        /// <param name="stickySocket"></param>
        public void StashFromSocketNoReturn (StickySocket stickySocket)
        {
            StashFromSocket(stickySocket);
        }

        /// <summary>
        /// Add an interactive item to the stash (inventory).
        /// Returns the StoreItemID or S3DStoreItem.NoStoreItem.
        /// TODO - check if it exceeds item count or mass limit
        /// </summary>
        /// <param name="itemToStash"></param>
        public int StashItem (StickyInteractive itemToStash)
        {
            int storeItemID = S3DStoreItem.NoStoreItem;

            if (isStashInitialised && itemToStash != null)
            {
                int itemToStashInteractiveID = itemToStash.StickyInteractiveID;

                if (itemToStash.StashObject(this))
                {
                    // Was this previously held by this character in left hand?
                    if (itemToStashInteractiveID == leftHandInteractiveId)
                    {
                        leftHandInteractiveId = StickyInteractive.NoID;
                        leftHandInteractive = null;

                        leftHandWeapon = null;
                        isLeftHandHoldingWeapon = false;
                        // Turn off if not holding a weapon in either hand
                        EnableOrDisableAimIK(isRightHandHoldingWeapon, false);
                        leftHandMagazine = null;
                        isLeftHandHoldingMagazine = false;
                    }

                    // Was this previously held by this character in right hand?
                    if (itemToStashInteractiveID == rightHandInteractiveId)
                    {
                        rightHandInteractiveId = StickyInteractive.NoID;
                        rightHandInteractive = null;

                        rightHandWeapon = null;
                        isRightHandHoldingWeapon = false;
                        // Turn off if not holding a weapon in either hand
                        EnableOrDisableAimIK(isLeftHandHoldingWeapon, false);
                        rightHandMagazine = null;
                        isRightHandHoldingMagazine = false;
                    }

                    // If currently looking at the item to be stashed, stop doing that.
                    if (itemToStashInteractiveID == lookingAtInteractiveId)
                    {
                        StopLookAtInteractive();
                    }

                    S3DStoreItem storeItem = new S3DStoreItem()
                    {
                        stickyInteractive = itemToStash,
                        stickyInteractiveID = itemToStash.StickyInteractiveID
                    };

                    itemToStash.Sticky3DCharacter = this;
                    itemToStash.IsStashed = true;

                    // Deactivate the interactive item
                    if (itemToStash.gameObject.activeSelf)
                    {
                        itemToStash.gameObject.SetActive(false);
                    }

                    stashList.Add(storeItem);

                    numStashedItems++;

                    // Is the object already held by the character
                    if (itemToStash.isReparentOnDrop && itemToStash.PreGrabParentTfrm != null)
                    {
                        itemToStash.PreStashParentTfrm = itemToStash.PreGrabParentTfrm;
                        itemToStash.PreGrabParentTfrm = null;
                    }
                    else
                    {
                        // Always remember the previous parent transform
                        itemToStash.PreStashParentTfrm = itemToStash.transform.parent;
                        itemToStash.PreGrabParentTfrm = null;
                    }

                    // Always parent it to the character stash transform
                    itemToStash.transform.SetParent(stashParent);

                    // Reset the local position and rotation
                    // Strangely, the z-axis rotation is always 360 after it is set.
                    itemToStash.transform.SetPositionAndRotation(stashParent.position, stashParent.rotation);
                    //itemToStash.transform.localPosition = Vector3.zero;
                    //itemToStash.transform.localRotation = Quaternion.identity;

                    storeItemID = storeItem.StoreItemID;

                    // Finally, call the Post Stash events (if any). The last param is currently not used.
                    itemToStash.PostStashObject(StickyID, storeItemID, Vector3.zero);
                }
            }

            return storeItemID;
        }

        /// <summary>
        /// Attempt to Stash a StickyInteractive item.
        /// A fire and forget version of StashItem(..). Can be called from
        /// a StickyInputModule custom input event.
        /// </summary>
        /// <param name="itemToStash"></param>
        public void StashItemNoReturn(StickyInteractive itemToStash)
        {
            StashItem(itemToStash);
        }

        /// <summary>
        /// If the character is holding an interactive object in their hand,
        /// attempt to add it to the Stash (inventory).
        /// See also StashItemFromLeftHand() and StashItemFromRightHand().
        /// This has no return code, so can be called from a StickyInputModule
        /// custom input event. 
        /// </summary>
        /// <param name="isLeftHand"></param>
        public void StashItemFromHand(bool isLeftHand)
        {
            if (isLeftHand) { StashItemFromLeftHand(); }
            else { StashItemFromRightHand(); }
        }

        /// <summary>
        /// If the character is holding an interactive object in their left hand,
        /// attempt to add it to the Stash (inventory).
        /// Returns the StoreItemID or S3DStoreItem.NoStoreItem.
        /// </summary>
        /// <returns></returns>
        public int StashItemFromLeftHand()
        {
            if (isStashInitialised && leftHandInteractiveId != StickyInteractive.NoID)
            {
                return StashItem(leftHandInteractive);
            }
            else { return S3DStoreItem.NoStoreItem; }
        }

        /// <summary>
        /// If the character is holding an interactive object in their left hand,
        /// attempt to add it to the Stash (inventory).
        /// Returns the StoreItemID or S3DStoreItem.NoStoreItem.
        /// </summary>
        /// <returns></returns>
        public int StashItemFromRightHand()
        {
            if (isStashInitialised && rightHandInteractiveId != StickyInteractive.NoID)
            {
                return StashItem(rightHandInteractive);
            }
            else { return S3DStoreItem.NoStoreItem; }
        }

        /// <summary>
        /// Attempt to stash the interactive-enabled (if any) item being looked at.
        /// Returns the StoreItemID or S3DStoreItem.NoStoreItem.
        /// </summary>
        /// <returns></returns>
        public int StashLookedAtInteractive()
        {
            int storeItemID = S3DStoreItem.NoStoreItem;

            if (lookingAtInteractiveId != StickyInteractive.NoID)
            {
                storeItemID = StashItem(lookingAtInteractive);
            }

            return storeItemID;
        }

        /// <summary>
        /// Attempt to stash the interactive-enabled (if any) item being looked at.
        /// Same as StashLookedAtInteractive(), except can be called from
        /// a StickyInputModule custom input event. 
        /// </summary>
        public void StashLookedAtInteractiveNoReturn()
        {
            StashLookedAtInteractive();
        }

        /// <summary>
        /// If holding an item, attempt to Stash it. Then hold the next available
        /// grabbable item from Stash. If no other items are Stashed, the character
        /// will no longer be holding an item in the hand indicated.
        /// </summary>
        /// <param name="isLeftHand"></param>
        public void SwitchStashedItem(bool isLeftHand)
        {
            if (isStashInitialised)
            {
                bool isHoldingItem = isLeftHand ? leftHandInteractiveId != StickyInteractive.NoID : rightHandInteractiveId != StickyInteractive.NoID;

                int currentInteractiveId = StickyInteractive.NoID;
                bool wasStashed = false;

                // If the character is holding an interactive object in the hand indicated, Stash it.
                if (isHoldingItem)
                {
                    currentInteractiveId = isLeftHand ? leftHandInteractiveId : rightHandInteractiveId;

                    if (isLeftHand)
                    {
                        wasStashed = StashItemFromLeftHand() != S3DStoreItem.NoStoreItem;
                    }
                    else
                    {
                        wasStashed = StashItemFromRightHand() != S3DStoreItem.NoStoreItem;
                    }
                }

                // If the character was holding an item, make sure it got stashed before
                // attempting to get another one from the Stash. Ideally, the stash should
                // have a max mass or max number of items in a category.
                if (!isHoldingItem || wasStashed)
                {
                    S3DStoreItem storeItem = null;

                    storeItem = GetFirstGrabbableStashItem(currentInteractiveId);

                    if (storeItem != null)
                    {
                        if (!isAnimateEnabled)
                        {
#if UNITY_EDITOR
                            Debug.LogWarning(name + " cannot grab stashed item because animate is not enabled");
#endif
                        }
                        else
                        {
                            StickyInteractive stickyInteractive = storeItem.stickyInteractive;

                            GrabInteractive(stickyInteractive, isLeftHand, false);

                            // The preGrabParent transform with be incorrectly set to the stash parent on the character.
                            if (stickyInteractive.isReparentOnDrop)
                            {
                                stickyInteractive.PreGrabParentTfrm = stickyInteractive.PreStashParentTfrm;
                                stickyInteractive.PreStashParentTfrm = null;
                            }

                            // Remove the item from stash
                            stashList.Remove(storeItem);

                            numStashedItems = stashList.Count;

                            // finally, turn it back on
                            if (!stickyInteractive.gameObject.activeSelf) { stickyInteractive.gameObject.SetActive(true); }
                        }
                    }
                }
            }
        }

        #endregion

        #region Public API Methods - Engage (Weapons)

        /// <summary>
        /// Get the number of magazines held in the left, right or both hands of a given MagType,
        /// and has an ammoType from the array provided. Currently the maxium number would be 2
        /// (one in each hand). For performance reasons, the types are provided as their integer
        /// values from the enumerations.
        /// </summary>
        /// <param name="magTypeInt"></param>
        /// <param name="compatibleAmmoTypes"></param>
        /// <param name="allowEmpty"></param>
        /// <returns></returns>
        public int GetNumberHeldMagazines(int magTypeInt, int[] compatibleAmmoTypes, bool allowEmpty)
        {
            int numberOfItems = 0;

            // Check mag type is valid
            if (magTypeInt >= 0 && magTypeInt < 26)
            {
                // Is left hand holding a magazine which is either not empty or permitted?
                if (isLeftHandHoldingMagazine && (allowEmpty || !leftHandMagazine.IsEmpty))
                {
                    // The magazine type AND ammo type must match
                    if (leftHandMagazine.IsMagazineCompatible(magTypeInt) && leftHandMagazine.IsAmmoCompatible(compatibleAmmoTypes))
                    {
                        numberOfItems++;
                    }
                }

                // Is right hand holding a magazine which is either not empty or permitted?
                if (isRightHandHoldingMagazine && (allowEmpty || !rightHandMagazine.IsEmpty))
                {
                    // The magazine type AND ammo type must match
                    if (rightHandMagazine.IsMagazineCompatible(magTypeInt) && rightHandMagazine.IsAmmoCompatible(compatibleAmmoTypes))
                    {
                        numberOfItems++;
                    }
                }
            }

            return numberOfItems;
        }

        /// <summary>
        /// Pause weapons that are held
        /// </summary>
        public void PauseWeapons()
        {
            if (isLeftHandHoldingWeapon)
            {
                leftHandWeapon.PauseWeapon();
            }

            if (isRightHandHoldingWeapon)
            {
                rightHandWeapon.PauseWeapon();
            }
        }

        /// <summary>
        /// Prevent weapons that are held from firing
        /// </summary>
        public void PauseWeaponsFiring()
        {
            // Cancel any outstanding invokes that will unpause the weapons from firing.
            CancelInvoke("UnPauseWeaponsFiring");

            if (isLeftHandHoldingWeapon)
            {
                leftHandWeapon.SetIsFiringPaused(true);
            }

            if (isRightHandHoldingWeapon)
            {
                rightHandWeapon.SetIsFiringPaused(true);
            }
        }

        /// <summary>
        /// Attempt to reload a weapon held in the left hand.
        /// </summary>
        /// <param name="weaponButtonNumber"></param>
        public void ReloadWeaponLeftHand(int weaponButtonNumber = 1)
        {
            if (!isLeftHandHoldingWeapon)
            {
#if UNITY_EDITOR
                Debug.LogWarning("The character (" + name + ") cannot reload because they are not holding a weapon in their left hand");
#endif
            }
            else if (weaponButtonNumber == 1 || weaponButtonNumber == 2)
            {
                leftHandWeapon.Reload(weaponButtonNumber);
            }
#if UNITY_EDITOR
            else { Debug.LogWarning("ERROR: The character (" + name + ") can only reload the primary (1) or secondary (2) firing button mechanisms."); }
#endif
        }

        /// <summary>
        /// Attempt to reload a weapon held in the right hand.
        /// </summary>
        /// <param name="weaponButtonNumber"></param>
        public void ReloadWeaponRightHand(int weaponButtonNumber = 1)
        {
            if (!isRightHandHoldingWeapon)
            {
#if UNITY_EDITOR
                Debug.LogWarning("The character (" + name + ") cannot reload because they are not holding a weapon in their right hand");
#endif
            }
            else if (weaponButtonNumber == 1 || weaponButtonNumber == 2)
            {
                rightHandWeapon.Reload(weaponButtonNumber);
            }
#if UNITY_EDITOR
            else { Debug.LogWarning("ERROR: The character (" + name + ") can only reload the primary (1) or secondary (2) firing button mechanisms."); }
#endif
        }

        /// <summary>
        /// Initialise or reinitialise weapon settings for this character.
        /// NOTE: Currently this does NOT reinitialise the actual weapons.
        /// </summary>
        public void ReinitialiseWeapons()
        {
            if (leftHandWeaponInput == null) { leftHandWeaponInput = new WeaponInput(); }
            else { leftHandWeaponInput.SetClassDefaults(); }

            if (rightHandWeaponInput == null) { rightHandWeaponInput = new WeaponInput(); }
            else { rightHandWeaponInput.SetClassDefaults(); }
        }

        /// <summary>
        /// If the character is holding a weapon, attempt to start aiming down the sights or through the Scope.
        /// </summary>
        /// <param name="isLeftHand"></param>
        public void StartAimingWeapon(bool isLeftHand)
        {
            if (isLeftHand)
            {
                if (isLeftHandHoldingWeapon)
                {
                    leftHandWeapon.StartAiming(true);
                }
#if UNITY_EDITOR
                else { Debug.LogWarning(name + " is not holding a weapon in their left hand so cannot start aiming."); }
#endif
            }
            else if (isRightHandHoldingWeapon)
            {
                rightHandWeapon.StartAiming(true);
            }
#if UNITY_EDITOR
            else { Debug.LogWarning(name + " is not holding a weapon in their right hand so cannot start aiming."); }
#endif
        }

        /// <summary>
        /// If the character is holding a weapon, stop aiming down the sights or through the Scope.
        /// </summary>
        /// <param name="isLeftHand"></param>
        public void StopAimingWeapon(bool isLeftHand)
        {
            if (isLeftHand)
            {
                if (isLeftHandHoldingWeapon)
                {
                    leftHandWeapon.StopAiming(true);
                }
#if UNITY_EDITOR
                else { Debug.LogWarning(name + " is not holding a weapon in their left hand so cannot stop aiming."); }
#endif
            }
            else if (isRightHandHoldingWeapon)
            {
                rightHandWeapon.StopAiming(true);
            }
#if UNITY_EDITOR
            else { Debug.LogWarning(name + " is not holding a weapon in their right hand so cannot stop aiming."); }
#endif
        }

        /// <summary>
        /// If holding a weapon, attempt to Stash it. Then hold the next available
        /// grabbable weapon from Stash. If no other weapons are Stashed, then
        /// the character will no longer be holding a weapon in the
        /// hand indicated.
        /// </summary>
        /// <param name="isLeftHand"></param>
        public void SwitchStashedWeapon(bool isLeftHand)
        {
            if (isStashInitialised)
            {
                bool isHoldingWeapon = isLeftHand ? isLeftHandHoldingWeapon : isRightHandHoldingWeapon;

                int currentWeaponId = StickyInteractive.NoID;
                bool wasStashed = false;

                // If the character is holding a weapon in the hand indicated, Stash it.
                if (isHoldingWeapon)
                {
                    currentWeaponId = isLeftHand ? leftHandInteractiveId : rightHandInteractiveId;

                    if (isLeftHand)
                    {
                        wasStashed = StashItemFromLeftHand() != S3DStoreItem.NoStoreItem;
                    }
                    else
                    {
                        wasStashed = StashItemFromRightHand() != S3DStoreItem.NoStoreItem;
                    }
                }

                // If the character was holding a weapon, make sure it got stashed before
                // attempting to get another one from the Stash. Ideally, the stash should
                // have a max mass or max number of items in a category.
                if (!isHoldingWeapon || wasStashed)
                {
                    S3DStoreItem storeItem = null;
                    bool isFoundOtherWeapon = false;

                    for (int sIdx = 0; sIdx < numStashedItems; sIdx++)
                    {
                        StickyInteractive storedInteractive = stashList[sIdx].stickyInteractive;

                        // Find the first grabbable weapon that isn't the one we just stashed
                        if (storedInteractive.IsGrabbable && storedInteractive.IsStickyWeapon && storedInteractive.StickyInteractiveID != currentWeaponId)
                        {
                            storeItem = stashList[sIdx];
                            isFoundOtherWeapon = true;
                            break;
                        }
                    }

                    // Use a bool to avoid a null comparison
                    if (isFoundOtherWeapon)
                    {
                        if (!isAnimateEnabled)
                        {
#if UNITY_EDITOR
                            Debug.LogWarning(name + " cannot grab stashed weapon because animate is not enabled");
#endif
                        }
                        else
                        {
                            StickyInteractive stickyInteractive = storeItem.stickyInteractive;

                            GrabInteractive(stickyInteractive, isLeftHand, false);

                            // The preGrabParent transform with be incorrectly set to the stash parent on the character.
                            if (stickyInteractive.isReparentOnDrop)
                            {
                                stickyInteractive.PreGrabParentTfrm = stickyInteractive.PreStashParentTfrm;
                                stickyInteractive.PreStashParentTfrm = null;
                            }

                            // Remove the item from stash
                            stashList.Remove(storeItem);

                            numStashedItems = stashList.Count;

                            // finally, turn it back on
                            if (!stickyInteractive.gameObject.activeSelf) { stickyInteractive.gameObject.SetActive(true); }
                        }
                    }
                }
            }
        }

        /// <summary>
        /// If the character is holding a weapon, enable or disable the character aiming down the sights or through the Scope.
        /// </summary>
        /// <param name="isLeftHand"></param>
        public void ToggleAimWeapon(bool isLeftHand)
        {
            if (isLeftHand)
            {
                if (isLeftHandHoldingWeapon)
                {
                    leftHandWeapon.ToggleAiming();
                }
#if UNITY_EDITOR
                else { Debug.LogWarning(name + " is not holding a weapon in their left hand so cannot toggle aiming on or off."); }
#endif
            }
            else if (isRightHandHoldingWeapon)
            {
                rightHandWeapon.ToggleAiming();
            }
#if UNITY_EDITOR
            else { Debug.LogWarning(name + " is not holding a weapon in their right hand so cannot toggle aiming on or off."); }
#endif
        }

        /// <summary>
        /// If the character is holding a weapon, and it has an equipped laser sight,
        /// turn it on or off.
        /// </summary>
        /// <param name="isLeftHand"></param>
        public void ToggleLaserSight(bool isLeftHand)
        {
            if (isLeftHand)
            {
                if (isLeftHandHoldingWeapon)
                {
                    leftHandWeapon.ToggleLaserSight();
                }
#if UNITY_EDITOR
                else { Debug.LogWarning(name + " is not holding a weapon in their left hand so cannot toggle the Laser Sight on or off."); }
#endif
            }
            else if (isRightHandHoldingWeapon)
            {
                rightHandWeapon.ToggleLaserSight();
            }
#if UNITY_EDITOR
            else { Debug.LogWarning(name + " is not holding a weapon in their right hand so cannot toggle the Laser Sight on or off."); }
#endif
        }

        /// <summary>
        /// If the character is holding a weapon, and it has an equipped Scope for more precise visual aiming,
        /// turn it on or off.
        /// </summary>
        /// <param name="isLeftHand"></param>
        public void ToggleWeaponScope(bool isLeftHand)
        {
            if (isLeftHand)
            {
                if (isLeftHandHoldingWeapon)
                {
                    leftHandWeapon.ToggleScope();
                }
#if UNITY_EDITOR
                else { Debug.LogWarning(name + " is not holding a weapon in their left hand so cannot toggle the Scope on or off."); }
#endif
            }
            else if (isRightHandHoldingWeapon)
            {
                rightHandWeapon.ToggleScope();
            }
#if UNITY_EDITOR
            else { Debug.LogWarning(name + " is not holding a weapon in their right hand so cannot toggle the Scope on or off."); }
#endif
        }

        /// <summary>
        /// Attempt to resume weapons that are held
        /// </summary>
        public void UnpauseWeapons()
        {
            if (isLeftHandHoldingWeapon)
            {
                leftHandWeapon.UnpauseWeapon();
            }

            if (isRightHandHoldingWeapon)
            {
                rightHandWeapon.UnpauseWeapon();
            }
        }

        /// <summary>
        /// Allow weapons that are held to fire after a period of delay in seconds.
        /// Delay period should be between 0.0 and 3 seconds.
        /// Will not unpause weapon firing if there is a popup associated with this character.
        /// Set GetActivePopupID().
        /// </summary>
        public void UnpauseWeaponsFiring (float delay)
        {
            // Cancel any outstanding invokes on this method
            CancelInvoke("UnPauseWeaponsFiring");

            if (delay > 0f)
            {
                Invoke("UnPauseWeaponsFiring", delay);
            }
            else
            {
                UnPauseWeaponsFiring();
            }
        }

        #endregion

        #region Public Static Methods

        /// <summary>
        /// Check if this is the main capsule collider for a Sticky3D Character
        /// </summary>
        /// <param name="colliderToCheck"></param>
        /// <returns></returns>
        public static bool IsS3DCharacter (Collider colliderToCheck)
        {
            bool isCharacter = false;

            if (colliderToCheck != null)
            {
                Rigidbody rBody = colliderToCheck.attachedRigidbody;

                // All S3D characters should have a kinematic rigidbody
                if (rBody != null && rBody.isKinematic)
                {
                    StickyControlModule stickyControlModule = null;

                    if (rBody.TryGetComponent(out stickyControlModule))
                    {
                        int stickyId = stickyControlModule.StickyID;

                        // Check if this collider matches the main capsule collider for the character
                        isCharacter = stickyId != 0 && stickyId == colliderToCheck.GetInstanceID();
                    }
                }
            }

            return isCharacter;
        }

        /// <summary>
        /// Check if this is the main capsule collider for a Sticky3D Character. If so, return the StickyControlModule.
        /// </summary>
        /// <param name="colliderToCheck"></param>
        /// <param name="stickyControlModule">The S3D character's control module</param>
        /// <returns></returns>
        public static bool IsS3DCharacter (Collider colliderToCheck, out StickyControlModule stickyControlModule)
        {
            bool isCharacter = false;

            if (colliderToCheck != null)
            {
                Rigidbody rBody = colliderToCheck.attachedRigidbody;

                // All S3D characters should have a kinematic rigidbody
                if (rBody != null && rBody.isKinematic)
                {
                    if (rBody.TryGetComponent(out stickyControlModule))
                    {
                        int stickyId = stickyControlModule.StickyID;

                        // Check if this collider matches the main capsule collider for the character
                        isCharacter = stickyId != 0 && stickyId == colliderToCheck.GetInstanceID();
                    }
                    else { stickyControlModule = null; }
                }
                else { stickyControlModule = null; }
            }
            else { stickyControlModule = null; }

            return isCharacter;
        }

        /// <summary>
        /// Check if the collider belongs to a Sticky3D character.
        /// </summary>
        /// <param name="colliderToCheck"></param>
        /// <param name="includeNonWeaponHit"></param>
        /// <returns></returns>
        public static bool IsS3DCharacter (Collider colliderToCheck, bool includeNonWeaponHit)
        {
            bool isCharacter = false;

            if (colliderToCheck != null)
            {
                Rigidbody rBody = colliderToCheck.attachedRigidbody;

                // All S3D characters should have a kinematic rigidbody
                if (rBody != null && rBody.isKinematic)
                {
                    StickyControlModule stickyControlModule = null;

                    if (rBody.TryGetComponent(out stickyControlModule))
                    {
                        // Check that we didn't hit a collider on a character that should be ignored
                        isCharacter = includeNonWeaponHit || !stickyControlModule.IsColliderHittableByWeapon(colliderToCheck);
                    }
                }
            }

            return isCharacter;
        }

        #endregion
    }

    #region Public Structures

    /// <summary>
    /// Paramaters structure for CallbackOnHit (callback for Sticky Control Module).
    /// We do not recommend keeping references to any fields within this structure.
    /// Use them immediately, then discard them.
    /// </summary>
    public struct S3DCharacterHitParameters
    {
        /// <summary>
        /// Hit information for the raycast hit against the ship.
        /// </summary>
        public RaycastHit hitInfo;
        /// <summary>
        /// The S3D character that was hit
        /// </summary>
        public StickyControlModule stickyControlModule;
        /// <summary>
        /// Prefab for the projectile that hit the ship.
        /// </summary>
        public StickyProjectileModule projectilePrefab;
        /// <summary>
        /// Prefab for the beam that hit the ship
        /// </summary>
        public StickyBeamModule beamPrefab;
        /// <summary>
        /// Amount of damage done by the projectile or beam.
        /// </summary>
        public float damageAmount;
        /// <summary>
        /// The type of damage done by the projectile or beam
        /// See S3DDamageRegion.DamageType
        /// </summary>
        public int damageTypeInt;
        /// <summary>
        /// The amount of force that is applied when hitting a rigidbody at the point of impact.
        /// For projectiles, the ammo Impact Multiplier has been applied.
        /// </summary>
        public float impactForce;
        /// <summary>
        /// The 0-25 (A-Z) ammo type that was used. -1 = unset.
        /// </summary>
        public int ammoTypeInt;
        /// <summary>
        /// The faction or alliance of the character that fired the projectile belongs to.
        /// </summary>
        public int sourceFactionId;
        /// <summary>
        /// The type, category, or model of the character that fired the projectile.
        /// </summary>
        public int sourceModelId;
        /// <summary>
        /// The Id of the S3D character that fired the projectile
        /// </summary>
        public int sourceStickyId;
    };

    #endregion
}